
// Generated from Dap.g4 by ANTLR 4.13.0


#include "DapListener.h"
#include "DapVisitor.h"

#include "DapParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct DapParserStaticData final {
  DapParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  DapParserStaticData(const DapParserStaticData&) = delete;
  DapParserStaticData(DapParserStaticData&&) = delete;
  DapParserStaticData& operator=(const DapParserStaticData&) = delete;
  DapParserStaticData& operator=(DapParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag dapParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
DapParserStaticData *dapParserStaticData = nullptr;

void dapParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (dapParserStaticData != nullptr) {
    return;
  }
#else
  assert(dapParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<DapParserStaticData>(
    std::vector<std::string>{
      "parse", "sas_stmt_list", "if_stmt", "if_then_else_stmt", "delete_stmt", 
      "do_stmt", "expression", "expressionList", "of_var_list", "identifiers_list", 
      "in_var_list", "colonInts", "literal", "variables", "abort_main", 
      "abort_stmt", "file_spec", "proc_main", "proc_stmt", "proc_name", 
      "array_main", "array_stmt", "array_name", "array_subscript", "array_elements", 
      "initial_value_list", "initial_value_list_item", "initial_value_list_bk", 
      "constant_iter_value", "constant_value", "assign_main", "assign_stmt", 
      "by_main", "by_stmt", "call_main", "call_stmt", "data_main", "data_stmt", 
      "dataset_name_opt", "datastmt_cmd", "view_dsname_opt", "view_name", 
      "dataset_name", "program_name", "passwd_opt", "source_opt", "datalines_main", 
      "datalines_stmt", "datalines4_stmt", "drop_main", "drop_stmt", "infile_main", 
      "infile_stmt", "file_specification", "device_type", "infile_options", 
      "input_main", "input_stmt", "put_stmt", "input_specification", "put_specification", 
      "pointer_control", "informat_list", "input_variable_format", "input_variable", 
      "put_variable_format", "put_variable", "column_point_control", "line_point_control", 
      "format_modifier", "column_specifications", "means_main", "means_proc", 
      "run_main", "run_stmt"
    },
    std::vector<std::string>{
      "", "'**'", "'||'", "'!!'", "'of'", "'#'", "'\\u003F'", "'\\u003F\\u003F'", 
      "'&'", "'~'", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "';;;;'", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'$'", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'><'", 
      "'<>'", "", "", "", "", "", "", "", "", "", "", "", "'@'", "'='", 
      "','", "", "", "", "", "", "';'", "", "", "':'", "'%'", "'+'", "'-'", 
      "'*'", "'/'", "'|'", "'!'", "'('", "')'", "'{'", "'}'", "'['", "']'"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "", "", "ABEND", "END", "LENGTH", 
      "QKUPCASE", "SYSEVALF", "ABORT", "EVAL", "LET", "QSCAN", "SYSEXEC", 
      "ACT", "FILE", "LIST", "QSUBSTR", "SYSFUNC", "ACTIVATE", "GLOBAL", 
      "LISTM", "QSYSFUNC", "SYSGET", "BQUOTE", "GO", "LOCAL", "QUOTE", "SYSRPUT", 
      "BY", "GOTO", "MACRO", "QUPCASE", "THEN", "CLEAR", "IF", "MEND", "RESOLVE", 
      "TO", "CLOSE", "INC", "PAUSE", "RETURN", "TSO", "CMS", "INCLUDE", 
      "NRSTR", "RUN", "UNQUOTE", "COMANDR", "INDEX", "ON", "SAVE", "UNSTR", 
      "COPY", "INFILE", "OPEN", "SCAN", "UNTIL", "DEACT", "INPUT", "PUT", 
      "STOP", "UPCASE", "DEL", "KCMPRES", "NRBQUOTE", "STR", "WHILE", "DELETE", 
      "KINDEX", "NRQUOTE", "SYSCALL", "WINDOW", "DISPLAY", "KLEFT", "METASYM", 
      "SUBSTR", "DMIDSPLY", "KLENGTH", "QKCMPRES", "SUPERQ", "DMISPLIT", 
      "KSCAN", "QKLEFT", "SYMDEL", "DO", "KSUBSTR", "QKSCAN", "SYMEXIST", 
      "EDIT", "KTRIM", "QKSUBSTR", "SYMGLOBL", "ELSE", "KUPCASE", "QKTRIM", 
      "SYMLOCAL", "Tk_NULL", "CANCEL", "NOLIST", "ARRAY", "ARRAY_NUMERIC_ELEMENTS", 
      "ARRAY_CHARACTER_ELEMENTS", "ARRAY_ALL_ELEMENTS", "GROUPFORMAT", "NOTSORTED", 
      "DESCENDING", "CALL", "DEBUG", "NESTING", "STACK", "READ", "PW", "SOURCE", 
      "VIEW", "PGM", "ENCRYPT", "NOSAVE", "DATALINES", "CARDS", "LINES", 
      "DATALINES4", "CARDS4", "LINES4", "END_DATALINES4", "ALTER", "DISK", 
      "DUMMY", "GTERM", "PIPE", "PLOTTER", "PRINTER", "TAPE", "TEMP", "TERMINAL", 
      "UPRINTER", "DSD", "EXPANDTABS", "NOEXPANDTABS", "FLOWOVER", "MISSOVER", 
      "PAD", "NOPAD", "SCANOVER", "SHAREBUFFERS", "STOPOVER", "TRUNCOVER", 
      "V_INFILE_", "INPUT_ODS", "DATE", "DATETIME", "DDMMYY", "INFORMAT_COMMA", 
      "INFORMAT_CHAR", "DROP", "PROC", "ANOVA", "MEANS", "REG", "CORR", 
      "SGPLOT", "PRINT", "DATA", "Informat", "DOLLAR", "EQ", "NE", "GT", 
      "LT", "GE", "LE", "IN", "EQC", "NEC", "GTC", "LTC", "GEC", "LEC", 
      "INColon", "AND", "OR", "NOT", "MIN", "MAX", "DateLiteral", "TimeLiteral", 
      "DateTimeLiteral", "BitLiteral", "NameLiteral", "HexLiteral", "STRINGLITERAL", 
      "INT", "FloatingPointLiteral", "Identifier", "DOT", "AT", "EQUAL", 
      "COMMA", "LBracket", "RBracket", "WS", "COMMENT", "LINE_COMMENT", 
      "SEMICOLON", "OF", "MissingValueLiteral", "COLON", "PERCENT", "ADD", 
      "SUB", "MUL", "DIV", "VERLINE", "EXCLAMATION", "LParentheses", "RParentheses", 
      "LBraces", "RBraces", "LSqBracket", "RSqBracket"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,226,1097,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,1,0,5,0,152,8,0,10,0,12,
  	0,155,9,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  	1,1,1,1,1,1,1,1,1,1,3,1,177,8,1,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,1,
  	3,3,3,189,8,3,1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,
  	1,6,1,6,1,6,1,6,1,6,1,6,3,6,211,8,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,
  	6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,
  	1,6,1,6,1,6,1,6,1,6,1,6,1,6,3,6,246,8,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,
  	6,1,6,1,6,1,6,1,6,1,6,1,6,5,6,262,8,6,10,6,12,6,265,9,6,1,7,1,7,1,7,3,
  	7,270,8,7,1,7,1,7,1,7,3,7,275,8,7,5,7,277,8,7,10,7,12,7,280,9,7,1,7,1,
  	7,4,7,284,8,7,11,7,12,7,285,1,7,5,7,289,8,7,10,7,12,7,292,9,7,1,8,1,8,
  	1,8,1,8,1,8,1,8,1,8,3,8,301,8,8,1,8,1,8,1,8,5,8,306,8,8,10,8,12,8,309,
  	9,8,1,8,1,8,1,8,5,8,314,8,8,10,8,12,8,317,9,8,1,8,1,8,1,8,1,8,1,8,3,8,
  	324,8,8,1,9,1,9,1,9,1,9,4,9,330,8,9,11,9,12,9,331,1,10,1,10,1,10,1,10,
  	3,10,338,8,10,1,10,1,10,1,10,3,10,343,8,10,5,10,345,8,10,10,10,12,10,
  	348,9,10,1,10,1,10,3,10,352,8,10,1,11,1,11,1,11,1,11,1,12,1,12,1,13,1,
  	13,1,13,1,13,1,13,3,13,365,8,13,1,13,1,13,1,13,5,13,370,8,13,10,13,12,
  	13,373,9,13,1,14,5,14,376,8,14,10,14,12,14,379,9,14,1,14,1,14,1,15,1,
  	15,1,15,1,15,3,15,387,8,15,1,15,3,15,390,8,15,1,15,3,15,393,8,15,1,15,
  	3,15,396,8,15,1,15,1,15,1,16,1,16,1,17,5,17,403,8,17,10,17,12,17,406,
  	9,17,1,17,1,17,1,18,1,18,1,18,5,18,413,8,18,10,18,12,18,416,9,18,1,18,
  	1,18,1,19,1,19,1,20,5,20,423,8,20,10,20,12,20,426,9,20,1,20,1,20,1,21,
  	1,21,1,21,1,21,1,21,1,21,3,21,436,8,21,1,21,3,21,439,8,21,1,21,3,21,442,
  	8,21,1,21,3,21,445,8,21,1,21,1,21,1,22,1,22,1,23,1,23,1,23,1,23,5,23,
  	455,8,23,10,23,12,23,458,9,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,5,23,
  	467,8,23,10,23,12,23,470,9,23,3,23,472,8,23,1,24,1,24,1,24,1,24,4,24,
  	478,8,24,11,24,12,24,479,1,24,1,24,1,24,3,24,485,8,24,1,25,1,25,1,25,
  	3,25,490,8,25,1,25,5,25,493,8,25,10,25,12,25,496,9,25,1,25,1,25,1,26,
  	1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,3,26,512,8,26,
  	1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,3,27,524,8,27,1,27,
  	3,27,527,8,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,3,27,538,8,
  	27,5,27,540,8,27,10,27,12,27,543,9,27,1,27,1,27,1,28,1,28,1,29,1,29,1,
  	30,5,30,552,8,30,10,30,12,30,555,9,30,1,30,1,30,1,31,1,31,1,31,1,31,1,
  	31,1,32,5,32,565,8,32,10,32,12,32,568,9,32,1,32,1,32,1,33,1,33,3,33,574,
  	8,33,1,33,1,33,1,33,3,33,579,8,33,1,33,5,33,582,8,33,10,33,12,33,585,
  	9,33,1,33,3,33,588,8,33,1,33,3,33,591,8,33,1,33,1,33,1,34,5,34,596,8,
  	34,10,34,12,34,599,9,34,1,34,1,34,1,35,1,35,1,35,1,35,3,35,607,8,35,1,
  	35,1,35,1,35,1,36,5,36,613,8,36,10,36,12,36,616,9,36,1,36,1,36,1,37,1,
  	37,1,37,1,37,1,37,3,37,625,8,37,1,37,3,37,628,8,37,1,37,1,37,1,37,4,37,
  	633,8,37,11,37,12,37,634,1,37,3,37,638,8,37,1,37,3,37,641,8,37,1,37,1,
  	37,1,37,1,37,4,37,647,8,37,11,37,12,37,648,1,37,1,37,1,37,1,37,1,37,3,
  	37,656,8,37,1,37,3,37,659,8,37,1,37,3,37,662,8,37,1,37,3,37,665,8,37,
  	1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,3,37,676,8,37,1,37,3,37,
  	679,8,37,1,37,3,37,682,8,37,1,37,3,37,685,8,37,1,37,1,37,1,37,1,37,1,
  	37,1,37,1,37,3,37,694,8,37,1,37,3,37,697,8,37,1,37,1,37,1,37,1,37,1,37,
  	1,37,1,37,3,37,706,8,37,1,37,3,37,709,8,37,1,37,1,37,3,37,713,8,37,1,
  	38,1,38,1,38,1,38,1,38,5,38,720,8,38,10,38,12,38,723,9,38,1,38,1,38,3,
  	38,727,8,38,1,39,1,39,3,39,731,8,39,1,39,3,39,734,8,39,1,39,1,39,1,39,
  	3,39,739,8,39,1,40,1,40,3,40,743,8,40,1,40,1,40,1,40,1,40,5,40,749,8,
  	40,10,40,12,40,752,9,40,1,40,1,40,3,40,756,8,40,1,41,1,41,1,42,1,42,1,
  	43,1,43,1,44,1,44,1,44,1,44,5,44,768,8,44,10,44,12,44,771,9,44,1,44,1,
  	44,1,45,1,45,1,45,1,45,1,45,1,45,1,46,1,46,5,46,783,8,46,10,46,12,46,
  	786,9,46,1,46,1,46,1,47,1,47,1,47,5,47,793,8,47,10,47,12,47,796,9,47,
  	1,47,1,47,1,48,1,48,1,48,5,48,803,8,48,10,48,12,48,806,9,48,1,48,1,48,
  	1,49,5,49,811,8,49,10,49,12,49,814,9,49,1,49,1,49,1,50,1,50,1,50,1,50,
  	1,50,1,50,4,50,824,8,50,11,50,12,50,825,1,50,1,50,1,51,5,51,831,8,51,
  	10,51,12,51,834,9,51,1,51,1,51,1,52,1,52,1,52,3,52,841,8,52,1,52,5,52,
  	844,8,52,10,52,12,52,847,9,52,1,52,1,52,1,53,1,53,1,54,1,54,1,55,1,55,
  	1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,3,55,
  	870,8,55,1,56,1,56,5,56,874,8,56,10,56,12,56,877,9,56,1,56,1,56,1,57,
  	1,57,5,57,883,8,57,10,57,12,57,886,9,57,1,57,3,57,889,8,57,1,57,1,57,
  	1,57,3,57,894,8,57,1,57,1,57,1,58,1,58,5,58,900,8,58,10,58,12,58,903,
  	9,58,1,58,3,58,906,8,58,1,58,1,58,1,58,3,58,911,8,58,1,58,1,58,1,59,1,
  	59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,3,59,925,8,59,1,60,1,60,1,
  	60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,3,60,937,8,60,1,61,1,61,3,61,941,
  	8,61,1,62,1,62,3,62,945,8,62,1,62,3,62,948,8,62,4,62,950,8,62,11,62,12,
  	62,951,1,63,1,63,3,63,956,8,63,1,63,3,63,959,8,63,1,63,3,63,962,8,63,
  	1,63,1,63,3,63,966,8,63,1,63,3,63,969,8,63,1,63,3,63,972,8,63,3,63,974,
  	8,63,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,3,64,986,8,64,
  	1,65,1,65,3,65,990,8,65,1,65,3,65,993,8,65,1,65,3,65,996,8,65,1,65,1,
  	65,3,65,1000,8,65,1,65,3,65,1003,8,65,1,65,3,65,1006,8,65,3,65,1008,8,
  	65,1,66,1,66,1,66,1,66,1,66,3,66,1015,8,66,1,66,1,66,3,66,1019,8,66,1,
  	67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,
  	67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,3,67,1043,8,67,1,68,1,68,1,68,1,
  	68,1,68,1,68,1,68,1,68,1,68,1,68,3,68,1055,8,68,1,69,1,69,1,70,1,70,1,
  	70,1,70,1,71,5,71,1064,8,71,10,71,12,71,1067,9,71,1,71,1,71,1,72,1,72,
  	1,72,1,72,1,72,1,72,4,72,1077,8,72,11,72,12,72,1078,1,72,1,72,1,73,5,
  	73,1084,8,73,10,73,12,73,1087,9,73,1,73,1,73,1,74,1,74,3,74,1093,8,74,
  	1,74,1,74,1,74,6,414,721,750,769,794,804,3,12,14,26,75,0,2,4,6,8,10,12,
  	14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,
  	60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
  	106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,
  	142,144,146,148,0,19,1,0,215,216,2,0,214,214,217,218,1,0,2,3,1,0,172,
  	177,1,0,179,184,1,0,186,187,2,0,178,178,185,185,2,0,191,199,201,201,1,
  	0,210,210,1,0,163,168,1,0,197,199,1,0,221,222,2,0,118,119,132,132,2,0,
  	58,58,123,124,1,0,125,126,1,0,128,129,4,0,125,126,128,129,197,197,200,
  	200,1,0,133,142,2,0,6,9,213,213,1234,0,153,1,0,0,0,2,176,1,0,0,0,4,178,
  	1,0,0,0,6,182,1,0,0,0,8,190,1,0,0,0,10,193,1,0,0,0,12,210,1,0,0,0,14,
  	266,1,0,0,0,16,323,1,0,0,0,18,329,1,0,0,0,20,351,1,0,0,0,22,353,1,0,0,
  	0,24,357,1,0,0,0,26,364,1,0,0,0,28,377,1,0,0,0,30,382,1,0,0,0,32,399,
  	1,0,0,0,34,404,1,0,0,0,36,409,1,0,0,0,38,419,1,0,0,0,40,424,1,0,0,0,42,
  	429,1,0,0,0,44,448,1,0,0,0,46,471,1,0,0,0,48,484,1,0,0,0,50,486,1,0,0,
  	0,52,511,1,0,0,0,54,513,1,0,0,0,56,546,1,0,0,0,58,548,1,0,0,0,60,553,
  	1,0,0,0,62,558,1,0,0,0,64,566,1,0,0,0,66,571,1,0,0,0,68,597,1,0,0,0,70,
  	602,1,0,0,0,72,614,1,0,0,0,74,712,1,0,0,0,76,714,1,0,0,0,78,728,1,0,0,
  	0,80,740,1,0,0,0,82,757,1,0,0,0,84,759,1,0,0,0,86,761,1,0,0,0,88,763,
  	1,0,0,0,90,774,1,0,0,0,92,784,1,0,0,0,94,789,1,0,0,0,96,799,1,0,0,0,98,
  	812,1,0,0,0,100,817,1,0,0,0,102,832,1,0,0,0,104,837,1,0,0,0,106,850,1,
  	0,0,0,108,852,1,0,0,0,110,869,1,0,0,0,112,875,1,0,0,0,114,880,1,0,0,0,
  	116,897,1,0,0,0,118,924,1,0,0,0,120,936,1,0,0,0,122,940,1,0,0,0,124,949,
  	1,0,0,0,126,973,1,0,0,0,128,985,1,0,0,0,130,1007,1,0,0,0,132,1018,1,0,
  	0,0,134,1042,1,0,0,0,136,1054,1,0,0,0,138,1056,1,0,0,0,140,1058,1,0,0,
  	0,142,1065,1,0,0,0,144,1070,1,0,0,0,146,1085,1,0,0,0,148,1090,1,0,0,0,
  	150,152,3,2,1,0,151,150,1,0,0,0,152,155,1,0,0,0,153,151,1,0,0,0,153,154,
  	1,0,0,0,154,156,1,0,0,0,155,153,1,0,0,0,156,157,5,0,0,1,157,1,1,0,0,0,
  	158,177,3,30,15,0,159,177,3,42,21,0,160,177,3,66,33,0,161,177,3,70,35,
  	0,162,177,3,94,47,0,163,177,3,96,48,0,164,177,3,8,4,0,165,177,3,100,50,
  	0,166,177,3,74,37,0,167,177,3,4,2,0,168,177,3,6,3,0,169,177,3,104,52,
  	0,170,177,3,114,57,0,171,177,3,116,58,0,172,177,3,144,72,0,173,177,3,
  	36,18,0,174,177,3,62,31,0,175,177,3,148,74,0,176,158,1,0,0,0,176,159,
  	1,0,0,0,176,160,1,0,0,0,176,161,1,0,0,0,176,162,1,0,0,0,176,163,1,0,0,
  	0,176,164,1,0,0,0,176,165,1,0,0,0,176,166,1,0,0,0,176,167,1,0,0,0,176,
  	168,1,0,0,0,176,169,1,0,0,0,176,170,1,0,0,0,176,171,1,0,0,0,176,172,1,
  	0,0,0,176,173,1,0,0,0,176,174,1,0,0,0,176,175,1,0,0,0,177,3,1,0,0,0,178,
  	179,5,41,0,0,179,180,3,12,6,0,180,181,5,210,0,0,181,5,1,0,0,0,182,183,
  	5,41,0,0,183,184,3,12,6,0,184,185,5,39,0,0,185,188,3,2,1,0,186,187,5,
  	100,0,0,187,189,3,2,1,0,188,186,1,0,0,0,188,189,1,0,0,0,189,7,1,0,0,0,
  	190,191,5,75,0,0,191,192,5,210,0,0,192,9,1,0,0,0,193,194,5,92,0,0,194,
  	195,3,12,6,0,195,196,5,44,0,0,196,197,3,2,1,0,197,198,5,210,0,0,198,11,
  	1,0,0,0,199,200,6,6,-1,0,200,211,3,24,12,0,201,211,5,200,0,0,202,203,
  	5,221,0,0,203,204,3,12,6,0,204,205,5,222,0,0,205,211,1,0,0,0,206,207,
  	7,0,0,0,207,211,3,12,6,12,208,209,5,188,0,0,209,211,3,12,6,11,210,199,
  	1,0,0,0,210,201,1,0,0,0,210,202,1,0,0,0,210,206,1,0,0,0,210,208,1,0,0,
  	0,211,263,1,0,0,0,212,213,10,13,0,0,213,214,5,1,0,0,214,262,3,12,6,13,
  	215,216,10,10,0,0,216,217,5,189,0,0,217,262,3,12,6,11,218,219,10,9,0,
  	0,219,220,5,190,0,0,220,262,3,12,6,10,221,222,10,8,0,0,222,223,7,1,0,
  	0,223,262,3,12,6,9,224,225,10,7,0,0,225,226,7,0,0,0,226,262,3,12,6,8,
  	227,228,10,6,0,0,228,229,7,2,0,0,229,262,3,12,6,7,230,231,10,5,0,0,231,
  	232,7,3,0,0,232,262,3,12,6,6,233,234,10,4,0,0,234,235,7,4,0,0,235,262,
  	3,12,6,5,236,237,10,2,0,0,237,238,7,5,0,0,238,262,3,12,6,3,239,240,10,
  	1,0,0,240,241,5,203,0,0,241,262,3,12,6,1,242,243,10,16,0,0,243,245,5,
  	221,0,0,244,246,3,14,7,0,245,244,1,0,0,0,245,246,1,0,0,0,246,247,1,0,
  	0,0,247,262,5,222,0,0,248,249,10,15,0,0,249,250,5,223,0,0,250,251,3,12,
  	6,0,251,252,5,224,0,0,252,262,1,0,0,0,253,254,10,14,0,0,254,255,5,225,
  	0,0,255,256,3,12,6,0,256,257,5,226,0,0,257,262,1,0,0,0,258,259,10,3,0,
  	0,259,260,7,6,0,0,260,262,3,20,10,0,261,212,1,0,0,0,261,215,1,0,0,0,261,
  	218,1,0,0,0,261,221,1,0,0,0,261,224,1,0,0,0,261,227,1,0,0,0,261,230,1,
  	0,0,0,261,233,1,0,0,0,261,236,1,0,0,0,261,239,1,0,0,0,261,242,1,0,0,0,
  	261,248,1,0,0,0,261,253,1,0,0,0,261,258,1,0,0,0,262,265,1,0,0,0,263,261,
  	1,0,0,0,263,264,1,0,0,0,264,13,1,0,0,0,265,263,1,0,0,0,266,269,6,7,-1,
  	0,267,270,3,12,6,0,268,270,3,16,8,0,269,267,1,0,0,0,269,268,1,0,0,0,270,
  	278,1,0,0,0,271,274,5,204,0,0,272,275,3,12,6,0,273,275,3,16,8,0,274,272,
  	1,0,0,0,274,273,1,0,0,0,275,277,1,0,0,0,276,271,1,0,0,0,277,280,1,0,0,
  	0,278,276,1,0,0,0,278,279,1,0,0,0,279,290,1,0,0,0,280,278,1,0,0,0,281,
  	283,10,1,0,0,282,284,5,204,0,0,283,282,1,0,0,0,284,285,1,0,0,0,285,283,
  	1,0,0,0,285,286,1,0,0,0,286,287,1,0,0,0,287,289,3,14,7,2,288,281,1,0,
  	0,0,289,292,1,0,0,0,290,288,1,0,0,0,290,291,1,0,0,0,291,15,1,0,0,0,292,
  	290,1,0,0,0,293,294,5,4,0,0,294,295,5,200,0,0,295,296,5,216,0,0,296,297,
  	5,200,0,0,297,307,1,0,0,0,298,299,5,204,0,0,299,301,5,4,0,0,300,298,1,
  	0,0,0,300,301,1,0,0,0,301,302,1,0,0,0,302,303,5,200,0,0,303,304,5,216,
  	0,0,304,306,5,200,0,0,305,300,1,0,0,0,306,309,1,0,0,0,307,305,1,0,0,0,
  	307,308,1,0,0,0,308,324,1,0,0,0,309,307,1,0,0,0,310,311,5,4,0,0,311,315,
  	5,200,0,0,312,314,5,200,0,0,313,312,1,0,0,0,314,317,1,0,0,0,315,313,1,
  	0,0,0,315,316,1,0,0,0,316,324,1,0,0,0,317,315,1,0,0,0,318,319,5,4,0,0,
  	319,320,5,200,0,0,320,321,5,225,0,0,321,322,5,217,0,0,322,324,5,226,0,
  	0,323,293,1,0,0,0,323,310,1,0,0,0,323,318,1,0,0,0,324,17,1,0,0,0,325,
  	330,5,200,0,0,326,327,5,200,0,0,327,328,5,216,0,0,328,330,5,200,0,0,329,
  	325,1,0,0,0,329,326,1,0,0,0,330,331,1,0,0,0,331,329,1,0,0,0,331,332,1,
  	0,0,0,332,19,1,0,0,0,333,352,5,200,0,0,334,337,5,221,0,0,335,338,3,24,
  	12,0,336,338,3,22,11,0,337,335,1,0,0,0,337,336,1,0,0,0,338,346,1,0,0,
  	0,339,342,5,204,0,0,340,343,3,24,12,0,341,343,3,22,11,0,342,340,1,0,0,
  	0,342,341,1,0,0,0,343,345,1,0,0,0,344,339,1,0,0,0,345,348,1,0,0,0,346,
  	344,1,0,0,0,346,347,1,0,0,0,347,349,1,0,0,0,348,346,1,0,0,0,349,350,5,
  	222,0,0,350,352,1,0,0,0,351,333,1,0,0,0,351,334,1,0,0,0,352,21,1,0,0,
  	0,353,354,5,198,0,0,354,355,5,213,0,0,355,356,5,198,0,0,356,23,1,0,0,
  	0,357,358,7,7,0,0,358,25,1,0,0,0,359,360,6,13,-1,0,360,365,5,200,0,0,
  	361,365,5,156,0,0,362,365,5,132,0,0,363,365,5,161,0,0,364,359,1,0,0,0,
  	364,361,1,0,0,0,364,362,1,0,0,0,364,363,1,0,0,0,365,371,1,0,0,0,366,367,
  	10,5,0,0,367,368,5,201,0,0,368,370,3,26,13,6,369,366,1,0,0,0,370,373,
  	1,0,0,0,371,369,1,0,0,0,371,372,1,0,0,0,372,27,1,0,0,0,373,371,1,0,0,
  	0,374,376,3,30,15,0,375,374,1,0,0,0,376,379,1,0,0,0,377,375,1,0,0,0,377,
  	378,1,0,0,0,378,380,1,0,0,0,379,377,1,0,0,0,380,381,5,0,0,1,381,29,1,
  	0,0,0,382,389,5,15,0,0,383,390,5,10,0,0,384,386,5,105,0,0,385,387,3,32,
  	16,0,386,385,1,0,0,0,386,387,1,0,0,0,387,390,1,0,0,0,388,390,5,48,0,0,
  	389,383,1,0,0,0,389,384,1,0,0,0,389,388,1,0,0,0,389,390,1,0,0,0,390,392,
  	1,0,0,0,391,393,5,198,0,0,392,391,1,0,0,0,392,393,1,0,0,0,393,395,1,0,
  	0,0,394,396,5,106,0,0,395,394,1,0,0,0,395,396,1,0,0,0,396,397,1,0,0,0,
  	397,398,5,210,0,0,398,31,1,0,0,0,399,400,5,197,0,0,400,33,1,0,0,0,401,
  	403,3,36,18,0,402,401,1,0,0,0,403,406,1,0,0,0,404,402,1,0,0,0,404,405,
  	1,0,0,0,405,407,1,0,0,0,406,404,1,0,0,0,407,408,5,0,0,1,408,35,1,0,0,
  	0,409,410,5,162,0,0,410,414,3,38,19,0,411,413,8,8,0,0,412,411,1,0,0,0,
  	413,416,1,0,0,0,414,415,1,0,0,0,414,412,1,0,0,0,415,417,1,0,0,0,416,414,
  	1,0,0,0,417,418,5,210,0,0,418,37,1,0,0,0,419,420,7,9,0,0,420,39,1,0,0,
  	0,421,423,3,42,21,0,422,421,1,0,0,0,423,426,1,0,0,0,424,422,1,0,0,0,424,
  	425,1,0,0,0,425,427,1,0,0,0,426,424,1,0,0,0,427,428,5,0,0,1,428,41,1,
  	0,0,0,429,430,5,107,0,0,430,431,3,44,22,0,431,432,5,205,0,0,432,433,3,
  	46,23,0,433,435,5,206,0,0,434,436,5,171,0,0,435,434,1,0,0,0,435,436,1,
  	0,0,0,436,438,1,0,0,0,437,439,5,198,0,0,438,437,1,0,0,0,438,439,1,0,0,
  	0,439,441,1,0,0,0,440,442,3,48,24,0,441,440,1,0,0,0,441,442,1,0,0,0,442,
  	444,1,0,0,0,443,445,3,50,25,0,444,443,1,0,0,0,444,445,1,0,0,0,445,446,
  	1,0,0,0,446,447,5,210,0,0,447,43,1,0,0,0,448,449,5,200,0,0,449,45,1,0,
  	0,0,450,472,5,217,0,0,451,456,5,198,0,0,452,453,5,204,0,0,453,455,5,198,
  	0,0,454,452,1,0,0,0,455,458,1,0,0,0,456,454,1,0,0,0,456,457,1,0,0,0,457,
  	472,1,0,0,0,458,456,1,0,0,0,459,460,5,198,0,0,460,461,5,213,0,0,461,468,
  	5,198,0,0,462,463,5,204,0,0,463,464,5,198,0,0,464,465,5,213,0,0,465,467,
  	5,198,0,0,466,462,1,0,0,0,467,470,1,0,0,0,468,466,1,0,0,0,468,469,1,0,
  	0,0,469,472,1,0,0,0,470,468,1,0,0,0,471,450,1,0,0,0,471,451,1,0,0,0,471,
  	459,1,0,0,0,472,47,1,0,0,0,473,485,5,108,0,0,474,485,5,109,0,0,475,485,
  	5,110,0,0,476,478,5,200,0,0,477,476,1,0,0,0,478,479,1,0,0,0,479,477,1,
  	0,0,0,479,480,1,0,0,0,480,485,1,0,0,0,481,482,5,200,0,0,482,483,5,216,
  	0,0,483,485,5,200,0,0,484,473,1,0,0,0,484,474,1,0,0,0,484,475,1,0,0,0,
  	484,477,1,0,0,0,484,481,1,0,0,0,485,49,1,0,0,0,486,487,5,221,0,0,487,
  	494,3,52,26,0,488,490,5,204,0,0,489,488,1,0,0,0,489,490,1,0,0,0,490,491,
  	1,0,0,0,491,493,3,52,26,0,492,489,1,0,0,0,493,496,1,0,0,0,494,492,1,0,
  	0,0,494,495,1,0,0,0,495,497,1,0,0,0,496,494,1,0,0,0,497,498,5,222,0,0,
  	498,51,1,0,0,0,499,500,5,198,0,0,500,501,5,213,0,0,501,512,5,198,0,0,
  	502,503,3,56,28,0,503,504,5,217,0,0,504,505,3,50,25,0,505,512,1,0,0,0,
  	506,507,3,56,28,0,507,508,5,217,0,0,508,509,3,58,29,0,509,512,1,0,0,0,
  	510,512,3,58,29,0,511,499,1,0,0,0,511,502,1,0,0,0,511,506,1,0,0,0,511,
  	510,1,0,0,0,512,53,1,0,0,0,513,523,5,221,0,0,514,515,3,56,28,0,515,516,
  	5,217,0,0,516,517,3,50,25,0,517,524,1,0,0,0,518,519,3,56,28,0,519,520,
  	5,217,0,0,520,521,3,58,29,0,521,524,1,0,0,0,522,524,3,58,29,0,523,514,
  	1,0,0,0,523,518,1,0,0,0,523,522,1,0,0,0,524,541,1,0,0,0,525,527,5,204,
  	0,0,526,525,1,0,0,0,526,527,1,0,0,0,527,537,1,0,0,0,528,529,3,56,28,0,
  	529,530,5,217,0,0,530,531,3,50,25,0,531,538,1,0,0,0,532,533,3,56,28,0,
  	533,534,5,217,0,0,534,535,3,58,29,0,535,538,1,0,0,0,536,538,3,58,29,0,
  	537,528,1,0,0,0,537,532,1,0,0,0,537,536,1,0,0,0,538,540,1,0,0,0,539,526,
  	1,0,0,0,540,543,1,0,0,0,541,539,1,0,0,0,541,542,1,0,0,0,542,544,1,0,0,
  	0,543,541,1,0,0,0,544,545,5,222,0,0,545,55,1,0,0,0,546,547,5,198,0,0,
  	547,57,1,0,0,0,548,549,7,10,0,0,549,59,1,0,0,0,550,552,3,62,31,0,551,
  	550,1,0,0,0,552,555,1,0,0,0,553,551,1,0,0,0,553,554,1,0,0,0,554,556,1,
  	0,0,0,555,553,1,0,0,0,556,557,5,0,0,1,557,61,1,0,0,0,558,559,5,200,0,
  	0,559,560,5,203,0,0,560,561,3,12,6,0,561,562,5,210,0,0,562,63,1,0,0,0,
  	563,565,3,66,33,0,564,563,1,0,0,0,565,568,1,0,0,0,566,564,1,0,0,0,566,
  	567,1,0,0,0,567,569,1,0,0,0,568,566,1,0,0,0,569,570,5,0,0,1,570,65,1,
  	0,0,0,571,573,5,35,0,0,572,574,5,113,0,0,573,572,1,0,0,0,573,574,1,0,
  	0,0,574,575,1,0,0,0,575,576,5,200,0,0,576,583,1,0,0,0,577,579,5,113,0,
  	0,578,577,1,0,0,0,578,579,1,0,0,0,579,580,1,0,0,0,580,582,5,200,0,0,581,
  	578,1,0,0,0,582,585,1,0,0,0,583,581,1,0,0,0,583,584,1,0,0,0,584,587,1,
  	0,0,0,585,583,1,0,0,0,586,588,5,112,0,0,587,586,1,0,0,0,587,588,1,0,0,
  	0,588,590,1,0,0,0,589,591,5,111,0,0,590,589,1,0,0,0,590,591,1,0,0,0,591,
  	592,1,0,0,0,592,593,5,210,0,0,593,67,1,0,0,0,594,596,3,70,35,0,595,594,
  	1,0,0,0,596,599,1,0,0,0,597,595,1,0,0,0,597,598,1,0,0,0,598,600,1,0,0,
  	0,599,597,1,0,0,0,600,601,5,0,0,1,601,69,1,0,0,0,602,603,5,114,0,0,603,
  	604,3,12,6,0,604,606,5,221,0,0,605,607,3,14,7,0,606,605,1,0,0,0,606,607,
  	1,0,0,0,607,608,1,0,0,0,608,609,5,222,0,0,609,610,5,210,0,0,610,71,1,
  	0,0,0,611,613,3,74,37,0,612,611,1,0,0,0,613,616,1,0,0,0,614,612,1,0,0,
  	0,614,615,1,0,0,0,615,617,1,0,0,0,616,614,1,0,0,0,617,618,5,0,0,1,618,
  	73,1,0,0,0,619,620,5,169,0,0,620,713,5,210,0,0,621,622,5,169,0,0,622,
  	624,5,104,0,0,623,625,3,78,39,0,624,623,1,0,0,0,624,625,1,0,0,0,625,627,
  	1,0,0,0,626,628,5,106,0,0,627,626,1,0,0,0,627,628,1,0,0,0,628,629,1,0,
  	0,0,629,713,5,210,0,0,630,632,5,169,0,0,631,633,3,76,38,0,632,631,1,0,
  	0,0,633,634,1,0,0,0,634,632,1,0,0,0,634,635,1,0,0,0,635,637,1,0,0,0,636,
  	638,3,78,39,0,637,636,1,0,0,0,637,638,1,0,0,0,638,640,1,0,0,0,639,641,
  	5,106,0,0,640,639,1,0,0,0,640,641,1,0,0,0,641,642,1,0,0,0,642,643,5,210,
  	0,0,643,713,1,0,0,0,644,646,5,169,0,0,645,647,3,80,40,0,646,645,1,0,0,
  	0,647,648,1,0,0,0,648,646,1,0,0,0,648,649,1,0,0,0,649,650,1,0,0,0,650,
  	651,5,218,0,0,651,652,5,121,0,0,652,653,5,203,0,0,653,655,3,82,41,0,654,
  	656,3,88,44,0,655,654,1,0,0,0,655,656,1,0,0,0,656,658,1,0,0,0,657,659,
  	3,90,45,0,658,657,1,0,0,0,658,659,1,0,0,0,659,661,1,0,0,0,660,662,5,116,
  	0,0,661,660,1,0,0,0,661,662,1,0,0,0,662,664,1,0,0,0,663,665,5,106,0,0,
  	664,663,1,0,0,0,664,665,1,0,0,0,665,666,1,0,0,0,666,667,5,210,0,0,667,
  	713,1,0,0,0,668,669,5,169,0,0,669,670,3,84,42,0,670,671,5,218,0,0,671,
  	672,5,122,0,0,672,673,5,203,0,0,673,675,3,86,43,0,674,676,3,88,44,0,675,
  	674,1,0,0,0,675,676,1,0,0,0,676,678,1,0,0,0,677,679,3,90,45,0,678,677,
  	1,0,0,0,678,679,1,0,0,0,679,681,1,0,0,0,680,682,5,116,0,0,681,680,1,0,
  	0,0,681,682,1,0,0,0,682,684,1,0,0,0,683,685,5,106,0,0,684,683,1,0,0,0,
  	684,685,1,0,0,0,685,686,1,0,0,0,686,687,5,210,0,0,687,713,1,0,0,0,688,
  	689,5,169,0,0,689,690,5,121,0,0,690,691,5,203,0,0,691,693,3,82,41,0,692,
  	694,3,88,44,0,693,692,1,0,0,0,693,694,1,0,0,0,694,696,1,0,0,0,695,697,
  	5,106,0,0,696,695,1,0,0,0,696,697,1,0,0,0,697,698,1,0,0,0,698,699,5,210,
  	0,0,699,713,1,0,0,0,700,701,5,169,0,0,701,702,5,122,0,0,702,703,5,203,
  	0,0,703,705,3,86,43,0,704,706,3,88,44,0,705,704,1,0,0,0,705,706,1,0,0,
  	0,706,708,1,0,0,0,707,709,5,106,0,0,708,707,1,0,0,0,708,709,1,0,0,0,709,
  	710,1,0,0,0,710,711,5,210,0,0,711,713,1,0,0,0,712,619,1,0,0,0,712,621,
  	1,0,0,0,712,630,1,0,0,0,712,644,1,0,0,0,712,668,1,0,0,0,712,688,1,0,0,
  	0,712,700,1,0,0,0,713,75,1,0,0,0,714,726,3,84,42,0,715,716,5,221,0,0,
  	716,717,3,26,13,0,717,721,5,203,0,0,718,720,8,11,0,0,719,718,1,0,0,0,
  	720,723,1,0,0,0,721,722,1,0,0,0,721,719,1,0,0,0,722,724,1,0,0,0,723,721,
  	1,0,0,0,724,725,5,222,0,0,725,727,1,0,0,0,726,715,1,0,0,0,726,727,1,0,
  	0,0,727,77,1,0,0,0,728,730,5,218,0,0,729,731,5,115,0,0,730,729,1,0,0,
  	0,730,731,1,0,0,0,731,733,1,0,0,0,732,734,5,116,0,0,733,732,1,0,0,0,733,
  	734,1,0,0,0,734,738,1,0,0,0,735,736,5,117,0,0,736,737,5,203,0,0,737,739,
  	5,198,0,0,738,735,1,0,0,0,738,739,1,0,0,0,739,79,1,0,0,0,740,742,3,26,
  	13,0,741,743,3,26,13,0,742,741,1,0,0,0,742,743,1,0,0,0,743,755,1,0,0,
  	0,744,745,5,221,0,0,745,746,3,26,13,0,746,750,5,203,0,0,747,749,8,11,
  	0,0,748,747,1,0,0,0,749,752,1,0,0,0,750,751,1,0,0,0,750,748,1,0,0,0,751,
  	753,1,0,0,0,752,750,1,0,0,0,753,754,5,222,0,0,754,756,1,0,0,0,755,744,
  	1,0,0,0,755,756,1,0,0,0,756,81,1,0,0,0,757,758,3,26,13,0,758,83,1,0,0,
  	0,759,760,3,26,13,0,760,85,1,0,0,0,761,762,3,26,13,0,762,87,1,0,0,0,763,
  	764,5,221,0,0,764,765,7,12,0,0,765,769,5,203,0,0,766,768,8,11,0,0,767,
  	766,1,0,0,0,768,771,1,0,0,0,769,770,1,0,0,0,769,767,1,0,0,0,770,772,1,
  	0,0,0,771,769,1,0,0,0,772,773,5,222,0,0,773,89,1,0,0,0,774,775,5,221,
  	0,0,775,776,5,120,0,0,776,777,5,203,0,0,777,778,7,13,0,0,778,779,5,222,
  	0,0,779,91,1,0,0,0,780,783,3,94,47,0,781,783,3,96,48,0,782,780,1,0,0,
  	0,782,781,1,0,0,0,783,786,1,0,0,0,784,782,1,0,0,0,784,785,1,0,0,0,785,
  	787,1,0,0,0,786,784,1,0,0,0,787,788,5,0,0,1,788,93,1,0,0,0,789,790,7,
  	14,0,0,790,794,5,210,0,0,791,793,8,8,0,0,792,791,1,0,0,0,793,796,1,0,
  	0,0,794,795,1,0,0,0,794,792,1,0,0,0,795,797,1,0,0,0,796,794,1,0,0,0,797,
  	798,5,210,0,0,798,95,1,0,0,0,799,800,7,15,0,0,800,804,5,210,0,0,801,803,
  	9,0,0,0,802,801,1,0,0,0,803,806,1,0,0,0,804,805,1,0,0,0,804,802,1,0,0,
  	0,805,807,1,0,0,0,806,804,1,0,0,0,807,808,5,131,0,0,808,97,1,0,0,0,809,
  	811,3,100,50,0,810,809,1,0,0,0,811,814,1,0,0,0,812,810,1,0,0,0,812,813,
  	1,0,0,0,813,815,1,0,0,0,814,812,1,0,0,0,815,816,5,0,0,1,816,99,1,0,0,
  	0,817,823,5,161,0,0,818,824,3,26,13,0,819,820,3,26,13,0,820,821,5,216,
  	0,0,821,822,3,26,13,0,822,824,1,0,0,0,823,818,1,0,0,0,823,819,1,0,0,0,
  	824,825,1,0,0,0,825,823,1,0,0,0,825,826,1,0,0,0,826,827,1,0,0,0,827,828,
  	5,210,0,0,828,101,1,0,0,0,829,831,3,104,52,0,830,829,1,0,0,0,831,834,
  	1,0,0,0,832,830,1,0,0,0,832,833,1,0,0,0,833,835,1,0,0,0,834,832,1,0,0,
  	0,835,836,5,0,0,1,836,103,1,0,0,0,837,838,5,61,0,0,838,840,3,106,53,0,
  	839,841,3,108,54,0,840,839,1,0,0,0,840,841,1,0,0,0,841,845,1,0,0,0,842,
  	844,3,110,55,0,843,842,1,0,0,0,844,847,1,0,0,0,845,843,1,0,0,0,845,846,
  	1,0,0,0,846,848,1,0,0,0,847,845,1,0,0,0,848,849,5,210,0,0,849,105,1,0,
  	0,0,850,851,7,16,0,0,851,107,1,0,0,0,852,853,7,17,0,0,853,109,1,0,0,0,
  	854,855,5,200,0,0,855,856,5,203,0,0,856,870,3,12,6,0,857,870,5,143,0,
  	0,858,870,5,144,0,0,859,870,5,145,0,0,860,870,5,146,0,0,861,870,5,147,
  	0,0,862,870,5,148,0,0,863,870,5,149,0,0,864,870,5,150,0,0,865,870,5,151,
  	0,0,866,870,5,152,0,0,867,870,5,153,0,0,868,870,5,154,0,0,869,854,1,0,
  	0,0,869,857,1,0,0,0,869,858,1,0,0,0,869,859,1,0,0,0,869,860,1,0,0,0,869,
  	861,1,0,0,0,869,862,1,0,0,0,869,863,1,0,0,0,869,864,1,0,0,0,869,865,1,
  	0,0,0,869,866,1,0,0,0,869,867,1,0,0,0,869,868,1,0,0,0,870,111,1,0,0,0,
  	871,874,3,114,57,0,872,874,3,116,58,0,873,871,1,0,0,0,873,872,1,0,0,0,
  	874,877,1,0,0,0,875,873,1,0,0,0,875,876,1,0,0,0,876,878,1,0,0,0,877,875,
  	1,0,0,0,878,879,5,0,0,1,879,113,1,0,0,0,880,884,5,66,0,0,881,883,3,118,
  	59,0,882,881,1,0,0,0,883,886,1,0,0,0,884,882,1,0,0,0,884,885,1,0,0,0,
  	885,888,1,0,0,0,886,884,1,0,0,0,887,889,5,155,0,0,888,887,1,0,0,0,888,
  	889,1,0,0,0,889,893,1,0,0,0,890,894,5,202,0,0,891,892,5,202,0,0,892,894,
  	5,202,0,0,893,890,1,0,0,0,893,891,1,0,0,0,893,894,1,0,0,0,894,895,1,0,
  	0,0,895,896,5,210,0,0,896,115,1,0,0,0,897,901,5,67,0,0,898,900,3,120,
  	60,0,899,898,1,0,0,0,900,903,1,0,0,0,901,899,1,0,0,0,901,902,1,0,0,0,
  	902,905,1,0,0,0,903,901,1,0,0,0,904,906,5,155,0,0,905,904,1,0,0,0,905,
  	906,1,0,0,0,906,910,1,0,0,0,907,911,5,202,0,0,908,909,5,202,0,0,909,911,
  	5,202,0,0,910,907,1,0,0,0,910,908,1,0,0,0,910,911,1,0,0,0,911,912,1,0,
  	0,0,912,913,5,210,0,0,913,117,1,0,0,0,914,925,3,122,61,0,915,925,3,126,
  	63,0,916,925,3,140,70,0,917,918,5,221,0,0,918,919,3,18,9,0,919,920,5,
  	222,0,0,920,921,5,221,0,0,921,922,3,124,62,0,922,923,5,222,0,0,923,925,
  	1,0,0,0,924,914,1,0,0,0,924,915,1,0,0,0,924,916,1,0,0,0,924,917,1,0,0,
  	0,925,119,1,0,0,0,926,937,3,122,61,0,927,937,3,130,65,0,928,937,3,140,
  	70,0,929,930,5,221,0,0,930,931,3,18,9,0,931,932,5,222,0,0,932,933,5,221,
  	0,0,933,934,3,124,62,0,934,935,5,222,0,0,935,937,1,0,0,0,936,926,1,0,
  	0,0,936,927,1,0,0,0,936,928,1,0,0,0,936,929,1,0,0,0,937,121,1,0,0,0,938,
  	941,3,136,68,0,939,941,3,134,67,0,940,938,1,0,0,0,940,939,1,0,0,0,941,
  	123,1,0,0,0,942,944,5,170,0,0,943,945,5,204,0,0,944,943,1,0,0,0,944,945,
  	1,0,0,0,945,947,1,0,0,0,946,948,3,122,61,0,947,946,1,0,0,0,947,948,1,
  	0,0,0,948,950,1,0,0,0,949,942,1,0,0,0,950,951,1,0,0,0,951,949,1,0,0,0,
  	951,952,1,0,0,0,952,125,1,0,0,0,953,955,3,128,64,0,954,956,5,203,0,0,
  	955,954,1,0,0,0,955,956,1,0,0,0,956,958,1,0,0,0,957,959,3,138,69,0,958,
  	957,1,0,0,0,958,959,1,0,0,0,959,961,1,0,0,0,960,962,5,170,0,0,961,960,
  	1,0,0,0,961,962,1,0,0,0,962,974,1,0,0,0,963,965,3,128,64,0,964,966,5,
  	203,0,0,965,964,1,0,0,0,965,966,1,0,0,0,966,968,1,0,0,0,967,969,3,138,
  	69,0,968,967,1,0,0,0,968,969,1,0,0,0,969,971,1,0,0,0,970,972,5,171,0,
  	0,971,970,1,0,0,0,971,972,1,0,0,0,972,974,1,0,0,0,973,953,1,0,0,0,973,
  	963,1,0,0,0,974,127,1,0,0,0,975,986,3,26,13,0,976,977,3,26,13,0,977,978,
  	5,216,0,0,978,979,3,26,13,0,979,986,1,0,0,0,980,981,3,26,13,0,981,982,
  	5,223,0,0,982,983,5,217,0,0,983,984,5,224,0,0,984,986,1,0,0,0,985,975,
  	1,0,0,0,985,976,1,0,0,0,985,980,1,0,0,0,986,129,1,0,0,0,987,989,3,132,
  	66,0,988,990,5,203,0,0,989,988,1,0,0,0,989,990,1,0,0,0,990,992,1,0,0,
  	0,991,993,3,138,69,0,992,991,1,0,0,0,992,993,1,0,0,0,993,995,1,0,0,0,
  	994,996,5,170,0,0,995,994,1,0,0,0,995,996,1,0,0,0,996,1008,1,0,0,0,997,
  	999,3,132,66,0,998,1000,5,203,0,0,999,998,1,0,0,0,999,1000,1,0,0,0,1000,
  	1002,1,0,0,0,1001,1003,3,138,69,0,1002,1001,1,0,0,0,1002,1003,1,0,0,0,
  	1003,1005,1,0,0,0,1004,1006,5,171,0,0,1005,1004,1,0,0,0,1005,1006,1,0,
  	0,0,1006,1008,1,0,0,0,1007,987,1,0,0,0,1007,997,1,0,0,0,1008,131,1,0,
  	0,0,1009,1019,5,154,0,0,1010,1019,5,110,0,0,1011,1019,3,128,64,0,1012,
  	1013,5,198,0,0,1013,1015,5,217,0,0,1014,1012,1,0,0,0,1014,1015,1,0,0,
  	0,1015,1016,1,0,0,0,1016,1019,5,197,0,0,1017,1019,3,24,12,0,1018,1009,
  	1,0,0,0,1018,1010,1,0,0,0,1018,1011,1,0,0,0,1018,1014,1,0,0,0,1018,1017,
  	1,0,0,0,1019,133,1,0,0,0,1020,1021,5,202,0,0,1021,1043,5,198,0,0,1022,
  	1023,5,202,0,0,1023,1043,5,199,0,0,1024,1025,5,202,0,0,1025,1043,5,200,
  	0,0,1026,1027,5,202,0,0,1027,1028,5,221,0,0,1028,1029,3,12,6,0,1029,1030,
  	5,222,0,0,1030,1043,1,0,0,0,1031,1032,5,215,0,0,1032,1043,5,198,0,0,1033,
  	1034,5,215,0,0,1034,1043,5,200,0,0,1035,1036,5,215,0,0,1036,1043,5,199,
  	0,0,1037,1038,5,215,0,0,1038,1039,5,221,0,0,1039,1040,3,12,6,0,1040,1041,
  	5,222,0,0,1041,1043,1,0,0,0,1042,1020,1,0,0,0,1042,1022,1,0,0,0,1042,
  	1024,1,0,0,0,1042,1026,1,0,0,0,1042,1031,1,0,0,0,1042,1033,1,0,0,0,1042,
  	1035,1,0,0,0,1042,1037,1,0,0,0,1043,135,1,0,0,0,1044,1045,5,5,0,0,1045,
  	1055,5,198,0,0,1046,1047,5,5,0,0,1047,1055,5,199,0,0,1048,1049,5,5,0,
  	0,1049,1050,5,221,0,0,1050,1051,3,12,6,0,1051,1052,5,222,0,0,1052,1055,
  	1,0,0,0,1053,1055,5,218,0,0,1054,1044,1,0,0,0,1054,1046,1,0,0,0,1054,
  	1048,1,0,0,0,1054,1053,1,0,0,0,1055,137,1,0,0,0,1056,1057,7,18,0,0,1057,
  	139,1,0,0,0,1058,1059,5,198,0,0,1059,1060,5,216,0,0,1060,1061,5,198,0,
  	0,1061,141,1,0,0,0,1062,1064,3,144,72,0,1063,1062,1,0,0,0,1064,1067,1,
  	0,0,0,1065,1063,1,0,0,0,1065,1066,1,0,0,0,1066,1068,1,0,0,0,1067,1065,
  	1,0,0,0,1068,1069,5,0,0,1,1069,143,1,0,0,0,1070,1076,5,161,0,0,1071,1077,
  	3,26,13,0,1072,1073,3,26,13,0,1073,1074,5,216,0,0,1074,1075,3,26,13,0,
  	1075,1077,1,0,0,0,1076,1071,1,0,0,0,1076,1072,1,0,0,0,1077,1078,1,0,0,
  	0,1078,1076,1,0,0,0,1078,1079,1,0,0,0,1079,1080,1,0,0,0,1080,1081,5,210,
  	0,0,1081,145,1,0,0,0,1082,1084,3,148,74,0,1083,1082,1,0,0,0,1084,1087,
  	1,0,0,0,1085,1083,1,0,0,0,1085,1086,1,0,0,0,1086,1088,1,0,0,0,1087,1085,
  	1,0,0,0,1088,1089,5,0,0,1,1089,147,1,0,0,0,1090,1092,5,53,0,0,1091,1093,
  	5,105,0,0,1092,1091,1,0,0,0,1092,1093,1,0,0,0,1093,1094,1,0,0,0,1094,
  	1095,5,210,0,0,1095,149,1,0,0,0,135,153,176,188,210,245,261,263,269,274,
  	278,285,290,300,307,315,323,329,331,337,342,346,351,364,371,377,386,389,
  	392,395,404,414,424,435,438,441,444,456,468,471,479,484,489,494,511,523,
  	526,537,541,553,566,573,578,583,587,590,597,606,614,624,627,634,637,640,
  	648,655,658,661,664,675,678,681,684,693,696,705,708,712,721,726,730,733,
  	738,742,750,755,769,782,784,794,804,812,823,825,832,840,845,869,873,875,
  	884,888,893,901,905,910,924,936,940,944,947,951,955,958,961,965,968,971,
  	973,985,989,992,995,999,1002,1005,1007,1014,1018,1042,1054,1065,1076,
  	1078,1085,1092
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  dapParserStaticData = staticData.release();
}

}

DapParser::DapParser(TokenStream *input) : DapParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

DapParser::DapParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  DapParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *dapParserStaticData->atn, dapParserStaticData->decisionToDFA, dapParserStaticData->sharedContextCache, options);
}

DapParser::~DapParser() {
  delete _interpreter;
}

const atn::ATN& DapParser::getATN() const {
  return *dapParserStaticData->atn;
}

std::string DapParser::getGrammarFileName() const {
  return "Dap.g4";
}

const std::vector<std::string>& DapParser::getRuleNames() const {
  return dapParserStaticData->ruleNames;
}

const dfa::Vocabulary& DapParser::getVocabulary() const {
  return dapParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView DapParser::getSerializedATN() const {
  return dapParserStaticData->serializedATN;
}


//----------------- ParseContext ------------------------------------------------------------------

DapParser::ParseContext::ParseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::ParseContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Sas_stmt_listContext *> DapParser::ParseContext::sas_stmt_list() {
  return getRuleContexts<DapParser::Sas_stmt_listContext>();
}

DapParser::Sas_stmt_listContext* DapParser::ParseContext::sas_stmt_list(size_t i) {
  return getRuleContext<DapParser::Sas_stmt_listContext>(i);
}


size_t DapParser::ParseContext::getRuleIndex() const {
  return DapParser::RuleParse;
}

void DapParser::ParseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParse(this);
}

void DapParser::ParseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParse(this);
}


std::any DapParser::ParseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitParse(this);
  else
    return visitor->visitChildren(this);
}

DapParser::ParseContext* DapParser::parse() {
  ParseContext *_localctx = _tracker.createInstance<ParseContext>(_ctx, getState());
  enterRule(_localctx, 0, DapParser::RuleParse);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(153);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2314852441851461632) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -2882020087517150717) != 0) || ((((_la - 161) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 161)) & 549755814147) != 0)) {
      setState(150);
      sas_stmt_list();
      setState(155);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(156);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sas_stmt_listContext ------------------------------------------------------------------

DapParser::Sas_stmt_listContext::Sas_stmt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::Abort_stmtContext* DapParser::Sas_stmt_listContext::abort_stmt() {
  return getRuleContext<DapParser::Abort_stmtContext>(0);
}

DapParser::Array_stmtContext* DapParser::Sas_stmt_listContext::array_stmt() {
  return getRuleContext<DapParser::Array_stmtContext>(0);
}

DapParser::By_stmtContext* DapParser::Sas_stmt_listContext::by_stmt() {
  return getRuleContext<DapParser::By_stmtContext>(0);
}

DapParser::Call_stmtContext* DapParser::Sas_stmt_listContext::call_stmt() {
  return getRuleContext<DapParser::Call_stmtContext>(0);
}

DapParser::Datalines_stmtContext* DapParser::Sas_stmt_listContext::datalines_stmt() {
  return getRuleContext<DapParser::Datalines_stmtContext>(0);
}

DapParser::Datalines4_stmtContext* DapParser::Sas_stmt_listContext::datalines4_stmt() {
  return getRuleContext<DapParser::Datalines4_stmtContext>(0);
}

DapParser::Delete_stmtContext* DapParser::Sas_stmt_listContext::delete_stmt() {
  return getRuleContext<DapParser::Delete_stmtContext>(0);
}

DapParser::Drop_stmtContext* DapParser::Sas_stmt_listContext::drop_stmt() {
  return getRuleContext<DapParser::Drop_stmtContext>(0);
}

DapParser::Data_stmtContext* DapParser::Sas_stmt_listContext::data_stmt() {
  return getRuleContext<DapParser::Data_stmtContext>(0);
}

DapParser::If_stmtContext* DapParser::Sas_stmt_listContext::if_stmt() {
  return getRuleContext<DapParser::If_stmtContext>(0);
}

DapParser::If_then_else_stmtContext* DapParser::Sas_stmt_listContext::if_then_else_stmt() {
  return getRuleContext<DapParser::If_then_else_stmtContext>(0);
}

DapParser::Infile_stmtContext* DapParser::Sas_stmt_listContext::infile_stmt() {
  return getRuleContext<DapParser::Infile_stmtContext>(0);
}

DapParser::Input_stmtContext* DapParser::Sas_stmt_listContext::input_stmt() {
  return getRuleContext<DapParser::Input_stmtContext>(0);
}

DapParser::Put_stmtContext* DapParser::Sas_stmt_listContext::put_stmt() {
  return getRuleContext<DapParser::Put_stmtContext>(0);
}

DapParser::Means_procContext* DapParser::Sas_stmt_listContext::means_proc() {
  return getRuleContext<DapParser::Means_procContext>(0);
}

DapParser::Proc_stmtContext* DapParser::Sas_stmt_listContext::proc_stmt() {
  return getRuleContext<DapParser::Proc_stmtContext>(0);
}

DapParser::Assign_stmtContext* DapParser::Sas_stmt_listContext::assign_stmt() {
  return getRuleContext<DapParser::Assign_stmtContext>(0);
}

DapParser::Run_stmtContext* DapParser::Sas_stmt_listContext::run_stmt() {
  return getRuleContext<DapParser::Run_stmtContext>(0);
}


size_t DapParser::Sas_stmt_listContext::getRuleIndex() const {
  return DapParser::RuleSas_stmt_list;
}

void DapParser::Sas_stmt_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSas_stmt_list(this);
}

void DapParser::Sas_stmt_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSas_stmt_list(this);
}


std::any DapParser::Sas_stmt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitSas_stmt_list(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Sas_stmt_listContext* DapParser::sas_stmt_list() {
  Sas_stmt_listContext *_localctx = _tracker.createInstance<Sas_stmt_listContext>(_ctx, getState());
  enterRule(_localctx, 2, DapParser::RuleSas_stmt_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(176);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(158);
      abort_stmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(159);
      array_stmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(160);
      by_stmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(161);
      call_stmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(162);
      datalines_stmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(163);
      datalines4_stmt();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(164);
      delete_stmt();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(165);
      drop_stmt();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(166);
      data_stmt();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(167);
      if_stmt();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(168);
      if_then_else_stmt();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(169);
      infile_stmt();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(170);
      input_stmt();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(171);
      put_stmt();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(172);
      means_proc();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(173);
      proc_stmt();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(174);
      assign_stmt();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(175);
      run_stmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_stmtContext ------------------------------------------------------------------

DapParser::If_stmtContext::If_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::If_stmtContext::IF() {
  return getToken(DapParser::IF, 0);
}

DapParser::ExpressionContext* DapParser::If_stmtContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::If_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}


size_t DapParser::If_stmtContext::getRuleIndex() const {
  return DapParser::RuleIf_stmt;
}

void DapParser::If_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_stmt(this);
}

void DapParser::If_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_stmt(this);
}


std::any DapParser::If_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitIf_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::If_stmtContext* DapParser::if_stmt() {
  If_stmtContext *_localctx = _tracker.createInstance<If_stmtContext>(_ctx, getState());
  enterRule(_localctx, 4, DapParser::RuleIf_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(178);
    match(DapParser::IF);
    setState(179);
    expression(0);
    setState(180);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_then_else_stmtContext ------------------------------------------------------------------

DapParser::If_then_else_stmtContext::If_then_else_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::If_then_else_stmtContext::IF() {
  return getToken(DapParser::IF, 0);
}

DapParser::ExpressionContext* DapParser::If_then_else_stmtContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::If_then_else_stmtContext::THEN() {
  return getToken(DapParser::THEN, 0);
}

std::vector<DapParser::Sas_stmt_listContext *> DapParser::If_then_else_stmtContext::sas_stmt_list() {
  return getRuleContexts<DapParser::Sas_stmt_listContext>();
}

DapParser::Sas_stmt_listContext* DapParser::If_then_else_stmtContext::sas_stmt_list(size_t i) {
  return getRuleContext<DapParser::Sas_stmt_listContext>(i);
}

tree::TerminalNode* DapParser::If_then_else_stmtContext::ELSE() {
  return getToken(DapParser::ELSE, 0);
}


size_t DapParser::If_then_else_stmtContext::getRuleIndex() const {
  return DapParser::RuleIf_then_else_stmt;
}

void DapParser::If_then_else_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_then_else_stmt(this);
}

void DapParser::If_then_else_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_then_else_stmt(this);
}


std::any DapParser::If_then_else_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitIf_then_else_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::If_then_else_stmtContext* DapParser::if_then_else_stmt() {
  If_then_else_stmtContext *_localctx = _tracker.createInstance<If_then_else_stmtContext>(_ctx, getState());
  enterRule(_localctx, 6, DapParser::RuleIf_then_else_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(182);
    match(DapParser::IF);
    setState(183);
    expression(0);
    setState(184);
    match(DapParser::THEN);
    setState(185);
    sas_stmt_list();
    setState(188);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      setState(186);
      match(DapParser::ELSE);
      setState(187);
      sas_stmt_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_stmtContext ------------------------------------------------------------------

DapParser::Delete_stmtContext::Delete_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Delete_stmtContext::DELETE() {
  return getToken(DapParser::DELETE, 0);
}

tree::TerminalNode* DapParser::Delete_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}


size_t DapParser::Delete_stmtContext::getRuleIndex() const {
  return DapParser::RuleDelete_stmt;
}

void DapParser::Delete_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_stmt(this);
}

void DapParser::Delete_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_stmt(this);
}


std::any DapParser::Delete_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDelete_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Delete_stmtContext* DapParser::delete_stmt() {
  Delete_stmtContext *_localctx = _tracker.createInstance<Delete_stmtContext>(_ctx, getState());
  enterRule(_localctx, 8, DapParser::RuleDelete_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(190);
    match(DapParser::DELETE);
    setState(191);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Do_stmtContext ------------------------------------------------------------------

DapParser::Do_stmtContext::Do_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Do_stmtContext::DO() {
  return getToken(DapParser::DO, 0);
}

DapParser::ExpressionContext* DapParser::Do_stmtContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::Do_stmtContext::TO() {
  return getToken(DapParser::TO, 0);
}

DapParser::Sas_stmt_listContext* DapParser::Do_stmtContext::sas_stmt_list() {
  return getRuleContext<DapParser::Sas_stmt_listContext>(0);
}

tree::TerminalNode* DapParser::Do_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}


size_t DapParser::Do_stmtContext::getRuleIndex() const {
  return DapParser::RuleDo_stmt;
}

void DapParser::Do_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDo_stmt(this);
}

void DapParser::Do_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDo_stmt(this);
}


std::any DapParser::Do_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDo_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Do_stmtContext* DapParser::do_stmt() {
  Do_stmtContext *_localctx = _tracker.createInstance<Do_stmtContext>(_ctx, getState());
  enterRule(_localctx, 10, DapParser::RuleDo_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(193);
    match(DapParser::DO);
    setState(194);
    expression(0);
    setState(195);
    match(DapParser::TO);
    setState(196);
    sas_stmt_list();
    setState(197);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

DapParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::LiteralContext* DapParser::ExpressionContext::literal() {
  return getRuleContext<DapParser::LiteralContext>(0);
}

tree::TerminalNode* DapParser::ExpressionContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

std::vector<DapParser::ExpressionContext *> DapParser::ExpressionContext::expression() {
  return getRuleContexts<DapParser::ExpressionContext>();
}

DapParser::ExpressionContext* DapParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<DapParser::ExpressionContext>(i);
}

tree::TerminalNode* DapParser::ExpressionContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::ADD() {
  return getToken(DapParser::ADD, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::SUB() {
  return getToken(DapParser::SUB, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::NOT() {
  return getToken(DapParser::NOT, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::MIN() {
  return getToken(DapParser::MIN, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::MAX() {
  return getToken(DapParser::MAX, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::MUL() {
  return getToken(DapParser::MUL, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::DIV() {
  return getToken(DapParser::DIV, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::PERCENT() {
  return getToken(DapParser::PERCENT, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::EQ() {
  return getToken(DapParser::EQ, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::NE() {
  return getToken(DapParser::NE, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::GT() {
  return getToken(DapParser::GT, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::LT() {
  return getToken(DapParser::LT, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::GE() {
  return getToken(DapParser::GE, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::LE() {
  return getToken(DapParser::LE, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::EQC() {
  return getToken(DapParser::EQC, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::NEC() {
  return getToken(DapParser::NEC, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::GTC() {
  return getToken(DapParser::GTC, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::LTC() {
  return getToken(DapParser::LTC, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::GEC() {
  return getToken(DapParser::GEC, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::LEC() {
  return getToken(DapParser::LEC, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::AND() {
  return getToken(DapParser::AND, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::OR() {
  return getToken(DapParser::OR, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

DapParser::ExpressionListContext* DapParser::ExpressionContext::expressionList() {
  return getRuleContext<DapParser::ExpressionListContext>(0);
}

tree::TerminalNode* DapParser::ExpressionContext::LBraces() {
  return getToken(DapParser::LBraces, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::RBraces() {
  return getToken(DapParser::RBraces, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::LSqBracket() {
  return getToken(DapParser::LSqBracket, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::RSqBracket() {
  return getToken(DapParser::RSqBracket, 0);
}

DapParser::In_var_listContext* DapParser::ExpressionContext::in_var_list() {
  return getRuleContext<DapParser::In_var_listContext>(0);
}

tree::TerminalNode* DapParser::ExpressionContext::IN() {
  return getToken(DapParser::IN, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::INColon() {
  return getToken(DapParser::INColon, 0);
}


size_t DapParser::ExpressionContext::getRuleIndex() const {
  return DapParser::RuleExpression;
}

void DapParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void DapParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


std::any DapParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}


DapParser::ExpressionContext* DapParser::expression() {
   return expression(0);
}

DapParser::ExpressionContext* DapParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  DapParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  DapParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 12;
  enterRecursionRule(_localctx, 12, DapParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(210);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::DateLiteral:
      case DapParser::TimeLiteral:
      case DapParser::DateTimeLiteral:
      case DapParser::BitLiteral:
      case DapParser::NameLiteral:
      case DapParser::HexLiteral:
      case DapParser::STRINGLITERAL:
      case DapParser::INT:
      case DapParser::FloatingPointLiteral:
      case DapParser::DOT: {
        setState(200);
        literal();
        break;
      }

      case DapParser::Identifier: {
        setState(201);
        match(DapParser::Identifier);
        break;
      }

      case DapParser::LParentheses: {
        setState(202);
        match(DapParser::LParentheses);
        setState(203);
        expression(0);
        setState(204);
        match(DapParser::RParentheses);
        break;
      }

      case DapParser::ADD:
      case DapParser::SUB: {
        setState(206);
        _la = _input->LA(1);
        if (!(_la == DapParser::ADD

        || _la == DapParser::SUB)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(207);
        expression(12);
        break;
      }

      case DapParser::NOT: {
        setState(208);
        match(DapParser::NOT);
        setState(209);
        expression(11);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(263);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(261);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(212);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(213);
          match(DapParser::T__0);
          setState(214);
          expression(13);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(215);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(216);
          match(DapParser::MIN);
          setState(217);
          expression(11);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(218);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(219);
          match(DapParser::MAX);
          setState(220);
          expression(10);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(221);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(222);
          _la = _input->LA(1);
          if (!(((((_la - 214) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 214)) & 25) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(223);
          expression(9);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(224);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(225);
          _la = _input->LA(1);
          if (!(_la == DapParser::ADD

          || _la == DapParser::SUB)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(226);
          expression(8);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(227);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(228);
          _la = _input->LA(1);
          if (!(_la == DapParser::T__1

          || _la == DapParser::T__2)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(229);
          expression(7);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(230);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(231);
          _la = _input->LA(1);
          if (!(((((_la - 172) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 172)) & 63) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(232);
          expression(6);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(233);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(234);
          _la = _input->LA(1);
          if (!(((((_la - 179) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 179)) & 63) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(235);
          expression(5);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(236);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(237);
          _la = _input->LA(1);
          if (!(_la == DapParser::AND

          || _la == DapParser::OR)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(238);
          expression(3);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(239);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(240);
          match(DapParser::EQUAL);
          setState(241);
          expression(1);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(242);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(243);
          match(DapParser::LParentheses);
          setState(245);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == DapParser::T__3 || ((((_la - 188) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 188)) & 8992604153) != 0)) {
            setState(244);
            expressionList(0);
          }
          setState(247);
          match(DapParser::RParentheses);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(248);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(249);
          match(DapParser::LBraces);
          setState(250);
          expression(0);
          setState(251);
          match(DapParser::RBraces);
          break;
        }

        case 13: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(253);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(254);
          match(DapParser::LSqBracket);
          setState(255);
          expression(0);
          setState(256);
          match(DapParser::RSqBracket);
          break;
        }

        case 14: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(258);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(259);
          _la = _input->LA(1);
          if (!(_la == DapParser::IN

          || _la == DapParser::INColon)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(260);
          in_var_list();
          break;
        }

        default:
          break;
        } 
      }
      setState(265);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ExpressionListContext ------------------------------------------------------------------

DapParser::ExpressionListContext::ExpressionListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<DapParser::ExpressionContext *> DapParser::ExpressionListContext::expression() {
  return getRuleContexts<DapParser::ExpressionContext>();
}

DapParser::ExpressionContext* DapParser::ExpressionListContext::expression(size_t i) {
  return getRuleContext<DapParser::ExpressionContext>(i);
}

std::vector<DapParser::Of_var_listContext *> DapParser::ExpressionListContext::of_var_list() {
  return getRuleContexts<DapParser::Of_var_listContext>();
}

DapParser::Of_var_listContext* DapParser::ExpressionListContext::of_var_list(size_t i) {
  return getRuleContext<DapParser::Of_var_listContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::ExpressionListContext::COMMA() {
  return getTokens(DapParser::COMMA);
}

tree::TerminalNode* DapParser::ExpressionListContext::COMMA(size_t i) {
  return getToken(DapParser::COMMA, i);
}

std::vector<DapParser::ExpressionListContext *> DapParser::ExpressionListContext::expressionList() {
  return getRuleContexts<DapParser::ExpressionListContext>();
}

DapParser::ExpressionListContext* DapParser::ExpressionListContext::expressionList(size_t i) {
  return getRuleContext<DapParser::ExpressionListContext>(i);
}


size_t DapParser::ExpressionListContext::getRuleIndex() const {
  return DapParser::RuleExpressionList;
}

void DapParser::ExpressionListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionList(this);
}

void DapParser::ExpressionListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionList(this);
}


std::any DapParser::ExpressionListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitExpressionList(this);
  else
    return visitor->visitChildren(this);
}


DapParser::ExpressionListContext* DapParser::expressionList() {
   return expressionList(0);
}

DapParser::ExpressionListContext* DapParser::expressionList(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  DapParser::ExpressionListContext *_localctx = _tracker.createInstance<ExpressionListContext>(_ctx, parentState);
  DapParser::ExpressionListContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 14;
  enterRecursionRule(_localctx, 14, DapParser::RuleExpressionList, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(269);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::NOT:
      case DapParser::DateLiteral:
      case DapParser::TimeLiteral:
      case DapParser::DateTimeLiteral:
      case DapParser::BitLiteral:
      case DapParser::NameLiteral:
      case DapParser::HexLiteral:
      case DapParser::STRINGLITERAL:
      case DapParser::INT:
      case DapParser::FloatingPointLiteral:
      case DapParser::Identifier:
      case DapParser::DOT:
      case DapParser::ADD:
      case DapParser::SUB:
      case DapParser::LParentheses: {
        setState(267);
        expression(0);
        break;
      }

      case DapParser::T__3: {
        setState(268);
        of_var_list();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(278);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(271);
        match(DapParser::COMMA);
        setState(274);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case DapParser::NOT:
          case DapParser::DateLiteral:
          case DapParser::TimeLiteral:
          case DapParser::DateTimeLiteral:
          case DapParser::BitLiteral:
          case DapParser::NameLiteral:
          case DapParser::HexLiteral:
          case DapParser::STRINGLITERAL:
          case DapParser::INT:
          case DapParser::FloatingPointLiteral:
          case DapParser::Identifier:
          case DapParser::DOT:
          case DapParser::ADD:
          case DapParser::SUB:
          case DapParser::LParentheses: {
            setState(272);
            expression(0);
            break;
          }

          case DapParser::T__3: {
            setState(273);
            of_var_list();
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(280);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    }
    _ctx->stop = _input->LT(-1);
    setState(290);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<ExpressionListContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleExpressionList);
        setState(281);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(283); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(282);
          match(DapParser::COMMA);
          setState(285); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == DapParser::COMMA);
        setState(287);
        expressionList(2); 
      }
      setState(292);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Of_var_listContext ------------------------------------------------------------------

DapParser::Of_var_listContext::Of_var_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::Of_var_listContext::Identifier() {
  return getTokens(DapParser::Identifier);
}

tree::TerminalNode* DapParser::Of_var_listContext::Identifier(size_t i) {
  return getToken(DapParser::Identifier, i);
}

std::vector<tree::TerminalNode *> DapParser::Of_var_listContext::SUB() {
  return getTokens(DapParser::SUB);
}

tree::TerminalNode* DapParser::Of_var_listContext::SUB(size_t i) {
  return getToken(DapParser::SUB, i);
}

std::vector<tree::TerminalNode *> DapParser::Of_var_listContext::COMMA() {
  return getTokens(DapParser::COMMA);
}

tree::TerminalNode* DapParser::Of_var_listContext::COMMA(size_t i) {
  return getToken(DapParser::COMMA, i);
}

tree::TerminalNode* DapParser::Of_var_listContext::LSqBracket() {
  return getToken(DapParser::LSqBracket, 0);
}

tree::TerminalNode* DapParser::Of_var_listContext::MUL() {
  return getToken(DapParser::MUL, 0);
}

tree::TerminalNode* DapParser::Of_var_listContext::RSqBracket() {
  return getToken(DapParser::RSqBracket, 0);
}


size_t DapParser::Of_var_listContext::getRuleIndex() const {
  return DapParser::RuleOf_var_list;
}

void DapParser::Of_var_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOf_var_list(this);
}

void DapParser::Of_var_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOf_var_list(this);
}


std::any DapParser::Of_var_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitOf_var_list(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Of_var_listContext* DapParser::of_var_list() {
  Of_var_listContext *_localctx = _tracker.createInstance<Of_var_listContext>(_ctx, getState());
  enterRule(_localctx, 16, DapParser::RuleOf_var_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(323);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(293);
      match(DapParser::T__3);

      setState(294);
      match(DapParser::Identifier);
      setState(295);
      match(DapParser::SUB);
      setState(296);
      match(DapParser::Identifier);
      setState(307);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(300);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == DapParser::COMMA) {
            setState(298);
            match(DapParser::COMMA);
            setState(299);
            match(DapParser::T__3);
          }

          setState(302);
          match(DapParser::Identifier);
          setState(303);
          match(DapParser::SUB);
          setState(304);
          match(DapParser::Identifier); 
        }
        setState(309);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(310);
      match(DapParser::T__3);
      setState(311);
      match(DapParser::Identifier);
      setState(315);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(312);
          match(DapParser::Identifier); 
        }
        setState(317);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(318);
      match(DapParser::T__3);
      setState(319);
      match(DapParser::Identifier);
      setState(320);
      match(DapParser::LSqBracket);
      setState(321);
      match(DapParser::MUL);
      setState(322);
      match(DapParser::RSqBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Identifiers_listContext ------------------------------------------------------------------

DapParser::Identifiers_listContext::Identifiers_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::Identifiers_listContext::Identifier() {
  return getTokens(DapParser::Identifier);
}

tree::TerminalNode* DapParser::Identifiers_listContext::Identifier(size_t i) {
  return getToken(DapParser::Identifier, i);
}

std::vector<tree::TerminalNode *> DapParser::Identifiers_listContext::SUB() {
  return getTokens(DapParser::SUB);
}

tree::TerminalNode* DapParser::Identifiers_listContext::SUB(size_t i) {
  return getToken(DapParser::SUB, i);
}


size_t DapParser::Identifiers_listContext::getRuleIndex() const {
  return DapParser::RuleIdentifiers_list;
}

void DapParser::Identifiers_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifiers_list(this);
}

void DapParser::Identifiers_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifiers_list(this);
}


std::any DapParser::Identifiers_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitIdentifiers_list(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Identifiers_listContext* DapParser::identifiers_list() {
  Identifiers_listContext *_localctx = _tracker.createInstance<Identifiers_listContext>(_ctx, getState());
  enterRule(_localctx, 18, DapParser::RuleIdentifiers_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(329); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(329);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
      case 1: {
        setState(325);
        match(DapParser::Identifier);
        break;
      }

      case 2: {
        setState(326);
        match(DapParser::Identifier);
        setState(327);
        match(DapParser::SUB);
        setState(328);
        match(DapParser::Identifier);
        break;
      }

      default:
        break;
      }
      setState(331); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == DapParser::Identifier);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- In_var_listContext ------------------------------------------------------------------

DapParser::In_var_listContext::In_var_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::In_var_listContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}

tree::TerminalNode* DapParser::In_var_listContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

tree::TerminalNode* DapParser::In_var_listContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

std::vector<DapParser::LiteralContext *> DapParser::In_var_listContext::literal() {
  return getRuleContexts<DapParser::LiteralContext>();
}

DapParser::LiteralContext* DapParser::In_var_listContext::literal(size_t i) {
  return getRuleContext<DapParser::LiteralContext>(i);
}

std::vector<DapParser::ColonIntsContext *> DapParser::In_var_listContext::colonInts() {
  return getRuleContexts<DapParser::ColonIntsContext>();
}

DapParser::ColonIntsContext* DapParser::In_var_listContext::colonInts(size_t i) {
  return getRuleContext<DapParser::ColonIntsContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::In_var_listContext::COMMA() {
  return getTokens(DapParser::COMMA);
}

tree::TerminalNode* DapParser::In_var_listContext::COMMA(size_t i) {
  return getToken(DapParser::COMMA, i);
}


size_t DapParser::In_var_listContext::getRuleIndex() const {
  return DapParser::RuleIn_var_list;
}

void DapParser::In_var_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIn_var_list(this);
}

void DapParser::In_var_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIn_var_list(this);
}


std::any DapParser::In_var_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitIn_var_list(this);
  else
    return visitor->visitChildren(this);
}

DapParser::In_var_listContext* DapParser::in_var_list() {
  In_var_listContext *_localctx = _tracker.createInstance<In_var_listContext>(_ctx, getState());
  enterRule(_localctx, 20, DapParser::RuleIn_var_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(351);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(333);
        match(DapParser::Identifier);
        break;
      }

      case DapParser::LParentheses: {
        enterOuterAlt(_localctx, 2);
        setState(334);
        match(DapParser::LParentheses);
        setState(337);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
        case 1: {
          setState(335);
          literal();
          break;
        }

        case 2: {
          setState(336);
          colonInts();
          break;
        }

        default:
          break;
        }
        setState(346);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == DapParser::COMMA) {
          setState(339);
          match(DapParser::COMMA);
          setState(342);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
          case 1: {
            setState(340);
            literal();
            break;
          }

          case 2: {
            setState(341);
            colonInts();
            break;
          }

          default:
            break;
          }
          setState(348);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(349);
        match(DapParser::RParentheses);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColonIntsContext ------------------------------------------------------------------

DapParser::ColonIntsContext::ColonIntsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::ColonIntsContext::INT() {
  return getTokens(DapParser::INT);
}

tree::TerminalNode* DapParser::ColonIntsContext::INT(size_t i) {
  return getToken(DapParser::INT, i);
}

tree::TerminalNode* DapParser::ColonIntsContext::COLON() {
  return getToken(DapParser::COLON, 0);
}


size_t DapParser::ColonIntsContext::getRuleIndex() const {
  return DapParser::RuleColonInts;
}

void DapParser::ColonIntsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColonInts(this);
}

void DapParser::ColonIntsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColonInts(this);
}


std::any DapParser::ColonIntsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitColonInts(this);
  else
    return visitor->visitChildren(this);
}

DapParser::ColonIntsContext* DapParser::colonInts() {
  ColonIntsContext *_localctx = _tracker.createInstance<ColonIntsContext>(_ctx, getState());
  enterRule(_localctx, 22, DapParser::RuleColonInts);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(353);
    match(DapParser::INT);
    setState(354);
    match(DapParser::COLON);
    setState(355);
    match(DapParser::INT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

DapParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::LiteralContext::INT() {
  return getToken(DapParser::INT, 0);
}

tree::TerminalNode* DapParser::LiteralContext::FloatingPointLiteral() {
  return getToken(DapParser::FloatingPointLiteral, 0);
}

tree::TerminalNode* DapParser::LiteralContext::STRINGLITERAL() {
  return getToken(DapParser::STRINGLITERAL, 0);
}

tree::TerminalNode* DapParser::LiteralContext::DateLiteral() {
  return getToken(DapParser::DateLiteral, 0);
}

tree::TerminalNode* DapParser::LiteralContext::TimeLiteral() {
  return getToken(DapParser::TimeLiteral, 0);
}

tree::TerminalNode* DapParser::LiteralContext::DateTimeLiteral() {
  return getToken(DapParser::DateTimeLiteral, 0);
}

tree::TerminalNode* DapParser::LiteralContext::BitLiteral() {
  return getToken(DapParser::BitLiteral, 0);
}

tree::TerminalNode* DapParser::LiteralContext::NameLiteral() {
  return getToken(DapParser::NameLiteral, 0);
}

tree::TerminalNode* DapParser::LiteralContext::HexLiteral() {
  return getToken(DapParser::HexLiteral, 0);
}

tree::TerminalNode* DapParser::LiteralContext::DOT() {
  return getToken(DapParser::DOT, 0);
}


size_t DapParser::LiteralContext::getRuleIndex() const {
  return DapParser::RuleLiteral;
}

void DapParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void DapParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}


std::any DapParser::LiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitLiteral(this);
  else
    return visitor->visitChildren(this);
}

DapParser::LiteralContext* DapParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 24, DapParser::RuleLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(357);
    _la = _input->LA(1);
    if (!(((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 1535) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariablesContext ------------------------------------------------------------------

DapParser::VariablesContext::VariablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::VariablesContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}

tree::TerminalNode* DapParser::VariablesContext::DATE() {
  return getToken(DapParser::DATE, 0);
}

tree::TerminalNode* DapParser::VariablesContext::ALTER() {
  return getToken(DapParser::ALTER, 0);
}

tree::TerminalNode* DapParser::VariablesContext::DROP() {
  return getToken(DapParser::DROP, 0);
}

std::vector<DapParser::VariablesContext *> DapParser::VariablesContext::variables() {
  return getRuleContexts<DapParser::VariablesContext>();
}

DapParser::VariablesContext* DapParser::VariablesContext::variables(size_t i) {
  return getRuleContext<DapParser::VariablesContext>(i);
}

tree::TerminalNode* DapParser::VariablesContext::DOT() {
  return getToken(DapParser::DOT, 0);
}


size_t DapParser::VariablesContext::getRuleIndex() const {
  return DapParser::RuleVariables;
}

void DapParser::VariablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariables(this);
}

void DapParser::VariablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariables(this);
}


std::any DapParser::VariablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitVariables(this);
  else
    return visitor->visitChildren(this);
}


DapParser::VariablesContext* DapParser::variables() {
   return variables(0);
}

DapParser::VariablesContext* DapParser::variables(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  DapParser::VariablesContext *_localctx = _tracker.createInstance<VariablesContext>(_ctx, parentState);
  DapParser::VariablesContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 26;
  enterRecursionRule(_localctx, 26, DapParser::RuleVariables, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(364);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::Identifier: {
        setState(360);
        match(DapParser::Identifier);
        break;
      }

      case DapParser::DATE: {
        setState(361);
        match(DapParser::DATE);
        break;
      }

      case DapParser::ALTER: {
        setState(362);
        match(DapParser::ALTER);
        break;
      }

      case DapParser::DROP: {
        setState(363);
        match(DapParser::DROP);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(371);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<VariablesContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleVariables);
        setState(366);

        if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
        setState(367);
        match(DapParser::DOT);
        setState(368);
        variables(6); 
      }
      setState(373);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Abort_mainContext ------------------------------------------------------------------

DapParser::Abort_mainContext::Abort_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Abort_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Abort_stmtContext *> DapParser::Abort_mainContext::abort_stmt() {
  return getRuleContexts<DapParser::Abort_stmtContext>();
}

DapParser::Abort_stmtContext* DapParser::Abort_mainContext::abort_stmt(size_t i) {
  return getRuleContext<DapParser::Abort_stmtContext>(i);
}


size_t DapParser::Abort_mainContext::getRuleIndex() const {
  return DapParser::RuleAbort_main;
}

void DapParser::Abort_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAbort_main(this);
}

void DapParser::Abort_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAbort_main(this);
}


std::any DapParser::Abort_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitAbort_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Abort_mainContext* DapParser::abort_main() {
  Abort_mainContext *_localctx = _tracker.createInstance<Abort_mainContext>(_ctx, getState());
  enterRule(_localctx, 28, DapParser::RuleAbort_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(377);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::ABORT) {
      setState(374);
      abort_stmt();
      setState(379);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(380);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Abort_stmtContext ------------------------------------------------------------------

DapParser::Abort_stmtContext::Abort_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Abort_stmtContext::ABORT() {
  return getToken(DapParser::ABORT, 0);
}

tree::TerminalNode* DapParser::Abort_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

tree::TerminalNode* DapParser::Abort_stmtContext::ABEND() {
  return getToken(DapParser::ABEND, 0);
}

tree::TerminalNode* DapParser::Abort_stmtContext::CANCEL() {
  return getToken(DapParser::CANCEL, 0);
}

tree::TerminalNode* DapParser::Abort_stmtContext::RETURN() {
  return getToken(DapParser::RETURN, 0);
}

tree::TerminalNode* DapParser::Abort_stmtContext::INT() {
  return getToken(DapParser::INT, 0);
}

tree::TerminalNode* DapParser::Abort_stmtContext::NOLIST() {
  return getToken(DapParser::NOLIST, 0);
}

DapParser::File_specContext* DapParser::Abort_stmtContext::file_spec() {
  return getRuleContext<DapParser::File_specContext>(0);
}


size_t DapParser::Abort_stmtContext::getRuleIndex() const {
  return DapParser::RuleAbort_stmt;
}

void DapParser::Abort_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAbort_stmt(this);
}

void DapParser::Abort_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAbort_stmt(this);
}


std::any DapParser::Abort_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitAbort_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Abort_stmtContext* DapParser::abort_stmt() {
  Abort_stmtContext *_localctx = _tracker.createInstance<Abort_stmtContext>(_ctx, getState());
  enterRule(_localctx, 30, DapParser::RuleAbort_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(382);
    match(DapParser::ABORT);
    setState(389);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::ABEND: {
        setState(383);
        match(DapParser::ABEND);
        break;
      }

      case DapParser::CANCEL: {
        setState(384);
        match(DapParser::CANCEL);
        setState(386);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == DapParser::STRINGLITERAL) {
          setState(385);
          file_spec();
        }
        break;
      }

      case DapParser::RETURN: {
        setState(388);
        match(DapParser::RETURN);
        break;
      }

      case DapParser::NOLIST:
      case DapParser::INT:
      case DapParser::SEMICOLON: {
        break;
      }

    default:
      break;
    }
    setState(392);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::INT) {
      setState(391);
      match(DapParser::INT);
    }
    setState(395);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::NOLIST) {
      setState(394);
      match(DapParser::NOLIST);
    }
    setState(397);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_specContext ------------------------------------------------------------------

DapParser::File_specContext::File_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::File_specContext::STRINGLITERAL() {
  return getToken(DapParser::STRINGLITERAL, 0);
}


size_t DapParser::File_specContext::getRuleIndex() const {
  return DapParser::RuleFile_spec;
}

void DapParser::File_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_spec(this);
}

void DapParser::File_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_spec(this);
}


std::any DapParser::File_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitFile_spec(this);
  else
    return visitor->visitChildren(this);
}

DapParser::File_specContext* DapParser::file_spec() {
  File_specContext *_localctx = _tracker.createInstance<File_specContext>(_ctx, getState());
  enterRule(_localctx, 32, DapParser::RuleFile_spec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(399);
    match(DapParser::STRINGLITERAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Proc_mainContext ------------------------------------------------------------------

DapParser::Proc_mainContext::Proc_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Proc_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Proc_stmtContext *> DapParser::Proc_mainContext::proc_stmt() {
  return getRuleContexts<DapParser::Proc_stmtContext>();
}

DapParser::Proc_stmtContext* DapParser::Proc_mainContext::proc_stmt(size_t i) {
  return getRuleContext<DapParser::Proc_stmtContext>(i);
}


size_t DapParser::Proc_mainContext::getRuleIndex() const {
  return DapParser::RuleProc_main;
}

void DapParser::Proc_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProc_main(this);
}

void DapParser::Proc_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProc_main(this);
}


std::any DapParser::Proc_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitProc_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Proc_mainContext* DapParser::proc_main() {
  Proc_mainContext *_localctx = _tracker.createInstance<Proc_mainContext>(_ctx, getState());
  enterRule(_localctx, 34, DapParser::RuleProc_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(404);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::PROC) {
      setState(401);
      proc_stmt();
      setState(406);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(407);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Proc_stmtContext ------------------------------------------------------------------

DapParser::Proc_stmtContext::Proc_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Proc_stmtContext::PROC() {
  return getToken(DapParser::PROC, 0);
}

DapParser::Proc_nameContext* DapParser::Proc_stmtContext::proc_name() {
  return getRuleContext<DapParser::Proc_nameContext>(0);
}

std::vector<tree::TerminalNode *> DapParser::Proc_stmtContext::SEMICOLON() {
  return getTokens(DapParser::SEMICOLON);
}

tree::TerminalNode* DapParser::Proc_stmtContext::SEMICOLON(size_t i) {
  return getToken(DapParser::SEMICOLON, i);
}


size_t DapParser::Proc_stmtContext::getRuleIndex() const {
  return DapParser::RuleProc_stmt;
}

void DapParser::Proc_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProc_stmt(this);
}

void DapParser::Proc_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProc_stmt(this);
}


std::any DapParser::Proc_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitProc_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Proc_stmtContext* DapParser::proc_stmt() {
  Proc_stmtContext *_localctx = _tracker.createInstance<Proc_stmtContext>(_ctx, getState());
  enterRule(_localctx, 36, DapParser::RuleProc_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(409);
    match(DapParser::PROC);
    setState(410);
    proc_name();
    setState(414);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(411);
        _la = _input->LA(1);
        if (_la == 0 || _la == Token::EOF || (_la == DapParser::SEMICOLON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(416);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx);
    }
    setState(417);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Proc_nameContext ------------------------------------------------------------------

DapParser::Proc_nameContext::Proc_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Proc_nameContext::ANOVA() {
  return getToken(DapParser::ANOVA, 0);
}

tree::TerminalNode* DapParser::Proc_nameContext::CORR() {
  return getToken(DapParser::CORR, 0);
}

tree::TerminalNode* DapParser::Proc_nameContext::MEANS() {
  return getToken(DapParser::MEANS, 0);
}

tree::TerminalNode* DapParser::Proc_nameContext::REG() {
  return getToken(DapParser::REG, 0);
}

tree::TerminalNode* DapParser::Proc_nameContext::SGPLOT() {
  return getToken(DapParser::SGPLOT, 0);
}

tree::TerminalNode* DapParser::Proc_nameContext::PRINT() {
  return getToken(DapParser::PRINT, 0);
}


size_t DapParser::Proc_nameContext::getRuleIndex() const {
  return DapParser::RuleProc_name;
}

void DapParser::Proc_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProc_name(this);
}

void DapParser::Proc_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProc_name(this);
}


std::any DapParser::Proc_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitProc_name(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Proc_nameContext* DapParser::proc_name() {
  Proc_nameContext *_localctx = _tracker.createInstance<Proc_nameContext>(_ctx, getState());
  enterRule(_localctx, 38, DapParser::RuleProc_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(419);
    _la = _input->LA(1);
    if (!(((((_la - 163) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 163)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_mainContext ------------------------------------------------------------------

DapParser::Array_mainContext::Array_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Array_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Array_stmtContext *> DapParser::Array_mainContext::array_stmt() {
  return getRuleContexts<DapParser::Array_stmtContext>();
}

DapParser::Array_stmtContext* DapParser::Array_mainContext::array_stmt(size_t i) {
  return getRuleContext<DapParser::Array_stmtContext>(i);
}


size_t DapParser::Array_mainContext::getRuleIndex() const {
  return DapParser::RuleArray_main;
}

void DapParser::Array_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_main(this);
}

void DapParser::Array_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_main(this);
}


std::any DapParser::Array_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitArray_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Array_mainContext* DapParser::array_main() {
  Array_mainContext *_localctx = _tracker.createInstance<Array_mainContext>(_ctx, getState());
  enterRule(_localctx, 40, DapParser::RuleArray_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(424);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::ARRAY) {
      setState(421);
      array_stmt();
      setState(426);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(427);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_stmtContext ------------------------------------------------------------------

DapParser::Array_stmtContext::Array_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Array_stmtContext::ARRAY() {
  return getToken(DapParser::ARRAY, 0);
}

DapParser::Array_nameContext* DapParser::Array_stmtContext::array_name() {
  return getRuleContext<DapParser::Array_nameContext>(0);
}

tree::TerminalNode* DapParser::Array_stmtContext::LBracket() {
  return getToken(DapParser::LBracket, 0);
}

DapParser::Array_subscriptContext* DapParser::Array_stmtContext::array_subscript() {
  return getRuleContext<DapParser::Array_subscriptContext>(0);
}

tree::TerminalNode* DapParser::Array_stmtContext::RBracket() {
  return getToken(DapParser::RBracket, 0);
}

tree::TerminalNode* DapParser::Array_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

tree::TerminalNode* DapParser::Array_stmtContext::DOLLAR() {
  return getToken(DapParser::DOLLAR, 0);
}

tree::TerminalNode* DapParser::Array_stmtContext::INT() {
  return getToken(DapParser::INT, 0);
}

DapParser::Array_elementsContext* DapParser::Array_stmtContext::array_elements() {
  return getRuleContext<DapParser::Array_elementsContext>(0);
}

DapParser::Initial_value_listContext* DapParser::Array_stmtContext::initial_value_list() {
  return getRuleContext<DapParser::Initial_value_listContext>(0);
}


size_t DapParser::Array_stmtContext::getRuleIndex() const {
  return DapParser::RuleArray_stmt;
}

void DapParser::Array_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_stmt(this);
}

void DapParser::Array_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_stmt(this);
}


std::any DapParser::Array_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitArray_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Array_stmtContext* DapParser::array_stmt() {
  Array_stmtContext *_localctx = _tracker.createInstance<Array_stmtContext>(_ctx, getState());
  enterRule(_localctx, 42, DapParser::RuleArray_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(429);
    match(DapParser::ARRAY);
    setState(430);
    array_name();
    setState(431);
    match(DapParser::LBracket);
    setState(432);
    array_subscript();
    setState(433);
    match(DapParser::RBracket);
    setState(435);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::DOLLAR) {
      setState(434);
      match(DapParser::DOLLAR);
    }
    setState(438);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::INT) {
      setState(437);
      match(DapParser::INT);
    }
    setState(441);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 108) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 108)) & 7) != 0) || _la == DapParser::Identifier) {
      setState(440);
      array_elements();
    }
    setState(444);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::LParentheses) {
      setState(443);
      initial_value_list();
    }
    setState(446);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_nameContext ------------------------------------------------------------------

DapParser::Array_nameContext::Array_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Array_nameContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}


size_t DapParser::Array_nameContext::getRuleIndex() const {
  return DapParser::RuleArray_name;
}

void DapParser::Array_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_name(this);
}

void DapParser::Array_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_name(this);
}


std::any DapParser::Array_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitArray_name(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Array_nameContext* DapParser::array_name() {
  Array_nameContext *_localctx = _tracker.createInstance<Array_nameContext>(_ctx, getState());
  enterRule(_localctx, 44, DapParser::RuleArray_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(448);
    match(DapParser::Identifier);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_subscriptContext ------------------------------------------------------------------

DapParser::Array_subscriptContext::Array_subscriptContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Array_subscriptContext::MUL() {
  return getToken(DapParser::MUL, 0);
}

std::vector<tree::TerminalNode *> DapParser::Array_subscriptContext::INT() {
  return getTokens(DapParser::INT);
}

tree::TerminalNode* DapParser::Array_subscriptContext::INT(size_t i) {
  return getToken(DapParser::INT, i);
}

std::vector<tree::TerminalNode *> DapParser::Array_subscriptContext::COMMA() {
  return getTokens(DapParser::COMMA);
}

tree::TerminalNode* DapParser::Array_subscriptContext::COMMA(size_t i) {
  return getToken(DapParser::COMMA, i);
}

std::vector<tree::TerminalNode *> DapParser::Array_subscriptContext::COLON() {
  return getTokens(DapParser::COLON);
}

tree::TerminalNode* DapParser::Array_subscriptContext::COLON(size_t i) {
  return getToken(DapParser::COLON, i);
}


size_t DapParser::Array_subscriptContext::getRuleIndex() const {
  return DapParser::RuleArray_subscript;
}

void DapParser::Array_subscriptContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_subscript(this);
}

void DapParser::Array_subscriptContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_subscript(this);
}


std::any DapParser::Array_subscriptContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitArray_subscript(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Array_subscriptContext* DapParser::array_subscript() {
  Array_subscriptContext *_localctx = _tracker.createInstance<Array_subscriptContext>(_ctx, getState());
  enterRule(_localctx, 46, DapParser::RuleArray_subscript);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(471);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(450);
      match(DapParser::MUL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(451);
      match(DapParser::INT);
      setState(456);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == DapParser::COMMA) {
        setState(452);
        match(DapParser::COMMA);
        setState(453);
        match(DapParser::INT);
        setState(458);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(459);
      match(DapParser::INT);
      setState(460);
      match(DapParser::COLON);
      setState(461);
      match(DapParser::INT);
      setState(468);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == DapParser::COMMA) {
        setState(462);
        match(DapParser::COMMA);
        setState(463);
        match(DapParser::INT);
        setState(464);
        match(DapParser::COLON);
        setState(465);
        match(DapParser::INT);
        setState(470);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_elementsContext ------------------------------------------------------------------

DapParser::Array_elementsContext::Array_elementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Array_elementsContext::ARRAY_NUMERIC_ELEMENTS() {
  return getToken(DapParser::ARRAY_NUMERIC_ELEMENTS, 0);
}

tree::TerminalNode* DapParser::Array_elementsContext::ARRAY_CHARACTER_ELEMENTS() {
  return getToken(DapParser::ARRAY_CHARACTER_ELEMENTS, 0);
}

tree::TerminalNode* DapParser::Array_elementsContext::ARRAY_ALL_ELEMENTS() {
  return getToken(DapParser::ARRAY_ALL_ELEMENTS, 0);
}

std::vector<tree::TerminalNode *> DapParser::Array_elementsContext::Identifier() {
  return getTokens(DapParser::Identifier);
}

tree::TerminalNode* DapParser::Array_elementsContext::Identifier(size_t i) {
  return getToken(DapParser::Identifier, i);
}

tree::TerminalNode* DapParser::Array_elementsContext::SUB() {
  return getToken(DapParser::SUB, 0);
}


size_t DapParser::Array_elementsContext::getRuleIndex() const {
  return DapParser::RuleArray_elements;
}

void DapParser::Array_elementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_elements(this);
}

void DapParser::Array_elementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_elements(this);
}


std::any DapParser::Array_elementsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitArray_elements(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Array_elementsContext* DapParser::array_elements() {
  Array_elementsContext *_localctx = _tracker.createInstance<Array_elementsContext>(_ctx, getState());
  enterRule(_localctx, 48, DapParser::RuleArray_elements);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(484);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(473);
      match(DapParser::ARRAY_NUMERIC_ELEMENTS);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(474);
      match(DapParser::ARRAY_CHARACTER_ELEMENTS);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(475);
      match(DapParser::ARRAY_ALL_ELEMENTS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(477); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(476);
        match(DapParser::Identifier);
        setState(479); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == DapParser::Identifier);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(481);
      match(DapParser::Identifier);
      setState(482);
      match(DapParser::SUB);
      setState(483);
      match(DapParser::Identifier);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initial_value_listContext ------------------------------------------------------------------

DapParser::Initial_value_listContext::Initial_value_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Initial_value_listContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

tree::TerminalNode* DapParser::Initial_value_listContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

std::vector<DapParser::Initial_value_list_itemContext *> DapParser::Initial_value_listContext::initial_value_list_item() {
  return getRuleContexts<DapParser::Initial_value_list_itemContext>();
}

DapParser::Initial_value_list_itemContext* DapParser::Initial_value_listContext::initial_value_list_item(size_t i) {
  return getRuleContext<DapParser::Initial_value_list_itemContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::Initial_value_listContext::COMMA() {
  return getTokens(DapParser::COMMA);
}

tree::TerminalNode* DapParser::Initial_value_listContext::COMMA(size_t i) {
  return getToken(DapParser::COMMA, i);
}


size_t DapParser::Initial_value_listContext::getRuleIndex() const {
  return DapParser::RuleInitial_value_list;
}

void DapParser::Initial_value_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitial_value_list(this);
}

void DapParser::Initial_value_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitial_value_list(this);
}


std::any DapParser::Initial_value_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInitial_value_list(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Initial_value_listContext* DapParser::initial_value_list() {
  Initial_value_listContext *_localctx = _tracker.createInstance<Initial_value_listContext>(_ctx, getState());
  enterRule(_localctx, 50, DapParser::RuleInitial_value_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(486);
    match(DapParser::LParentheses);

    setState(487);
    initial_value_list_item();
    setState(494);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 197) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 197)) & 135) != 0)) {
      setState(489);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::COMMA) {
        setState(488);
        match(DapParser::COMMA);
      }
      setState(491);
      initial_value_list_item();
      setState(496);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(497);
    match(DapParser::RParentheses);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initial_value_list_itemContext ------------------------------------------------------------------

DapParser::Initial_value_list_itemContext::Initial_value_list_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::Initial_value_list_itemContext::INT() {
  return getTokens(DapParser::INT);
}

tree::TerminalNode* DapParser::Initial_value_list_itemContext::INT(size_t i) {
  return getToken(DapParser::INT, i);
}

tree::TerminalNode* DapParser::Initial_value_list_itemContext::COLON() {
  return getToken(DapParser::COLON, 0);
}

DapParser::Constant_iter_valueContext* DapParser::Initial_value_list_itemContext::constant_iter_value() {
  return getRuleContext<DapParser::Constant_iter_valueContext>(0);
}

tree::TerminalNode* DapParser::Initial_value_list_itemContext::MUL() {
  return getToken(DapParser::MUL, 0);
}

DapParser::Initial_value_listContext* DapParser::Initial_value_list_itemContext::initial_value_list() {
  return getRuleContext<DapParser::Initial_value_listContext>(0);
}

DapParser::Constant_valueContext* DapParser::Initial_value_list_itemContext::constant_value() {
  return getRuleContext<DapParser::Constant_valueContext>(0);
}


size_t DapParser::Initial_value_list_itemContext::getRuleIndex() const {
  return DapParser::RuleInitial_value_list_item;
}

void DapParser::Initial_value_list_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitial_value_list_item(this);
}

void DapParser::Initial_value_list_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitial_value_list_item(this);
}


std::any DapParser::Initial_value_list_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInitial_value_list_item(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Initial_value_list_itemContext* DapParser::initial_value_list_item() {
  Initial_value_list_itemContext *_localctx = _tracker.createInstance<Initial_value_list_itemContext>(_ctx, getState());
  enterRule(_localctx, 52, DapParser::RuleInitial_value_list_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(511);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(499);
      match(DapParser::INT);
      setState(500);
      match(DapParser::COLON);
      setState(501);
      match(DapParser::INT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(502);
      constant_iter_value();
      setState(503);
      match(DapParser::MUL);
      setState(504);
      initial_value_list();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(506);
      constant_iter_value();
      setState(507);
      match(DapParser::MUL);
      setState(508);
      constant_value();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(510);
      constant_value();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initial_value_list_bkContext ------------------------------------------------------------------

DapParser::Initial_value_list_bkContext::Initial_value_list_bkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Initial_value_list_bkContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

tree::TerminalNode* DapParser::Initial_value_list_bkContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

std::vector<DapParser::Constant_valueContext *> DapParser::Initial_value_list_bkContext::constant_value() {
  return getRuleContexts<DapParser::Constant_valueContext>();
}

DapParser::Constant_valueContext* DapParser::Initial_value_list_bkContext::constant_value(size_t i) {
  return getRuleContext<DapParser::Constant_valueContext>(i);
}

std::vector<DapParser::Constant_iter_valueContext *> DapParser::Initial_value_list_bkContext::constant_iter_value() {
  return getRuleContexts<DapParser::Constant_iter_valueContext>();
}

DapParser::Constant_iter_valueContext* DapParser::Initial_value_list_bkContext::constant_iter_value(size_t i) {
  return getRuleContext<DapParser::Constant_iter_valueContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::Initial_value_list_bkContext::MUL() {
  return getTokens(DapParser::MUL);
}

tree::TerminalNode* DapParser::Initial_value_list_bkContext::MUL(size_t i) {
  return getToken(DapParser::MUL, i);
}

std::vector<DapParser::Initial_value_listContext *> DapParser::Initial_value_list_bkContext::initial_value_list() {
  return getRuleContexts<DapParser::Initial_value_listContext>();
}

DapParser::Initial_value_listContext* DapParser::Initial_value_list_bkContext::initial_value_list(size_t i) {
  return getRuleContext<DapParser::Initial_value_listContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::Initial_value_list_bkContext::COMMA() {
  return getTokens(DapParser::COMMA);
}

tree::TerminalNode* DapParser::Initial_value_list_bkContext::COMMA(size_t i) {
  return getToken(DapParser::COMMA, i);
}


size_t DapParser::Initial_value_list_bkContext::getRuleIndex() const {
  return DapParser::RuleInitial_value_list_bk;
}

void DapParser::Initial_value_list_bkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitial_value_list_bk(this);
}

void DapParser::Initial_value_list_bkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitial_value_list_bk(this);
}


std::any DapParser::Initial_value_list_bkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInitial_value_list_bk(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Initial_value_list_bkContext* DapParser::initial_value_list_bk() {
  Initial_value_list_bkContext *_localctx = _tracker.createInstance<Initial_value_list_bkContext>(_ctx, getState());
  enterRule(_localctx, 54, DapParser::RuleInitial_value_list_bk);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(513);
    match(DapParser::LParentheses);
    setState(523);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(514);
      constant_iter_value();
      setState(515);
      match(DapParser::MUL);
      setState(516);
      initial_value_list();
      break;
    }

    case 2: {
      setState(518);
      constant_iter_value();
      setState(519);
      match(DapParser::MUL);
      setState(520);
      constant_value();
      break;
    }

    case 3: {
      setState(522);
      constant_value();
      break;
    }

    default:
      break;
    }
    setState(541);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 197) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 197)) & 135) != 0)) {
      setState(526);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::COMMA) {
        setState(525);
        match(DapParser::COMMA);
      }
      setState(537);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
      case 1: {
        setState(528);
        constant_iter_value();
        setState(529);
        match(DapParser::MUL);
        setState(530);
        initial_value_list();
        break;
      }

      case 2: {
        setState(532);
        constant_iter_value();
        setState(533);
        match(DapParser::MUL);
        setState(534);
        constant_value();
        break;
      }

      case 3: {
        setState(536);
        constant_value();
        break;
      }

      default:
        break;
      }
      setState(543);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(544);
    match(DapParser::RParentheses);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_iter_valueContext ------------------------------------------------------------------

DapParser::Constant_iter_valueContext::Constant_iter_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Constant_iter_valueContext::INT() {
  return getToken(DapParser::INT, 0);
}


size_t DapParser::Constant_iter_valueContext::getRuleIndex() const {
  return DapParser::RuleConstant_iter_value;
}

void DapParser::Constant_iter_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_iter_value(this);
}

void DapParser::Constant_iter_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_iter_value(this);
}


std::any DapParser::Constant_iter_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitConstant_iter_value(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Constant_iter_valueContext* DapParser::constant_iter_value() {
  Constant_iter_valueContext *_localctx = _tracker.createInstance<Constant_iter_valueContext>(_ctx, getState());
  enterRule(_localctx, 56, DapParser::RuleConstant_iter_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(546);
    match(DapParser::INT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_valueContext ------------------------------------------------------------------

DapParser::Constant_valueContext::Constant_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Constant_valueContext::INT() {
  return getToken(DapParser::INT, 0);
}

tree::TerminalNode* DapParser::Constant_valueContext::FloatingPointLiteral() {
  return getToken(DapParser::FloatingPointLiteral, 0);
}

tree::TerminalNode* DapParser::Constant_valueContext::STRINGLITERAL() {
  return getToken(DapParser::STRINGLITERAL, 0);
}


size_t DapParser::Constant_valueContext::getRuleIndex() const {
  return DapParser::RuleConstant_value;
}

void DapParser::Constant_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_value(this);
}

void DapParser::Constant_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_value(this);
}


std::any DapParser::Constant_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitConstant_value(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Constant_valueContext* DapParser::constant_value() {
  Constant_valueContext *_localctx = _tracker.createInstance<Constant_valueContext>(_ctx, getState());
  enterRule(_localctx, 58, DapParser::RuleConstant_value);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(548);
    _la = _input->LA(1);
    if (!(((((_la - 197) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 197)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assign_mainContext ------------------------------------------------------------------

DapParser::Assign_mainContext::Assign_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Assign_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Assign_stmtContext *> DapParser::Assign_mainContext::assign_stmt() {
  return getRuleContexts<DapParser::Assign_stmtContext>();
}

DapParser::Assign_stmtContext* DapParser::Assign_mainContext::assign_stmt(size_t i) {
  return getRuleContext<DapParser::Assign_stmtContext>(i);
}


size_t DapParser::Assign_mainContext::getRuleIndex() const {
  return DapParser::RuleAssign_main;
}

void DapParser::Assign_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssign_main(this);
}

void DapParser::Assign_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssign_main(this);
}


std::any DapParser::Assign_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitAssign_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Assign_mainContext* DapParser::assign_main() {
  Assign_mainContext *_localctx = _tracker.createInstance<Assign_mainContext>(_ctx, getState());
  enterRule(_localctx, 60, DapParser::RuleAssign_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(553);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::Identifier) {
      setState(550);
      assign_stmt();
      setState(555);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(556);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assign_stmtContext ------------------------------------------------------------------

DapParser::Assign_stmtContext::Assign_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Assign_stmtContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}

tree::TerminalNode* DapParser::Assign_stmtContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

DapParser::ExpressionContext* DapParser::Assign_stmtContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::Assign_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}


size_t DapParser::Assign_stmtContext::getRuleIndex() const {
  return DapParser::RuleAssign_stmt;
}

void DapParser::Assign_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssign_stmt(this);
}

void DapParser::Assign_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssign_stmt(this);
}


std::any DapParser::Assign_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitAssign_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Assign_stmtContext* DapParser::assign_stmt() {
  Assign_stmtContext *_localctx = _tracker.createInstance<Assign_stmtContext>(_ctx, getState());
  enterRule(_localctx, 62, DapParser::RuleAssign_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(558);
    match(DapParser::Identifier);
    setState(559);
    match(DapParser::EQUAL);
    setState(560);
    expression(0);
    setState(561);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- By_mainContext ------------------------------------------------------------------

DapParser::By_mainContext::By_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::By_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::By_stmtContext *> DapParser::By_mainContext::by_stmt() {
  return getRuleContexts<DapParser::By_stmtContext>();
}

DapParser::By_stmtContext* DapParser::By_mainContext::by_stmt(size_t i) {
  return getRuleContext<DapParser::By_stmtContext>(i);
}


size_t DapParser::By_mainContext::getRuleIndex() const {
  return DapParser::RuleBy_main;
}

void DapParser::By_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBy_main(this);
}

void DapParser::By_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBy_main(this);
}


std::any DapParser::By_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitBy_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::By_mainContext* DapParser::by_main() {
  By_mainContext *_localctx = _tracker.createInstance<By_mainContext>(_ctx, getState());
  enterRule(_localctx, 64, DapParser::RuleBy_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(566);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::BY) {
      setState(563);
      by_stmt();
      setState(568);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(569);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- By_stmtContext ------------------------------------------------------------------

DapParser::By_stmtContext::By_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::By_stmtContext::BY() {
  return getToken(DapParser::BY, 0);
}

tree::TerminalNode* DapParser::By_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

std::vector<tree::TerminalNode *> DapParser::By_stmtContext::Identifier() {
  return getTokens(DapParser::Identifier);
}

tree::TerminalNode* DapParser::By_stmtContext::Identifier(size_t i) {
  return getToken(DapParser::Identifier, i);
}

tree::TerminalNode* DapParser::By_stmtContext::NOTSORTED() {
  return getToken(DapParser::NOTSORTED, 0);
}

tree::TerminalNode* DapParser::By_stmtContext::GROUPFORMAT() {
  return getToken(DapParser::GROUPFORMAT, 0);
}

std::vector<tree::TerminalNode *> DapParser::By_stmtContext::DESCENDING() {
  return getTokens(DapParser::DESCENDING);
}

tree::TerminalNode* DapParser::By_stmtContext::DESCENDING(size_t i) {
  return getToken(DapParser::DESCENDING, i);
}


size_t DapParser::By_stmtContext::getRuleIndex() const {
  return DapParser::RuleBy_stmt;
}

void DapParser::By_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBy_stmt(this);
}

void DapParser::By_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBy_stmt(this);
}


std::any DapParser::By_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitBy_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::By_stmtContext* DapParser::by_stmt() {
  By_stmtContext *_localctx = _tracker.createInstance<By_stmtContext>(_ctx, getState());
  enterRule(_localctx, 66, DapParser::RuleBy_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(571);
    match(DapParser::BY);

    setState(573);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::DESCENDING) {
      setState(572);
      match(DapParser::DESCENDING);
    }
    setState(575);
    match(DapParser::Identifier);
    setState(583);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::DESCENDING || _la == DapParser::Identifier) {
      setState(578);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::DESCENDING) {
        setState(577);
        match(DapParser::DESCENDING);
      }
      setState(580);
      match(DapParser::Identifier);
      setState(585);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(587);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::NOTSORTED) {
      setState(586);
      match(DapParser::NOTSORTED);
    }
    setState(590);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::GROUPFORMAT) {
      setState(589);
      match(DapParser::GROUPFORMAT);
    }
    setState(592);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_mainContext ------------------------------------------------------------------

DapParser::Call_mainContext::Call_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Call_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Call_stmtContext *> DapParser::Call_mainContext::call_stmt() {
  return getRuleContexts<DapParser::Call_stmtContext>();
}

DapParser::Call_stmtContext* DapParser::Call_mainContext::call_stmt(size_t i) {
  return getRuleContext<DapParser::Call_stmtContext>(i);
}


size_t DapParser::Call_mainContext::getRuleIndex() const {
  return DapParser::RuleCall_main;
}

void DapParser::Call_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_main(this);
}

void DapParser::Call_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_main(this);
}


std::any DapParser::Call_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitCall_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Call_mainContext* DapParser::call_main() {
  Call_mainContext *_localctx = _tracker.createInstance<Call_mainContext>(_ctx, getState());
  enterRule(_localctx, 68, DapParser::RuleCall_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(597);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::CALL) {
      setState(594);
      call_stmt();
      setState(599);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(600);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_stmtContext ------------------------------------------------------------------

DapParser::Call_stmtContext::Call_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Call_stmtContext::CALL() {
  return getToken(DapParser::CALL, 0);
}

DapParser::ExpressionContext* DapParser::Call_stmtContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::Call_stmtContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

tree::TerminalNode* DapParser::Call_stmtContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

tree::TerminalNode* DapParser::Call_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

DapParser::ExpressionListContext* DapParser::Call_stmtContext::expressionList() {
  return getRuleContext<DapParser::ExpressionListContext>(0);
}


size_t DapParser::Call_stmtContext::getRuleIndex() const {
  return DapParser::RuleCall_stmt;
}

void DapParser::Call_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_stmt(this);
}

void DapParser::Call_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_stmt(this);
}


std::any DapParser::Call_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitCall_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Call_stmtContext* DapParser::call_stmt() {
  Call_stmtContext *_localctx = _tracker.createInstance<Call_stmtContext>(_ctx, getState());
  enterRule(_localctx, 70, DapParser::RuleCall_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(602);
    match(DapParser::CALL);
    setState(603);
    expression(0);
    setState(604);
    match(DapParser::LParentheses);
    setState(606);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::T__3 || ((((_la - 188) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 188)) & 8992604153) != 0)) {
      setState(605);
      expressionList(0);
    }
    setState(608);
    match(DapParser::RParentheses);
    setState(609);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_mainContext ------------------------------------------------------------------

DapParser::Data_mainContext::Data_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Data_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Data_stmtContext *> DapParser::Data_mainContext::data_stmt() {
  return getRuleContexts<DapParser::Data_stmtContext>();
}

DapParser::Data_stmtContext* DapParser::Data_mainContext::data_stmt(size_t i) {
  return getRuleContext<DapParser::Data_stmtContext>(i);
}


size_t DapParser::Data_mainContext::getRuleIndex() const {
  return DapParser::RuleData_main;
}

void DapParser::Data_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterData_main(this);
}

void DapParser::Data_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitData_main(this);
}


std::any DapParser::Data_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitData_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Data_mainContext* DapParser::data_main() {
  Data_mainContext *_localctx = _tracker.createInstance<Data_mainContext>(_ctx, getState());
  enterRule(_localctx, 72, DapParser::RuleData_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(614);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::DATA) {
      setState(611);
      data_stmt();
      setState(616);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(617);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_stmtContext ------------------------------------------------------------------

DapParser::Data_stmtContext::Data_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Data_stmtContext::DATA() {
  return getToken(DapParser::DATA, 0);
}

tree::TerminalNode* DapParser::Data_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

tree::TerminalNode* DapParser::Data_stmtContext::Tk_NULL() {
  return getToken(DapParser::Tk_NULL, 0);
}

DapParser::Datastmt_cmdContext* DapParser::Data_stmtContext::datastmt_cmd() {
  return getRuleContext<DapParser::Datastmt_cmdContext>(0);
}

tree::TerminalNode* DapParser::Data_stmtContext::NOLIST() {
  return getToken(DapParser::NOLIST, 0);
}

std::vector<DapParser::Dataset_name_optContext *> DapParser::Data_stmtContext::dataset_name_opt() {
  return getRuleContexts<DapParser::Dataset_name_optContext>();
}

DapParser::Dataset_name_optContext* DapParser::Data_stmtContext::dataset_name_opt(size_t i) {
  return getRuleContext<DapParser::Dataset_name_optContext>(i);
}

tree::TerminalNode* DapParser::Data_stmtContext::DIV() {
  return getToken(DapParser::DIV, 0);
}

tree::TerminalNode* DapParser::Data_stmtContext::VIEW() {
  return getToken(DapParser::VIEW, 0);
}

tree::TerminalNode* DapParser::Data_stmtContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

DapParser::View_nameContext* DapParser::Data_stmtContext::view_name() {
  return getRuleContext<DapParser::View_nameContext>(0);
}

std::vector<DapParser::View_dsname_optContext *> DapParser::Data_stmtContext::view_dsname_opt() {
  return getRuleContexts<DapParser::View_dsname_optContext>();
}

DapParser::View_dsname_optContext* DapParser::Data_stmtContext::view_dsname_opt(size_t i) {
  return getRuleContext<DapParser::View_dsname_optContext>(i);
}

DapParser::Passwd_optContext* DapParser::Data_stmtContext::passwd_opt() {
  return getRuleContext<DapParser::Passwd_optContext>(0);
}

DapParser::Source_optContext* DapParser::Data_stmtContext::source_opt() {
  return getRuleContext<DapParser::Source_optContext>(0);
}

tree::TerminalNode* DapParser::Data_stmtContext::NESTING() {
  return getToken(DapParser::NESTING, 0);
}

DapParser::Dataset_nameContext* DapParser::Data_stmtContext::dataset_name() {
  return getRuleContext<DapParser::Dataset_nameContext>(0);
}

tree::TerminalNode* DapParser::Data_stmtContext::PGM() {
  return getToken(DapParser::PGM, 0);
}

DapParser::Program_nameContext* DapParser::Data_stmtContext::program_name() {
  return getRuleContext<DapParser::Program_nameContext>(0);
}


size_t DapParser::Data_stmtContext::getRuleIndex() const {
  return DapParser::RuleData_stmt;
}

void DapParser::Data_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterData_stmt(this);
}

void DapParser::Data_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitData_stmt(this);
}


std::any DapParser::Data_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitData_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Data_stmtContext* DapParser::data_stmt() {
  Data_stmtContext *_localctx = _tracker.createInstance<Data_stmtContext>(_ctx, getState());
  enterRule(_localctx, 74, DapParser::RuleData_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(712);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(619);
      match(DapParser::DATA);
      setState(620);
      match(DapParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(621);
      match(DapParser::DATA);
      setState(622);
      match(DapParser::Tk_NULL);
      setState(624);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::DIV) {
        setState(623);
        datastmt_cmd();
      }
      setState(627);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NOLIST) {
        setState(626);
        match(DapParser::NOLIST);
      }
      setState(629);
      match(DapParser::SEMICOLON);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(630);
      match(DapParser::DATA);
      setState(632); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(631);
        dataset_name_opt();
        setState(634); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (((((_la - 132) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 132)) & 553648129) != 0) || _la == DapParser::Identifier);
      setState(637);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::DIV) {
        setState(636);
        datastmt_cmd();
      }
      setState(640);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NOLIST) {
        setState(639);
        match(DapParser::NOLIST);
      }
      setState(642);
      match(DapParser::SEMICOLON);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(644);
      match(DapParser::DATA);
      setState(646); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(645);
        view_dsname_opt();
        setState(648); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (((((_la - 132) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 132)) & 553648129) != 0) || _la == DapParser::Identifier);
      setState(650);
      match(DapParser::DIV);
      setState(651);
      match(DapParser::VIEW);
      setState(652);
      match(DapParser::EQUAL);
      setState(653);
      view_name();
      setState(655);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
      case 1: {
        setState(654);
        passwd_opt();
        break;
      }

      default:
        break;
      }
      setState(658);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::LParentheses) {
        setState(657);
        source_opt();
      }
      setState(661);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NESTING) {
        setState(660);
        match(DapParser::NESTING);
      }
      setState(664);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NOLIST) {
        setState(663);
        match(DapParser::NOLIST);
      }
      setState(666);
      match(DapParser::SEMICOLON);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(668);
      match(DapParser::DATA);
      setState(669);
      dataset_name();
      setState(670);
      match(DapParser::DIV);
      setState(671);
      match(DapParser::PGM);
      setState(672);
      match(DapParser::EQUAL);
      setState(673);
      program_name();
      setState(675);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
      case 1: {
        setState(674);
        passwd_opt();
        break;
      }

      default:
        break;
      }
      setState(678);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::LParentheses) {
        setState(677);
        source_opt();
      }
      setState(681);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NESTING) {
        setState(680);
        match(DapParser::NESTING);
      }
      setState(684);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NOLIST) {
        setState(683);
        match(DapParser::NOLIST);
      }
      setState(686);
      match(DapParser::SEMICOLON);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(688);
      match(DapParser::DATA);
      setState(689);
      match(DapParser::VIEW);
      setState(690);
      match(DapParser::EQUAL);
      setState(691);
      view_name();
      setState(693);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::LParentheses) {
        setState(692);
        passwd_opt();
      }
      setState(696);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NOLIST) {
        setState(695);
        match(DapParser::NOLIST);
      }
      setState(698);
      match(DapParser::SEMICOLON);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(700);
      match(DapParser::DATA);
      setState(701);
      match(DapParser::PGM);
      setState(702);
      match(DapParser::EQUAL);
      setState(703);
      program_name();
      setState(705);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::LParentheses) {
        setState(704);
        passwd_opt();
      }
      setState(708);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NOLIST) {
        setState(707);
        match(DapParser::NOLIST);
      }
      setState(710);
      match(DapParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dataset_name_optContext ------------------------------------------------------------------

DapParser::Dataset_name_optContext::Dataset_name_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::Dataset_nameContext* DapParser::Dataset_name_optContext::dataset_name() {
  return getRuleContext<DapParser::Dataset_nameContext>(0);
}

std::vector<tree::TerminalNode *> DapParser::Dataset_name_optContext::LParentheses() {
  return getTokens(DapParser::LParentheses);
}

tree::TerminalNode* DapParser::Dataset_name_optContext::LParentheses(size_t i) {
  return getToken(DapParser::LParentheses, i);
}

DapParser::VariablesContext* DapParser::Dataset_name_optContext::variables() {
  return getRuleContext<DapParser::VariablesContext>(0);
}

tree::TerminalNode* DapParser::Dataset_name_optContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

std::vector<tree::TerminalNode *> DapParser::Dataset_name_optContext::RParentheses() {
  return getTokens(DapParser::RParentheses);
}

tree::TerminalNode* DapParser::Dataset_name_optContext::RParentheses(size_t i) {
  return getToken(DapParser::RParentheses, i);
}


size_t DapParser::Dataset_name_optContext::getRuleIndex() const {
  return DapParser::RuleDataset_name_opt;
}

void DapParser::Dataset_name_optContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataset_name_opt(this);
}

void DapParser::Dataset_name_optContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataset_name_opt(this);
}


std::any DapParser::Dataset_name_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDataset_name_opt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Dataset_name_optContext* DapParser::dataset_name_opt() {
  Dataset_name_optContext *_localctx = _tracker.createInstance<Dataset_name_optContext>(_ctx, getState());
  enterRule(_localctx, 76, DapParser::RuleDataset_name_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(714);
    dataset_name();
    setState(726);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::LParentheses) {
      setState(715);
      match(DapParser::LParentheses);
      setState(716);
      variables(0);
      setState(717);
      match(DapParser::EQUAL);
      setState(721);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
      while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1 + 1) {
          setState(718);
          _la = _input->LA(1);
          if (_la == 0 || _la == Token::EOF || (_la == DapParser::LParentheses

          || _la == DapParser::RParentheses)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          } 
        }
        setState(723);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
      }
      setState(724);
      match(DapParser::RParentheses);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Datastmt_cmdContext ------------------------------------------------------------------

DapParser::Datastmt_cmdContext::Datastmt_cmdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Datastmt_cmdContext::DIV() {
  return getToken(DapParser::DIV, 0);
}

tree::TerminalNode* DapParser::Datastmt_cmdContext::DEBUG() {
  return getToken(DapParser::DEBUG, 0);
}

tree::TerminalNode* DapParser::Datastmt_cmdContext::NESTING() {
  return getToken(DapParser::NESTING, 0);
}

tree::TerminalNode* DapParser::Datastmt_cmdContext::STACK() {
  return getToken(DapParser::STACK, 0);
}

tree::TerminalNode* DapParser::Datastmt_cmdContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

tree::TerminalNode* DapParser::Datastmt_cmdContext::INT() {
  return getToken(DapParser::INT, 0);
}


size_t DapParser::Datastmt_cmdContext::getRuleIndex() const {
  return DapParser::RuleDatastmt_cmd;
}

void DapParser::Datastmt_cmdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatastmt_cmd(this);
}

void DapParser::Datastmt_cmdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatastmt_cmd(this);
}


std::any DapParser::Datastmt_cmdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDatastmt_cmd(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Datastmt_cmdContext* DapParser::datastmt_cmd() {
  Datastmt_cmdContext *_localctx = _tracker.createInstance<Datastmt_cmdContext>(_ctx, getState());
  enterRule(_localctx, 78, DapParser::RuleDatastmt_cmd);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(728);
    match(DapParser::DIV);
    setState(730);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::DEBUG) {
      setState(729);
      match(DapParser::DEBUG);
    }
    setState(733);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::NESTING) {
      setState(732);
      match(DapParser::NESTING);
    }
    setState(738);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::STACK) {
      setState(735);
      match(DapParser::STACK);
      setState(736);
      match(DapParser::EQUAL);
      setState(737);
      match(DapParser::INT);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- View_dsname_optContext ------------------------------------------------------------------

DapParser::View_dsname_optContext::View_dsname_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<DapParser::VariablesContext *> DapParser::View_dsname_optContext::variables() {
  return getRuleContexts<DapParser::VariablesContext>();
}

DapParser::VariablesContext* DapParser::View_dsname_optContext::variables(size_t i) {
  return getRuleContext<DapParser::VariablesContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::View_dsname_optContext::LParentheses() {
  return getTokens(DapParser::LParentheses);
}

tree::TerminalNode* DapParser::View_dsname_optContext::LParentheses(size_t i) {
  return getToken(DapParser::LParentheses, i);
}

tree::TerminalNode* DapParser::View_dsname_optContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

std::vector<tree::TerminalNode *> DapParser::View_dsname_optContext::RParentheses() {
  return getTokens(DapParser::RParentheses);
}

tree::TerminalNode* DapParser::View_dsname_optContext::RParentheses(size_t i) {
  return getToken(DapParser::RParentheses, i);
}


size_t DapParser::View_dsname_optContext::getRuleIndex() const {
  return DapParser::RuleView_dsname_opt;
}

void DapParser::View_dsname_optContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterView_dsname_opt(this);
}

void DapParser::View_dsname_optContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitView_dsname_opt(this);
}


std::any DapParser::View_dsname_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitView_dsname_opt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::View_dsname_optContext* DapParser::view_dsname_opt() {
  View_dsname_optContext *_localctx = _tracker.createInstance<View_dsname_optContext>(_ctx, getState());
  enterRule(_localctx, 80, DapParser::RuleView_dsname_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(740);
    variables(0);
    setState(742);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      setState(741);
      variables(0);
      break;
    }

    default:
      break;
    }
    setState(755);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::LParentheses) {
      setState(744);
      match(DapParser::LParentheses);
      setState(745);
      variables(0);
      setState(746);
      match(DapParser::EQUAL);
      setState(750);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx);
      while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1 + 1) {
          setState(747);
          _la = _input->LA(1);
          if (_la == 0 || _la == Token::EOF || (_la == DapParser::LParentheses

          || _la == DapParser::RParentheses)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          } 
        }
        setState(752);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx);
      }
      setState(753);
      match(DapParser::RParentheses);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- View_nameContext ------------------------------------------------------------------

DapParser::View_nameContext::View_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::VariablesContext* DapParser::View_nameContext::variables() {
  return getRuleContext<DapParser::VariablesContext>(0);
}


size_t DapParser::View_nameContext::getRuleIndex() const {
  return DapParser::RuleView_name;
}

void DapParser::View_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterView_name(this);
}

void DapParser::View_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitView_name(this);
}


std::any DapParser::View_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitView_name(this);
  else
    return visitor->visitChildren(this);
}

DapParser::View_nameContext* DapParser::view_name() {
  View_nameContext *_localctx = _tracker.createInstance<View_nameContext>(_ctx, getState());
  enterRule(_localctx, 82, DapParser::RuleView_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(757);
    variables(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dataset_nameContext ------------------------------------------------------------------

DapParser::Dataset_nameContext::Dataset_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::VariablesContext* DapParser::Dataset_nameContext::variables() {
  return getRuleContext<DapParser::VariablesContext>(0);
}


size_t DapParser::Dataset_nameContext::getRuleIndex() const {
  return DapParser::RuleDataset_name;
}

void DapParser::Dataset_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataset_name(this);
}

void DapParser::Dataset_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataset_name(this);
}


std::any DapParser::Dataset_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDataset_name(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Dataset_nameContext* DapParser::dataset_name() {
  Dataset_nameContext *_localctx = _tracker.createInstance<Dataset_nameContext>(_ctx, getState());
  enterRule(_localctx, 84, DapParser::RuleDataset_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(759);
    variables(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Program_nameContext ------------------------------------------------------------------

DapParser::Program_nameContext::Program_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::VariablesContext* DapParser::Program_nameContext::variables() {
  return getRuleContext<DapParser::VariablesContext>(0);
}


size_t DapParser::Program_nameContext::getRuleIndex() const {
  return DapParser::RuleProgram_name;
}

void DapParser::Program_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProgram_name(this);
}

void DapParser::Program_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProgram_name(this);
}


std::any DapParser::Program_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitProgram_name(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Program_nameContext* DapParser::program_name() {
  Program_nameContext *_localctx = _tracker.createInstance<Program_nameContext>(_ctx, getState());
  enterRule(_localctx, 86, DapParser::RuleProgram_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(761);
    variables(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Passwd_optContext ------------------------------------------------------------------

DapParser::Passwd_optContext::Passwd_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::Passwd_optContext::LParentheses() {
  return getTokens(DapParser::LParentheses);
}

tree::TerminalNode* DapParser::Passwd_optContext::LParentheses(size_t i) {
  return getToken(DapParser::LParentheses, i);
}

tree::TerminalNode* DapParser::Passwd_optContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

std::vector<tree::TerminalNode *> DapParser::Passwd_optContext::RParentheses() {
  return getTokens(DapParser::RParentheses);
}

tree::TerminalNode* DapParser::Passwd_optContext::RParentheses(size_t i) {
  return getToken(DapParser::RParentheses, i);
}

tree::TerminalNode* DapParser::Passwd_optContext::ALTER() {
  return getToken(DapParser::ALTER, 0);
}

tree::TerminalNode* DapParser::Passwd_optContext::READ() {
  return getToken(DapParser::READ, 0);
}

tree::TerminalNode* DapParser::Passwd_optContext::PW() {
  return getToken(DapParser::PW, 0);
}


size_t DapParser::Passwd_optContext::getRuleIndex() const {
  return DapParser::RulePasswd_opt;
}

void DapParser::Passwd_optContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPasswd_opt(this);
}

void DapParser::Passwd_optContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPasswd_opt(this);
}


std::any DapParser::Passwd_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitPasswd_opt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Passwd_optContext* DapParser::passwd_opt() {
  Passwd_optContext *_localctx = _tracker.createInstance<Passwd_optContext>(_ctx, getState());
  enterRule(_localctx, 88, DapParser::RulePasswd_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(763);
    match(DapParser::LParentheses);
    setState(764);
    _la = _input->LA(1);
    if (!(((((_la - 118) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 118)) & 16387) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(765);
    match(DapParser::EQUAL);
    setState(769);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(766);
        _la = _input->LA(1);
        if (_la == 0 || _la == Token::EOF || (_la == DapParser::LParentheses

        || _la == DapParser::RParentheses)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(771);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx);
    }
    setState(772);
    match(DapParser::RParentheses);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Source_optContext ------------------------------------------------------------------

DapParser::Source_optContext::Source_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Source_optContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

tree::TerminalNode* DapParser::Source_optContext::SOURCE() {
  return getToken(DapParser::SOURCE, 0);
}

tree::TerminalNode* DapParser::Source_optContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

tree::TerminalNode* DapParser::Source_optContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

tree::TerminalNode* DapParser::Source_optContext::SAVE() {
  return getToken(DapParser::SAVE, 0);
}

tree::TerminalNode* DapParser::Source_optContext::ENCRYPT() {
  return getToken(DapParser::ENCRYPT, 0);
}

tree::TerminalNode* DapParser::Source_optContext::NOSAVE() {
  return getToken(DapParser::NOSAVE, 0);
}


size_t DapParser::Source_optContext::getRuleIndex() const {
  return DapParser::RuleSource_opt;
}

void DapParser::Source_optContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSource_opt(this);
}

void DapParser::Source_optContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSource_opt(this);
}


std::any DapParser::Source_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitSource_opt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Source_optContext* DapParser::source_opt() {
  Source_optContext *_localctx = _tracker.createInstance<Source_optContext>(_ctx, getState());
  enterRule(_localctx, 90, DapParser::RuleSource_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(774);
    match(DapParser::LParentheses);
    setState(775);
    match(DapParser::SOURCE);
    setState(776);
    match(DapParser::EQUAL);
    setState(777);
    _la = _input->LA(1);
    if (!(_la == DapParser::SAVE || _la == DapParser::ENCRYPT

    || _la == DapParser::NOSAVE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(778);
    match(DapParser::RParentheses);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Datalines_mainContext ------------------------------------------------------------------

DapParser::Datalines_mainContext::Datalines_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Datalines_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Datalines_stmtContext *> DapParser::Datalines_mainContext::datalines_stmt() {
  return getRuleContexts<DapParser::Datalines_stmtContext>();
}

DapParser::Datalines_stmtContext* DapParser::Datalines_mainContext::datalines_stmt(size_t i) {
  return getRuleContext<DapParser::Datalines_stmtContext>(i);
}

std::vector<DapParser::Datalines4_stmtContext *> DapParser::Datalines_mainContext::datalines4_stmt() {
  return getRuleContexts<DapParser::Datalines4_stmtContext>();
}

DapParser::Datalines4_stmtContext* DapParser::Datalines_mainContext::datalines4_stmt(size_t i) {
  return getRuleContext<DapParser::Datalines4_stmtContext>(i);
}


size_t DapParser::Datalines_mainContext::getRuleIndex() const {
  return DapParser::RuleDatalines_main;
}

void DapParser::Datalines_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatalines_main(this);
}

void DapParser::Datalines_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatalines_main(this);
}


std::any DapParser::Datalines_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDatalines_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Datalines_mainContext* DapParser::datalines_main() {
  Datalines_mainContext *_localctx = _tracker.createInstance<Datalines_mainContext>(_ctx, getState());
  enterRule(_localctx, 92, DapParser::RuleDatalines_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(784);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 125) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 125)) & 27) != 0)) {
      setState(782);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case DapParser::DATALINES:
        case DapParser::CARDS: {
          setState(780);
          datalines_stmt();
          break;
        }

        case DapParser::DATALINES4:
        case DapParser::CARDS4: {
          setState(781);
          datalines4_stmt();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(786);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(787);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Datalines_stmtContext ------------------------------------------------------------------

DapParser::Datalines_stmtContext::Datalines_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::Datalines_stmtContext::SEMICOLON() {
  return getTokens(DapParser::SEMICOLON);
}

tree::TerminalNode* DapParser::Datalines_stmtContext::SEMICOLON(size_t i) {
  return getToken(DapParser::SEMICOLON, i);
}

tree::TerminalNode* DapParser::Datalines_stmtContext::DATALINES() {
  return getToken(DapParser::DATALINES, 0);
}

tree::TerminalNode* DapParser::Datalines_stmtContext::CARDS() {
  return getToken(DapParser::CARDS, 0);
}


size_t DapParser::Datalines_stmtContext::getRuleIndex() const {
  return DapParser::RuleDatalines_stmt;
}

void DapParser::Datalines_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatalines_stmt(this);
}

void DapParser::Datalines_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatalines_stmt(this);
}


std::any DapParser::Datalines_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDatalines_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Datalines_stmtContext* DapParser::datalines_stmt() {
  Datalines_stmtContext *_localctx = _tracker.createInstance<Datalines_stmtContext>(_ctx, getState());
  enterRule(_localctx, 94, DapParser::RuleDatalines_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(789);
    _la = _input->LA(1);
    if (!(_la == DapParser::DATALINES

    || _la == DapParser::CARDS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(790);
    match(DapParser::SEMICOLON);
    setState(794);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(791);
        _la = _input->LA(1);
        if (_la == 0 || _la == Token::EOF || (_la == DapParser::SEMICOLON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(796);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
    }
    setState(797);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Datalines4_stmtContext ------------------------------------------------------------------

DapParser::Datalines4_stmtContext::Datalines4_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Datalines4_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

tree::TerminalNode* DapParser::Datalines4_stmtContext::END_DATALINES4() {
  return getToken(DapParser::END_DATALINES4, 0);
}

tree::TerminalNode* DapParser::Datalines4_stmtContext::DATALINES4() {
  return getToken(DapParser::DATALINES4, 0);
}

tree::TerminalNode* DapParser::Datalines4_stmtContext::CARDS4() {
  return getToken(DapParser::CARDS4, 0);
}


size_t DapParser::Datalines4_stmtContext::getRuleIndex() const {
  return DapParser::RuleDatalines4_stmt;
}

void DapParser::Datalines4_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatalines4_stmt(this);
}

void DapParser::Datalines4_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatalines4_stmt(this);
}


std::any DapParser::Datalines4_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDatalines4_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Datalines4_stmtContext* DapParser::datalines4_stmt() {
  Datalines4_stmtContext *_localctx = _tracker.createInstance<Datalines4_stmtContext>(_ctx, getState());
  enterRule(_localctx, 96, DapParser::RuleDatalines4_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(799);
    _la = _input->LA(1);
    if (!(_la == DapParser::DATALINES4

    || _la == DapParser::CARDS4)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(800);
    match(DapParser::SEMICOLON);
    setState(804);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(801);
        matchWildcard(); 
      }
      setState(806);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
    }
    setState(807);
    match(DapParser::END_DATALINES4);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_mainContext ------------------------------------------------------------------

DapParser::Drop_mainContext::Drop_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Drop_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Drop_stmtContext *> DapParser::Drop_mainContext::drop_stmt() {
  return getRuleContexts<DapParser::Drop_stmtContext>();
}

DapParser::Drop_stmtContext* DapParser::Drop_mainContext::drop_stmt(size_t i) {
  return getRuleContext<DapParser::Drop_stmtContext>(i);
}


size_t DapParser::Drop_mainContext::getRuleIndex() const {
  return DapParser::RuleDrop_main;
}

void DapParser::Drop_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_main(this);
}

void DapParser::Drop_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_main(this);
}


std::any DapParser::Drop_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDrop_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Drop_mainContext* DapParser::drop_main() {
  Drop_mainContext *_localctx = _tracker.createInstance<Drop_mainContext>(_ctx, getState());
  enterRule(_localctx, 98, DapParser::RuleDrop_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(812);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::DROP) {
      setState(809);
      drop_stmt();
      setState(814);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(815);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_stmtContext ------------------------------------------------------------------

DapParser::Drop_stmtContext::Drop_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Drop_stmtContext::DROP() {
  return getToken(DapParser::DROP, 0);
}

tree::TerminalNode* DapParser::Drop_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

std::vector<DapParser::VariablesContext *> DapParser::Drop_stmtContext::variables() {
  return getRuleContexts<DapParser::VariablesContext>();
}

DapParser::VariablesContext* DapParser::Drop_stmtContext::variables(size_t i) {
  return getRuleContext<DapParser::VariablesContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::Drop_stmtContext::SUB() {
  return getTokens(DapParser::SUB);
}

tree::TerminalNode* DapParser::Drop_stmtContext::SUB(size_t i) {
  return getToken(DapParser::SUB, i);
}


size_t DapParser::Drop_stmtContext::getRuleIndex() const {
  return DapParser::RuleDrop_stmt;
}

void DapParser::Drop_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_stmt(this);
}

void DapParser::Drop_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_stmt(this);
}


std::any DapParser::Drop_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDrop_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Drop_stmtContext* DapParser::drop_stmt() {
  Drop_stmtContext *_localctx = _tracker.createInstance<Drop_stmtContext>(_ctx, getState());
  enterRule(_localctx, 100, DapParser::RuleDrop_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(817);
    match(DapParser::DROP);
    setState(823); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(823);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx)) {
      case 1: {
        setState(818);
        variables(0);
        break;
      }

      case 2: {
        setState(819);
        variables(0);
        setState(820);
        match(DapParser::SUB);
        setState(821);
        variables(0);
        break;
      }

      default:
        break;
      }
      setState(825); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 132) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 132)) & 553648129) != 0) || _la == DapParser::Identifier);
    setState(827);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Infile_mainContext ------------------------------------------------------------------

DapParser::Infile_mainContext::Infile_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Infile_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Infile_stmtContext *> DapParser::Infile_mainContext::infile_stmt() {
  return getRuleContexts<DapParser::Infile_stmtContext>();
}

DapParser::Infile_stmtContext* DapParser::Infile_mainContext::infile_stmt(size_t i) {
  return getRuleContext<DapParser::Infile_stmtContext>(i);
}


size_t DapParser::Infile_mainContext::getRuleIndex() const {
  return DapParser::RuleInfile_main;
}

void DapParser::Infile_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInfile_main(this);
}

void DapParser::Infile_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInfile_main(this);
}


std::any DapParser::Infile_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInfile_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Infile_mainContext* DapParser::infile_main() {
  Infile_mainContext *_localctx = _tracker.createInstance<Infile_mainContext>(_ctx, getState());
  enterRule(_localctx, 102, DapParser::RuleInfile_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(832);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::INFILE) {
      setState(829);
      infile_stmt();
      setState(834);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(835);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Infile_stmtContext ------------------------------------------------------------------

DapParser::Infile_stmtContext::Infile_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Infile_stmtContext::INFILE() {
  return getToken(DapParser::INFILE, 0);
}

DapParser::File_specificationContext* DapParser::Infile_stmtContext::file_specification() {
  return getRuleContext<DapParser::File_specificationContext>(0);
}

tree::TerminalNode* DapParser::Infile_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

DapParser::Device_typeContext* DapParser::Infile_stmtContext::device_type() {
  return getRuleContext<DapParser::Device_typeContext>(0);
}

std::vector<DapParser::Infile_optionsContext *> DapParser::Infile_stmtContext::infile_options() {
  return getRuleContexts<DapParser::Infile_optionsContext>();
}

DapParser::Infile_optionsContext* DapParser::Infile_stmtContext::infile_options(size_t i) {
  return getRuleContext<DapParser::Infile_optionsContext>(i);
}


size_t DapParser::Infile_stmtContext::getRuleIndex() const {
  return DapParser::RuleInfile_stmt;
}

void DapParser::Infile_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInfile_stmt(this);
}

void DapParser::Infile_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInfile_stmt(this);
}


std::any DapParser::Infile_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInfile_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Infile_stmtContext* DapParser::infile_stmt() {
  Infile_stmtContext *_localctx = _tracker.createInstance<Infile_stmtContext>(_ctx, getState());
  enterRule(_localctx, 104, DapParser::RuleInfile_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(837);
    match(DapParser::INFILE);
    setState(838);
    file_specification();
    setState(840);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 133) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 133)) & 1023) != 0)) {
      setState(839);
      device_type();
    }
    setState(845);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 143) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 143)) & 144115188075859967) != 0)) {
      setState(842);
      infile_options();
      setState(847);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(848);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_specificationContext ------------------------------------------------------------------

DapParser::File_specificationContext::File_specificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::File_specificationContext::STRINGLITERAL() {
  return getToken(DapParser::STRINGLITERAL, 0);
}

tree::TerminalNode* DapParser::File_specificationContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}

tree::TerminalNode* DapParser::File_specificationContext::CARDS() {
  return getToken(DapParser::CARDS, 0);
}

tree::TerminalNode* DapParser::File_specificationContext::CARDS4() {
  return getToken(DapParser::CARDS4, 0);
}

tree::TerminalNode* DapParser::File_specificationContext::DATALINES() {
  return getToken(DapParser::DATALINES, 0);
}

tree::TerminalNode* DapParser::File_specificationContext::DATALINES4() {
  return getToken(DapParser::DATALINES4, 0);
}


size_t DapParser::File_specificationContext::getRuleIndex() const {
  return DapParser::RuleFile_specification;
}

void DapParser::File_specificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_specification(this);
}

void DapParser::File_specificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_specification(this);
}


std::any DapParser::File_specificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitFile_specification(this);
  else
    return visitor->visitChildren(this);
}

DapParser::File_specificationContext* DapParser::file_specification() {
  File_specificationContext *_localctx = _tracker.createInstance<File_specificationContext>(_ctx, getState());
  enterRule(_localctx, 106, DapParser::RuleFile_specification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(850);
    _la = _input->LA(1);
    if (!(((((_la - 125) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 125)) & 27) != 0) || _la == DapParser::STRINGLITERAL

    || _la == DapParser::Identifier)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Device_typeContext ------------------------------------------------------------------

DapParser::Device_typeContext::Device_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Device_typeContext::DISK() {
  return getToken(DapParser::DISK, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::DUMMY() {
  return getToken(DapParser::DUMMY, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::GTERM() {
  return getToken(DapParser::GTERM, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::PIPE() {
  return getToken(DapParser::PIPE, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::PLOTTER() {
  return getToken(DapParser::PLOTTER, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::PRINTER() {
  return getToken(DapParser::PRINTER, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::TAPE() {
  return getToken(DapParser::TAPE, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::TEMP() {
  return getToken(DapParser::TEMP, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::TERMINAL() {
  return getToken(DapParser::TERMINAL, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::UPRINTER() {
  return getToken(DapParser::UPRINTER, 0);
}


size_t DapParser::Device_typeContext::getRuleIndex() const {
  return DapParser::RuleDevice_type;
}

void DapParser::Device_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDevice_type(this);
}

void DapParser::Device_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDevice_type(this);
}


std::any DapParser::Device_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDevice_type(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Device_typeContext* DapParser::device_type() {
  Device_typeContext *_localctx = _tracker.createInstance<Device_typeContext>(_ctx, getState());
  enterRule(_localctx, 108, DapParser::RuleDevice_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(852);
    _la = _input->LA(1);
    if (!(((((_la - 133) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 133)) & 1023) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Infile_optionsContext ------------------------------------------------------------------

DapParser::Infile_optionsContext::Infile_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Infile_optionsContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

DapParser::ExpressionContext* DapParser::Infile_optionsContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::DSD() {
  return getToken(DapParser::DSD, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::EXPANDTABS() {
  return getToken(DapParser::EXPANDTABS, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::NOEXPANDTABS() {
  return getToken(DapParser::NOEXPANDTABS, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::FLOWOVER() {
  return getToken(DapParser::FLOWOVER, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::MISSOVER() {
  return getToken(DapParser::MISSOVER, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::PAD() {
  return getToken(DapParser::PAD, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::NOPAD() {
  return getToken(DapParser::NOPAD, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::SCANOVER() {
  return getToken(DapParser::SCANOVER, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::SHAREBUFFERS() {
  return getToken(DapParser::SHAREBUFFERS, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::STOPOVER() {
  return getToken(DapParser::STOPOVER, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::TRUNCOVER() {
  return getToken(DapParser::TRUNCOVER, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::V_INFILE_() {
  return getToken(DapParser::V_INFILE_, 0);
}


size_t DapParser::Infile_optionsContext::getRuleIndex() const {
  return DapParser::RuleInfile_options;
}

void DapParser::Infile_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInfile_options(this);
}

void DapParser::Infile_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInfile_options(this);
}


std::any DapParser::Infile_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInfile_options(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Infile_optionsContext* DapParser::infile_options() {
  Infile_optionsContext *_localctx = _tracker.createInstance<Infile_optionsContext>(_ctx, getState());
  enterRule(_localctx, 110, DapParser::RuleInfile_options);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(869);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(854);
        match(DapParser::Identifier);
        setState(855);
        match(DapParser::EQUAL);
        setState(856);
        expression(0);
        break;
      }

      case DapParser::DSD: {
        enterOuterAlt(_localctx, 2);
        setState(857);
        match(DapParser::DSD);
        break;
      }

      case DapParser::EXPANDTABS: {
        enterOuterAlt(_localctx, 3);
        setState(858);
        match(DapParser::EXPANDTABS);
        break;
      }

      case DapParser::NOEXPANDTABS: {
        enterOuterAlt(_localctx, 4);
        setState(859);
        match(DapParser::NOEXPANDTABS);
        break;
      }

      case DapParser::FLOWOVER: {
        enterOuterAlt(_localctx, 5);
        setState(860);
        match(DapParser::FLOWOVER);
        break;
      }

      case DapParser::MISSOVER: {
        enterOuterAlt(_localctx, 6);
        setState(861);
        match(DapParser::MISSOVER);
        break;
      }

      case DapParser::PAD: {
        enterOuterAlt(_localctx, 7);
        setState(862);
        match(DapParser::PAD);
        break;
      }

      case DapParser::NOPAD: {
        enterOuterAlt(_localctx, 8);
        setState(863);
        match(DapParser::NOPAD);
        break;
      }

      case DapParser::SCANOVER: {
        enterOuterAlt(_localctx, 9);
        setState(864);
        match(DapParser::SCANOVER);
        break;
      }

      case DapParser::SHAREBUFFERS: {
        enterOuterAlt(_localctx, 10);
        setState(865);
        match(DapParser::SHAREBUFFERS);
        break;
      }

      case DapParser::STOPOVER: {
        enterOuterAlt(_localctx, 11);
        setState(866);
        match(DapParser::STOPOVER);
        break;
      }

      case DapParser::TRUNCOVER: {
        enterOuterAlt(_localctx, 12);
        setState(867);
        match(DapParser::TRUNCOVER);
        break;
      }

      case DapParser::V_INFILE_: {
        enterOuterAlt(_localctx, 13);
        setState(868);
        match(DapParser::V_INFILE_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_mainContext ------------------------------------------------------------------

DapParser::Input_mainContext::Input_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Input_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Input_stmtContext *> DapParser::Input_mainContext::input_stmt() {
  return getRuleContexts<DapParser::Input_stmtContext>();
}

DapParser::Input_stmtContext* DapParser::Input_mainContext::input_stmt(size_t i) {
  return getRuleContext<DapParser::Input_stmtContext>(i);
}

std::vector<DapParser::Put_stmtContext *> DapParser::Input_mainContext::put_stmt() {
  return getRuleContexts<DapParser::Put_stmtContext>();
}

DapParser::Put_stmtContext* DapParser::Input_mainContext::put_stmt(size_t i) {
  return getRuleContext<DapParser::Put_stmtContext>(i);
}


size_t DapParser::Input_mainContext::getRuleIndex() const {
  return DapParser::RuleInput_main;
}

void DapParser::Input_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInput_main(this);
}

void DapParser::Input_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInput_main(this);
}


std::any DapParser::Input_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInput_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Input_mainContext* DapParser::input_main() {
  Input_mainContext *_localctx = _tracker.createInstance<Input_mainContext>(_ctx, getState());
  enterRule(_localctx, 112, DapParser::RuleInput_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(875);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::INPUT

    || _la == DapParser::PUT) {
      setState(873);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case DapParser::INPUT: {
          setState(871);
          input_stmt();
          break;
        }

        case DapParser::PUT: {
          setState(872);
          put_stmt();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(877);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(878);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_stmtContext ------------------------------------------------------------------

DapParser::Input_stmtContext::Input_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Input_stmtContext::INPUT() {
  return getToken(DapParser::INPUT, 0);
}

tree::TerminalNode* DapParser::Input_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

std::vector<DapParser::Input_specificationContext *> DapParser::Input_stmtContext::input_specification() {
  return getRuleContexts<DapParser::Input_specificationContext>();
}

DapParser::Input_specificationContext* DapParser::Input_stmtContext::input_specification(size_t i) {
  return getRuleContext<DapParser::Input_specificationContext>(i);
}

tree::TerminalNode* DapParser::Input_stmtContext::INPUT_ODS() {
  return getToken(DapParser::INPUT_ODS, 0);
}

std::vector<tree::TerminalNode *> DapParser::Input_stmtContext::AT() {
  return getTokens(DapParser::AT);
}

tree::TerminalNode* DapParser::Input_stmtContext::AT(size_t i) {
  return getToken(DapParser::AT, i);
}


size_t DapParser::Input_stmtContext::getRuleIndex() const {
  return DapParser::RuleInput_stmt;
}

void DapParser::Input_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInput_stmt(this);
}

void DapParser::Input_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInput_stmt(this);
}


std::any DapParser::Input_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInput_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Input_stmtContext* DapParser::input_stmt() {
  Input_stmtContext *_localctx = _tracker.createInstance<Input_stmtContext>(_ctx, getState());
  enterRule(_localctx, 114, DapParser::RuleInput_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(880);
    match(DapParser::INPUT);
    setState(884);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(881);
        input_specification(); 
      }
      setState(886);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx);
    }
    setState(888);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::INPUT_ODS) {
      setState(887);
      match(DapParser::INPUT_ODS);
    }
    setState(893);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      setState(890);
      match(DapParser::AT);
      break;
    }

    case 2: {
      setState(891);
      match(DapParser::AT);
      setState(892);
      match(DapParser::AT);
      break;
    }

    default:
      break;
    }
    setState(895);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Put_stmtContext ------------------------------------------------------------------

DapParser::Put_stmtContext::Put_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Put_stmtContext::PUT() {
  return getToken(DapParser::PUT, 0);
}

tree::TerminalNode* DapParser::Put_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

std::vector<DapParser::Put_specificationContext *> DapParser::Put_stmtContext::put_specification() {
  return getRuleContexts<DapParser::Put_specificationContext>();
}

DapParser::Put_specificationContext* DapParser::Put_stmtContext::put_specification(size_t i) {
  return getRuleContext<DapParser::Put_specificationContext>(i);
}

tree::TerminalNode* DapParser::Put_stmtContext::INPUT_ODS() {
  return getToken(DapParser::INPUT_ODS, 0);
}

std::vector<tree::TerminalNode *> DapParser::Put_stmtContext::AT() {
  return getTokens(DapParser::AT);
}

tree::TerminalNode* DapParser::Put_stmtContext::AT(size_t i) {
  return getToken(DapParser::AT, i);
}


size_t DapParser::Put_stmtContext::getRuleIndex() const {
  return DapParser::RulePut_stmt;
}

void DapParser::Put_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPut_stmt(this);
}

void DapParser::Put_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPut_stmt(this);
}


std::any DapParser::Put_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitPut_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Put_stmtContext* DapParser::put_stmt() {
  Put_stmtContext *_localctx = _tracker.createInstance<Put_stmtContext>(_ctx, getState());
  enterRule(_localctx, 116, DapParser::RulePut_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(897);
    match(DapParser::PUT);
    setState(901);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(898);
        put_specification(); 
      }
      setState(903);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx);
    }
    setState(905);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::INPUT_ODS) {
      setState(904);
      match(DapParser::INPUT_ODS);
    }
    setState(910);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
    case 1: {
      setState(907);
      match(DapParser::AT);
      break;
    }

    case 2: {
      setState(908);
      match(DapParser::AT);
      setState(909);
      match(DapParser::AT);
      break;
    }

    default:
      break;
    }
    setState(912);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_specificationContext ------------------------------------------------------------------

DapParser::Input_specificationContext::Input_specificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::Pointer_controlContext* DapParser::Input_specificationContext::pointer_control() {
  return getRuleContext<DapParser::Pointer_controlContext>(0);
}

DapParser::Input_variable_formatContext* DapParser::Input_specificationContext::input_variable_format() {
  return getRuleContext<DapParser::Input_variable_formatContext>(0);
}

DapParser::Column_specificationsContext* DapParser::Input_specificationContext::column_specifications() {
  return getRuleContext<DapParser::Column_specificationsContext>(0);
}

std::vector<tree::TerminalNode *> DapParser::Input_specificationContext::LParentheses() {
  return getTokens(DapParser::LParentheses);
}

tree::TerminalNode* DapParser::Input_specificationContext::LParentheses(size_t i) {
  return getToken(DapParser::LParentheses, i);
}

DapParser::Identifiers_listContext* DapParser::Input_specificationContext::identifiers_list() {
  return getRuleContext<DapParser::Identifiers_listContext>(0);
}

std::vector<tree::TerminalNode *> DapParser::Input_specificationContext::RParentheses() {
  return getTokens(DapParser::RParentheses);
}

tree::TerminalNode* DapParser::Input_specificationContext::RParentheses(size_t i) {
  return getToken(DapParser::RParentheses, i);
}

DapParser::Informat_listContext* DapParser::Input_specificationContext::informat_list() {
  return getRuleContext<DapParser::Informat_listContext>(0);
}


size_t DapParser::Input_specificationContext::getRuleIndex() const {
  return DapParser::RuleInput_specification;
}

void DapParser::Input_specificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInput_specification(this);
}

void DapParser::Input_specificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInput_specification(this);
}


std::any DapParser::Input_specificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInput_specification(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Input_specificationContext* DapParser::input_specification() {
  Input_specificationContext *_localctx = _tracker.createInstance<Input_specificationContext>(_ctx, getState());
  enterRule(_localctx, 118, DapParser::RuleInput_specification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(924);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::T__4:
      case DapParser::AT:
      case DapParser::ADD:
      case DapParser::DIV: {
        enterOuterAlt(_localctx, 1);
        setState(914);
        pointer_control();
        break;
      }

      case DapParser::ALTER:
      case DapParser::DATE:
      case DapParser::DROP:
      case DapParser::Identifier: {
        enterOuterAlt(_localctx, 2);
        setState(915);
        input_variable_format();
        break;
      }

      case DapParser::INT: {
        enterOuterAlt(_localctx, 3);
        setState(916);
        column_specifications();
        break;
      }

      case DapParser::LParentheses: {
        enterOuterAlt(_localctx, 4);
        setState(917);
        match(DapParser::LParentheses);
        setState(918);
        identifiers_list();
        setState(919);
        match(DapParser::RParentheses);
        setState(920);
        match(DapParser::LParentheses);
        setState(921);
        informat_list();
        setState(922);
        match(DapParser::RParentheses);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Put_specificationContext ------------------------------------------------------------------

DapParser::Put_specificationContext::Put_specificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::Pointer_controlContext* DapParser::Put_specificationContext::pointer_control() {
  return getRuleContext<DapParser::Pointer_controlContext>(0);
}

DapParser::Put_variable_formatContext* DapParser::Put_specificationContext::put_variable_format() {
  return getRuleContext<DapParser::Put_variable_formatContext>(0);
}

DapParser::Column_specificationsContext* DapParser::Put_specificationContext::column_specifications() {
  return getRuleContext<DapParser::Column_specificationsContext>(0);
}

std::vector<tree::TerminalNode *> DapParser::Put_specificationContext::LParentheses() {
  return getTokens(DapParser::LParentheses);
}

tree::TerminalNode* DapParser::Put_specificationContext::LParentheses(size_t i) {
  return getToken(DapParser::LParentheses, i);
}

DapParser::Identifiers_listContext* DapParser::Put_specificationContext::identifiers_list() {
  return getRuleContext<DapParser::Identifiers_listContext>(0);
}

std::vector<tree::TerminalNode *> DapParser::Put_specificationContext::RParentheses() {
  return getTokens(DapParser::RParentheses);
}

tree::TerminalNode* DapParser::Put_specificationContext::RParentheses(size_t i) {
  return getToken(DapParser::RParentheses, i);
}

DapParser::Informat_listContext* DapParser::Put_specificationContext::informat_list() {
  return getRuleContext<DapParser::Informat_listContext>(0);
}


size_t DapParser::Put_specificationContext::getRuleIndex() const {
  return DapParser::RulePut_specification;
}

void DapParser::Put_specificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPut_specification(this);
}

void DapParser::Put_specificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPut_specification(this);
}


std::any DapParser::Put_specificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitPut_specification(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Put_specificationContext* DapParser::put_specification() {
  Put_specificationContext *_localctx = _tracker.createInstance<Put_specificationContext>(_ctx, getState());
  enterRule(_localctx, 120, DapParser::RulePut_specification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(936);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(926);
      pointer_control();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(927);
      put_variable_format();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(928);
      column_specifications();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(929);
      match(DapParser::LParentheses);
      setState(930);
      identifiers_list();
      setState(931);
      match(DapParser::RParentheses);
      setState(932);
      match(DapParser::LParentheses);
      setState(933);
      informat_list();
      setState(934);
      match(DapParser::RParentheses);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pointer_controlContext ------------------------------------------------------------------

DapParser::Pointer_controlContext::Pointer_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::Line_point_controlContext* DapParser::Pointer_controlContext::line_point_control() {
  return getRuleContext<DapParser::Line_point_controlContext>(0);
}

DapParser::Column_point_controlContext* DapParser::Pointer_controlContext::column_point_control() {
  return getRuleContext<DapParser::Column_point_controlContext>(0);
}


size_t DapParser::Pointer_controlContext::getRuleIndex() const {
  return DapParser::RulePointer_control;
}

void DapParser::Pointer_controlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPointer_control(this);
}

void DapParser::Pointer_controlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPointer_control(this);
}


std::any DapParser::Pointer_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitPointer_control(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Pointer_controlContext* DapParser::pointer_control() {
  Pointer_controlContext *_localctx = _tracker.createInstance<Pointer_controlContext>(_ctx, getState());
  enterRule(_localctx, 122, DapParser::RulePointer_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(940);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::T__4:
      case DapParser::DIV: {
        enterOuterAlt(_localctx, 1);
        setState(938);
        line_point_control();
        break;
      }

      case DapParser::AT:
      case DapParser::ADD: {
        enterOuterAlt(_localctx, 2);
        setState(939);
        column_point_control();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Informat_listContext ------------------------------------------------------------------

DapParser::Informat_listContext::Informat_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::Informat_listContext::Informat() {
  return getTokens(DapParser::Informat);
}

tree::TerminalNode* DapParser::Informat_listContext::Informat(size_t i) {
  return getToken(DapParser::Informat, i);
}

std::vector<tree::TerminalNode *> DapParser::Informat_listContext::COMMA() {
  return getTokens(DapParser::COMMA);
}

tree::TerminalNode* DapParser::Informat_listContext::COMMA(size_t i) {
  return getToken(DapParser::COMMA, i);
}

std::vector<DapParser::Pointer_controlContext *> DapParser::Informat_listContext::pointer_control() {
  return getRuleContexts<DapParser::Pointer_controlContext>();
}

DapParser::Pointer_controlContext* DapParser::Informat_listContext::pointer_control(size_t i) {
  return getRuleContext<DapParser::Pointer_controlContext>(i);
}


size_t DapParser::Informat_listContext::getRuleIndex() const {
  return DapParser::RuleInformat_list;
}

void DapParser::Informat_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInformat_list(this);
}

void DapParser::Informat_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInformat_list(this);
}


std::any DapParser::Informat_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInformat_list(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Informat_listContext* DapParser::informat_list() {
  Informat_listContext *_localctx = _tracker.createInstance<Informat_listContext>(_ctx, getState());
  enterRule(_localctx, 124, DapParser::RuleInformat_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(949); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(942);
      match(DapParser::Informat);
      setState(944);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::COMMA) {
        setState(943);
        match(DapParser::COMMA);
      }
      setState(947);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::T__4 || ((((_la - 202) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 202)) & 73729) != 0)) {
        setState(946);
        pointer_control();
      }
      setState(951); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == DapParser::Informat);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_variable_formatContext ------------------------------------------------------------------

DapParser::Input_variable_formatContext::Input_variable_formatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::Input_variableContext* DapParser::Input_variable_formatContext::input_variable() {
  return getRuleContext<DapParser::Input_variableContext>(0);
}

tree::TerminalNode* DapParser::Input_variable_formatContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

DapParser::Format_modifierContext* DapParser::Input_variable_formatContext::format_modifier() {
  return getRuleContext<DapParser::Format_modifierContext>(0);
}

tree::TerminalNode* DapParser::Input_variable_formatContext::Informat() {
  return getToken(DapParser::Informat, 0);
}

tree::TerminalNode* DapParser::Input_variable_formatContext::DOLLAR() {
  return getToken(DapParser::DOLLAR, 0);
}


size_t DapParser::Input_variable_formatContext::getRuleIndex() const {
  return DapParser::RuleInput_variable_format;
}

void DapParser::Input_variable_formatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInput_variable_format(this);
}

void DapParser::Input_variable_formatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInput_variable_format(this);
}


std::any DapParser::Input_variable_formatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInput_variable_format(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Input_variable_formatContext* DapParser::input_variable_format() {
  Input_variable_formatContext *_localctx = _tracker.createInstance<Input_variable_formatContext>(_ctx, getState());
  enterRule(_localctx, 126, DapParser::RuleInput_variable_format);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(973);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(953);
      input_variable();
      setState(955);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::EQUAL) {
        setState(954);
        match(DapParser::EQUAL);
      }
      setState(958);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 960) != 0) || _la == DapParser::COLON) {
        setState(957);
        format_modifier();
      }
      setState(961);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::Informat) {
        setState(960);
        match(DapParser::Informat);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(963);
      input_variable();
      setState(965);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::EQUAL) {
        setState(964);
        match(DapParser::EQUAL);
      }
      setState(968);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 960) != 0) || _la == DapParser::COLON) {
        setState(967);
        format_modifier();
      }
      setState(971);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::DOLLAR) {
        setState(970);
        match(DapParser::DOLLAR);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_variableContext ------------------------------------------------------------------

DapParser::Input_variableContext::Input_variableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<DapParser::VariablesContext *> DapParser::Input_variableContext::variables() {
  return getRuleContexts<DapParser::VariablesContext>();
}

DapParser::VariablesContext* DapParser::Input_variableContext::variables(size_t i) {
  return getRuleContext<DapParser::VariablesContext>(i);
}

tree::TerminalNode* DapParser::Input_variableContext::SUB() {
  return getToken(DapParser::SUB, 0);
}

tree::TerminalNode* DapParser::Input_variableContext::LBraces() {
  return getToken(DapParser::LBraces, 0);
}

tree::TerminalNode* DapParser::Input_variableContext::MUL() {
  return getToken(DapParser::MUL, 0);
}

tree::TerminalNode* DapParser::Input_variableContext::RBraces() {
  return getToken(DapParser::RBraces, 0);
}


size_t DapParser::Input_variableContext::getRuleIndex() const {
  return DapParser::RuleInput_variable;
}

void DapParser::Input_variableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInput_variable(this);
}

void DapParser::Input_variableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInput_variable(this);
}


std::any DapParser::Input_variableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInput_variable(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Input_variableContext* DapParser::input_variable() {
  Input_variableContext *_localctx = _tracker.createInstance<Input_variableContext>(_ctx, getState());
  enterRule(_localctx, 128, DapParser::RuleInput_variable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(985);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(975);
      variables(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(976);
      variables(0);
      setState(977);
      match(DapParser::SUB);
      setState(978);
      variables(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(980);
      variables(0);
      setState(981);
      match(DapParser::LBraces);
      setState(982);
      match(DapParser::MUL);
      setState(983);
      match(DapParser::RBraces);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Put_variable_formatContext ------------------------------------------------------------------

DapParser::Put_variable_formatContext::Put_variable_formatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::Put_variableContext* DapParser::Put_variable_formatContext::put_variable() {
  return getRuleContext<DapParser::Put_variableContext>(0);
}

tree::TerminalNode* DapParser::Put_variable_formatContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

DapParser::Format_modifierContext* DapParser::Put_variable_formatContext::format_modifier() {
  return getRuleContext<DapParser::Format_modifierContext>(0);
}

tree::TerminalNode* DapParser::Put_variable_formatContext::Informat() {
  return getToken(DapParser::Informat, 0);
}

tree::TerminalNode* DapParser::Put_variable_formatContext::DOLLAR() {
  return getToken(DapParser::DOLLAR, 0);
}


size_t DapParser::Put_variable_formatContext::getRuleIndex() const {
  return DapParser::RulePut_variable_format;
}

void DapParser::Put_variable_formatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPut_variable_format(this);
}

void DapParser::Put_variable_formatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPut_variable_format(this);
}


std::any DapParser::Put_variable_formatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitPut_variable_format(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Put_variable_formatContext* DapParser::put_variable_format() {
  Put_variable_formatContext *_localctx = _tracker.createInstance<Put_variable_formatContext>(_ctx, getState());
  enterRule(_localctx, 130, DapParser::RulePut_variable_format);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1007);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 125, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(987);
      put_variable();
      setState(989);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::EQUAL) {
        setState(988);
        match(DapParser::EQUAL);
      }
      setState(992);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 960) != 0) || _la == DapParser::COLON) {
        setState(991);
        format_modifier();
      }
      setState(995);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::Informat) {
        setState(994);
        match(DapParser::Informat);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(997);
      put_variable();
      setState(999);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::EQUAL) {
        setState(998);
        match(DapParser::EQUAL);
      }
      setState(1002);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 960) != 0) || _la == DapParser::COLON) {
        setState(1001);
        format_modifier();
      }
      setState(1005);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::DOLLAR) {
        setState(1004);
        match(DapParser::DOLLAR);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Put_variableContext ------------------------------------------------------------------

DapParser::Put_variableContext::Put_variableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Put_variableContext::V_INFILE_() {
  return getToken(DapParser::V_INFILE_, 0);
}

tree::TerminalNode* DapParser::Put_variableContext::ARRAY_ALL_ELEMENTS() {
  return getToken(DapParser::ARRAY_ALL_ELEMENTS, 0);
}

DapParser::Input_variableContext* DapParser::Put_variableContext::input_variable() {
  return getRuleContext<DapParser::Input_variableContext>(0);
}

tree::TerminalNode* DapParser::Put_variableContext::STRINGLITERAL() {
  return getToken(DapParser::STRINGLITERAL, 0);
}

tree::TerminalNode* DapParser::Put_variableContext::INT() {
  return getToken(DapParser::INT, 0);
}

tree::TerminalNode* DapParser::Put_variableContext::MUL() {
  return getToken(DapParser::MUL, 0);
}

DapParser::LiteralContext* DapParser::Put_variableContext::literal() {
  return getRuleContext<DapParser::LiteralContext>(0);
}


size_t DapParser::Put_variableContext::getRuleIndex() const {
  return DapParser::RulePut_variable;
}

void DapParser::Put_variableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPut_variable(this);
}

void DapParser::Put_variableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPut_variable(this);
}


std::any DapParser::Put_variableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitPut_variable(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Put_variableContext* DapParser::put_variable() {
  Put_variableContext *_localctx = _tracker.createInstance<Put_variableContext>(_ctx, getState());
  enterRule(_localctx, 132, DapParser::RulePut_variable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1018);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1009);
      match(DapParser::V_INFILE_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1010);
      match(DapParser::ARRAY_ALL_ELEMENTS);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1011);
      input_variable();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1014);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::INT) {
        setState(1012);
        match(DapParser::INT);
        setState(1013);
        match(DapParser::MUL);
      }
      setState(1016);
      match(DapParser::STRINGLITERAL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1017);
      literal();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_point_controlContext ------------------------------------------------------------------

DapParser::Column_point_controlContext::Column_point_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Column_point_controlContext::AT() {
  return getToken(DapParser::AT, 0);
}

tree::TerminalNode* DapParser::Column_point_controlContext::INT() {
  return getToken(DapParser::INT, 0);
}

tree::TerminalNode* DapParser::Column_point_controlContext::FloatingPointLiteral() {
  return getToken(DapParser::FloatingPointLiteral, 0);
}

tree::TerminalNode* DapParser::Column_point_controlContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}

tree::TerminalNode* DapParser::Column_point_controlContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

DapParser::ExpressionContext* DapParser::Column_point_controlContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::Column_point_controlContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

tree::TerminalNode* DapParser::Column_point_controlContext::ADD() {
  return getToken(DapParser::ADD, 0);
}


size_t DapParser::Column_point_controlContext::getRuleIndex() const {
  return DapParser::RuleColumn_point_control;
}

void DapParser::Column_point_controlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_point_control(this);
}

void DapParser::Column_point_controlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_point_control(this);
}


std::any DapParser::Column_point_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitColumn_point_control(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Column_point_controlContext* DapParser::column_point_control() {
  Column_point_controlContext *_localctx = _tracker.createInstance<Column_point_controlContext>(_ctx, getState());
  enterRule(_localctx, 134, DapParser::RuleColumn_point_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1042);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1020);
      match(DapParser::AT);
      setState(1021);
      match(DapParser::INT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1022);
      match(DapParser::AT);
      setState(1023);
      match(DapParser::FloatingPointLiteral);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1024);
      match(DapParser::AT);
      setState(1025);
      match(DapParser::Identifier);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1026);
      match(DapParser::AT);
      setState(1027);
      match(DapParser::LParentheses);
      setState(1028);
      expression(0);
      setState(1029);
      match(DapParser::RParentheses);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1031);
      match(DapParser::ADD);
      setState(1032);
      match(DapParser::INT);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1033);
      match(DapParser::ADD);
      setState(1034);
      match(DapParser::Identifier);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1035);
      match(DapParser::ADD);
      setState(1036);
      match(DapParser::FloatingPointLiteral);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1037);
      match(DapParser::ADD);
      setState(1038);
      match(DapParser::LParentheses);
      setState(1039);
      expression(0);
      setState(1040);
      match(DapParser::RParentheses);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Line_point_controlContext ------------------------------------------------------------------

DapParser::Line_point_controlContext::Line_point_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Line_point_controlContext::INT() {
  return getToken(DapParser::INT, 0);
}

tree::TerminalNode* DapParser::Line_point_controlContext::FloatingPointLiteral() {
  return getToken(DapParser::FloatingPointLiteral, 0);
}

tree::TerminalNode* DapParser::Line_point_controlContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

DapParser::ExpressionContext* DapParser::Line_point_controlContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::Line_point_controlContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

tree::TerminalNode* DapParser::Line_point_controlContext::DIV() {
  return getToken(DapParser::DIV, 0);
}


size_t DapParser::Line_point_controlContext::getRuleIndex() const {
  return DapParser::RuleLine_point_control;
}

void DapParser::Line_point_controlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLine_point_control(this);
}

void DapParser::Line_point_controlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLine_point_control(this);
}


std::any DapParser::Line_point_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitLine_point_control(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Line_point_controlContext* DapParser::line_point_control() {
  Line_point_controlContext *_localctx = _tracker.createInstance<Line_point_controlContext>(_ctx, getState());
  enterRule(_localctx, 136, DapParser::RuleLine_point_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1054);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1044);
      match(DapParser::T__4);
      setState(1045);
      match(DapParser::INT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1046);
      match(DapParser::T__4);
      setState(1047);
      match(DapParser::FloatingPointLiteral);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1048);
      match(DapParser::T__4);
      setState(1049);
      match(DapParser::LParentheses);
      setState(1050);
      expression(0);
      setState(1051);
      match(DapParser::RParentheses);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1053);
      match(DapParser::DIV);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Format_modifierContext ------------------------------------------------------------------

DapParser::Format_modifierContext::Format_modifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Format_modifierContext::COLON() {
  return getToken(DapParser::COLON, 0);
}


size_t DapParser::Format_modifierContext::getRuleIndex() const {
  return DapParser::RuleFormat_modifier;
}

void DapParser::Format_modifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormat_modifier(this);
}

void DapParser::Format_modifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormat_modifier(this);
}


std::any DapParser::Format_modifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitFormat_modifier(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Format_modifierContext* DapParser::format_modifier() {
  Format_modifierContext *_localctx = _tracker.createInstance<Format_modifierContext>(_ctx, getState());
  enterRule(_localctx, 138, DapParser::RuleFormat_modifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1056);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 960) != 0) || _la == DapParser::COLON)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_specificationsContext ------------------------------------------------------------------

DapParser::Column_specificationsContext::Column_specificationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::Column_specificationsContext::INT() {
  return getTokens(DapParser::INT);
}

tree::TerminalNode* DapParser::Column_specificationsContext::INT(size_t i) {
  return getToken(DapParser::INT, i);
}

tree::TerminalNode* DapParser::Column_specificationsContext::SUB() {
  return getToken(DapParser::SUB, 0);
}


size_t DapParser::Column_specificationsContext::getRuleIndex() const {
  return DapParser::RuleColumn_specifications;
}

void DapParser::Column_specificationsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_specifications(this);
}

void DapParser::Column_specificationsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_specifications(this);
}


std::any DapParser::Column_specificationsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitColumn_specifications(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Column_specificationsContext* DapParser::column_specifications() {
  Column_specificationsContext *_localctx = _tracker.createInstance<Column_specificationsContext>(_ctx, getState());
  enterRule(_localctx, 140, DapParser::RuleColumn_specifications);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1058);
    match(DapParser::INT);
    setState(1059);
    match(DapParser::SUB);
    setState(1060);
    match(DapParser::INT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Means_mainContext ------------------------------------------------------------------

DapParser::Means_mainContext::Means_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Means_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Means_procContext *> DapParser::Means_mainContext::means_proc() {
  return getRuleContexts<DapParser::Means_procContext>();
}

DapParser::Means_procContext* DapParser::Means_mainContext::means_proc(size_t i) {
  return getRuleContext<DapParser::Means_procContext>(i);
}


size_t DapParser::Means_mainContext::getRuleIndex() const {
  return DapParser::RuleMeans_main;
}

void DapParser::Means_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeans_main(this);
}

void DapParser::Means_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeans_main(this);
}


std::any DapParser::Means_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitMeans_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Means_mainContext* DapParser::means_main() {
  Means_mainContext *_localctx = _tracker.createInstance<Means_mainContext>(_ctx, getState());
  enterRule(_localctx, 142, DapParser::RuleMeans_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1065);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::DROP) {
      setState(1062);
      means_proc();
      setState(1067);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1068);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Means_procContext ------------------------------------------------------------------

DapParser::Means_procContext::Means_procContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Means_procContext::DROP() {
  return getToken(DapParser::DROP, 0);
}

tree::TerminalNode* DapParser::Means_procContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

std::vector<DapParser::VariablesContext *> DapParser::Means_procContext::variables() {
  return getRuleContexts<DapParser::VariablesContext>();
}

DapParser::VariablesContext* DapParser::Means_procContext::variables(size_t i) {
  return getRuleContext<DapParser::VariablesContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::Means_procContext::SUB() {
  return getTokens(DapParser::SUB);
}

tree::TerminalNode* DapParser::Means_procContext::SUB(size_t i) {
  return getToken(DapParser::SUB, i);
}


size_t DapParser::Means_procContext::getRuleIndex() const {
  return DapParser::RuleMeans_proc;
}

void DapParser::Means_procContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeans_proc(this);
}

void DapParser::Means_procContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeans_proc(this);
}


std::any DapParser::Means_procContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitMeans_proc(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Means_procContext* DapParser::means_proc() {
  Means_procContext *_localctx = _tracker.createInstance<Means_procContext>(_ctx, getState());
  enterRule(_localctx, 144, DapParser::RuleMeans_proc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1070);
    match(DapParser::DROP);
    setState(1076); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1076);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx)) {
      case 1: {
        setState(1071);
        variables(0);
        break;
      }

      case 2: {
        setState(1072);
        variables(0);
        setState(1073);
        match(DapParser::SUB);
        setState(1074);
        variables(0);
        break;
      }

      default:
        break;
      }
      setState(1078); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 132) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 132)) & 553648129) != 0) || _la == DapParser::Identifier);
    setState(1080);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Run_mainContext ------------------------------------------------------------------

DapParser::Run_mainContext::Run_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Run_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Run_stmtContext *> DapParser::Run_mainContext::run_stmt() {
  return getRuleContexts<DapParser::Run_stmtContext>();
}

DapParser::Run_stmtContext* DapParser::Run_mainContext::run_stmt(size_t i) {
  return getRuleContext<DapParser::Run_stmtContext>(i);
}


size_t DapParser::Run_mainContext::getRuleIndex() const {
  return DapParser::RuleRun_main;
}

void DapParser::Run_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRun_main(this);
}

void DapParser::Run_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRun_main(this);
}


std::any DapParser::Run_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitRun_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Run_mainContext* DapParser::run_main() {
  Run_mainContext *_localctx = _tracker.createInstance<Run_mainContext>(_ctx, getState());
  enterRule(_localctx, 146, DapParser::RuleRun_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1085);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::RUN) {
      setState(1082);
      run_stmt();
      setState(1087);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1088);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Run_stmtContext ------------------------------------------------------------------

DapParser::Run_stmtContext::Run_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Run_stmtContext::RUN() {
  return getToken(DapParser::RUN, 0);
}

tree::TerminalNode* DapParser::Run_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

tree::TerminalNode* DapParser::Run_stmtContext::CANCEL() {
  return getToken(DapParser::CANCEL, 0);
}


size_t DapParser::Run_stmtContext::getRuleIndex() const {
  return DapParser::RuleRun_stmt;
}

void DapParser::Run_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRun_stmt(this);
}

void DapParser::Run_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRun_stmt(this);
}


std::any DapParser::Run_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitRun_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Run_stmtContext* DapParser::run_stmt() {
  Run_stmtContext *_localctx = _tracker.createInstance<Run_stmtContext>(_ctx, getState());
  enterRule(_localctx, 148, DapParser::RuleRun_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1090);
    match(DapParser::RUN);
    setState(1092);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::CANCEL) {
      setState(1091);
      match(DapParser::CANCEL);
    }
    setState(1094);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool DapParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 6: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);
    case 7: return expressionListSempred(antlrcpp::downCast<ExpressionListContext *>(context), predicateIndex);
    case 13: return variablesSempred(antlrcpp::downCast<VariablesContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool DapParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 13);
    case 1: return precpred(_ctx, 10);
    case 2: return precpred(_ctx, 9);
    case 3: return precpred(_ctx, 8);
    case 4: return precpred(_ctx, 7);
    case 5: return precpred(_ctx, 6);
    case 6: return precpred(_ctx, 5);
    case 7: return precpred(_ctx, 4);
    case 8: return precpred(_ctx, 2);
    case 9: return precpred(_ctx, 1);
    case 10: return precpred(_ctx, 16);
    case 11: return precpred(_ctx, 15);
    case 12: return precpred(_ctx, 14);
    case 13: return precpred(_ctx, 3);

  default:
    break;
  }
  return true;
}

bool DapParser::expressionListSempred(ExpressionListContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 14: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool DapParser::variablesSempred(VariablesContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 15: return precpred(_ctx, 5);

  default:
    break;
  }
  return true;
}

void DapParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  dapParserInitialize();
#else
  ::antlr4::internal::call_once(dapParserOnceFlag, dapParserInitialize);
#endif
}
