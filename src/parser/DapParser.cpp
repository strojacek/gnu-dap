
// Generated from Dap.g4 by ANTLR 4.12.0


#include "DapListener.h"
#include "DapVisitor.h"

#include "DapParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct DapParserStaticData final {
  DapParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  DapParserStaticData(const DapParserStaticData&) = delete;
  DapParserStaticData(DapParserStaticData&&) = delete;
  DapParserStaticData& operator=(const DapParserStaticData&) = delete;
  DapParserStaticData& operator=(DapParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag dapParserOnceFlag;
DapParserStaticData *dapParserStaticData = nullptr;

void dapParserInitialize() {
  assert(dapParserStaticData == nullptr);
  auto staticData = std::make_unique<DapParserStaticData>(
    std::vector<std::string>{
      "parse", "sas_stmt_list", "if_stmt", "if_then_else_stmt", "delete_stmt", 
      "expression", "expressionList", "of_var_list", "identifiers_list", 
      "in_var_list", "colonInts", "literal", "variables", "abort_main", 
      "abort_stmt", "file_spec", "proc_main", "proc_stmt", "proc_name", 
      "array_main", "array_stmt", "array_name", "array_subscript", "array_elements", 
      "initial_value_list", "initial_value_list_item", "initial_value_list_bk", 
      "constant_iter_value", "constant_value", "assign_main", "assign_stmt", 
      "by_main", "by_stmt", "call_main", "call_stmt", "data_main", "data_stmt", 
      "dataset_name_opt", "datastmt_cmd", "view_dsname_opt", "view_name", 
      "dataset_name", "program_name", "passwd_opt", "source_opt", "datalines_main", 
      "datalines_stmt", "datalines4_stmt", "drop_main", "drop_stmt", "infile_main", 
      "infile_stmt", "file_specification", "device_type", "infile_options", 
      "input_main", "input_stmt", "put_stmt", "input_specification", "put_specification", 
      "pointer_control", "informat_list", "input_variable_format", "input_variable", 
      "put_variable_format", "put_variable", "column_point_control", "line_point_control", 
      "format_modifier", "column_specifications", "means_main", "means_proc", 
      "run_main", "run_stmt"
    },
    std::vector<std::string>{
      "", "'**'", "'||'", "'!!'", "'of'", "'#'", "'\\u003F'", "'\\u003F\\u003F'", 
      "'&'", "'~'", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "';;;;'", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'$'", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'><'", 
      "'<>'", "", "", "", "", "", "", "", "", "", "", "", "'@'", "'='", 
      "','", "", "", "", "", "", "';'", "", "", "':'", "'%'", "'+'", "'-'", 
      "'*'", "'/'", "'|'", "'!'", "'('", "')'", "'{'", "'}'", "'['", "']'"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "", "", "ABEND", "END", "LENGTH", 
      "QKUPCASE", "SYSEVALF", "ABORT", "EVAL", "LET", "QSCAN", "SYSEXEC", 
      "ACT", "FILE", "LIST", "QSUBSTR", "SYSFUNC", "ACTIVATE", "GLOBAL", 
      "LISTM", "QSYSFUNC", "SYSGET", "BQUOTE", "GO", "LOCAL", "QUOTE", "SYSRPUT", 
      "BY", "GOTO", "MACRO", "QUPCASE", "THEN", "CLEAR", "IF", "MEND", "RESOLVE", 
      "TO", "CLOSE", "INC", "PAUSE", "RETURN", "TSO", "CMS", "INCLUDE", 
      "NRSTR", "RUN", "UNQUOTE", "COMANDR", "INDEX", "ON", "SAVE", "UNSTR", 
      "COPY", "INFILE", "OPEN", "SCAN", "UNTIL", "DEACT", "INPUT", "PUT", 
      "STOP", "UPCASE", "DEL", "KCMPRES", "NRBQUOTE", "STR", "WHILE", "DELETE", 
      "KINDEX", "NRQUOTE", "SYSCALL", "WINDOW", "DISPLAY", "KLEFT", "METASYM", 
      "SUBSTR", "DMIDSPLY", "KLENGTH", "QKCMPRES", "SUPERQ", "DMISPLIT", 
      "KSCAN", "QKLEFT", "SYMDEL", "DO", "KSUBSTR", "QKSCAN", "SYMEXIST", 
      "EDIT", "KTRIM", "QKSUBSTR", "SYMGLOBL", "ELSE", "KUPCASE", "QKTRIM", 
      "SYMLOCAL", "Tk_NULL", "CANCEL", "NOLIST", "ARRAY", "ARRAY_NUMERIC_ELEMENTS", 
      "ARRAY_CHARACTER_ELEMENTS", "ARRAY_ALL_ELEMENTS", "GROUPFORMAT", "NOTSORTED", 
      "DESCENDING", "CALL", "DEBUG", "NESTING", "STACK", "READ", "PW", "SOURCE", 
      "VIEW", "PGM", "ENCRYPT", "NOSAVE", "DATALINES", "CARDS", "LINES", 
      "DATALINES4", "CARDS4", "LINES4", "END_DATALINES4", "ALTER", "DISK", 
      "DUMMY", "GTERM", "PIPE", "PLOTTER", "PRINTER", "TAPE", "TEMP", "TERMINAL", 
      "UPRINTER", "DSD", "EXPANDTABS", "NOEXPANDTABS", "FLOWOVER", "MISSOVER", 
      "PAD", "NOPAD", "SCANOVER", "SHAREBUFFERS", "STOPOVER", "TRUNCOVER", 
      "V_INFILE_", "INPUT_ODS", "DATE", "DATETIME", "DDMMYY", "INFORMAT_COMMA", 
      "INFORMAT_CHAR", "DROP", "PROC", "ANOVA", "MEANS", "REG", "CORR", 
      "SGPLOT", "PRINT", "DATA", "Informat", "DOLLAR", "EQ", "NE", "GT", 
      "LT", "GE", "LE", "IN", "EQC", "NEC", "GTC", "LTC", "GEC", "LEC", 
      "INColon", "AND", "OR", "NOT", "MIN", "MAX", "DateLiteral", "TimeLiteral", 
      "DateTimeLiteral", "BitLiteral", "NameLiteral", "HexLiteral", "STRINGLITERAL", 
      "INT", "FloatingPointLiteral", "Identifier", "DOT", "AT", "EQUAL", 
      "COMMA", "LBracket", "RBracket", "WS", "COMMENT", "LINE_COMMENT", 
      "SEMICOLON", "OF", "MissingValueLiteral", "COLON", "PERCENT", "ADD", 
      "SUB", "MUL", "DIV", "VERLINE", "EXCLAMATION", "LParentheses", "RParentheses", 
      "LBraces", "RBraces", "LSqBracket", "RSqBracket"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,226,1089,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,1,0,5,0,150,8,0,10,0,12,0,153,9,0,
  	1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  	1,1,1,1,1,3,1,175,8,1,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,1,3,3,3,187,
  	8,3,1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,203,8,
  	5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
  	1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,238,
  	8,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,5,5,254,8,
  	5,10,5,12,5,257,9,5,1,6,1,6,1,6,3,6,262,8,6,1,6,1,6,1,6,3,6,267,8,6,5,
  	6,269,8,6,10,6,12,6,272,9,6,1,6,1,6,4,6,276,8,6,11,6,12,6,277,1,6,5,6,
  	281,8,6,10,6,12,6,284,9,6,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,293,8,7,1,7,
  	1,7,1,7,5,7,298,8,7,10,7,12,7,301,9,7,1,7,1,7,1,7,5,7,306,8,7,10,7,12,
  	7,309,9,7,1,7,1,7,1,7,1,7,1,7,3,7,316,8,7,1,8,1,8,1,8,1,8,4,8,322,8,8,
  	11,8,12,8,323,1,9,1,9,1,9,1,9,3,9,330,8,9,1,9,1,9,1,9,3,9,335,8,9,5,9,
  	337,8,9,10,9,12,9,340,9,9,1,9,1,9,3,9,344,8,9,1,10,1,10,1,10,1,10,1,11,
  	1,11,1,12,1,12,1,12,1,12,1,12,3,12,357,8,12,1,12,1,12,1,12,5,12,362,8,
  	12,10,12,12,12,365,9,12,1,13,5,13,368,8,13,10,13,12,13,371,9,13,1,13,
  	1,13,1,14,1,14,1,14,1,14,3,14,379,8,14,1,14,3,14,382,8,14,1,14,3,14,385,
  	8,14,1,14,3,14,388,8,14,1,14,1,14,1,15,1,15,1,16,5,16,395,8,16,10,16,
  	12,16,398,9,16,1,16,1,16,1,17,1,17,1,17,5,17,405,8,17,10,17,12,17,408,
  	9,17,1,17,1,17,1,18,1,18,1,19,5,19,415,8,19,10,19,12,19,418,9,19,1,19,
  	1,19,1,20,1,20,1,20,1,20,1,20,1,20,3,20,428,8,20,1,20,3,20,431,8,20,1,
  	20,3,20,434,8,20,1,20,3,20,437,8,20,1,20,1,20,1,21,1,21,1,22,1,22,1,22,
  	1,22,5,22,447,8,22,10,22,12,22,450,9,22,1,22,1,22,1,22,1,22,1,22,1,22,
  	1,22,5,22,459,8,22,10,22,12,22,462,9,22,3,22,464,8,22,1,23,1,23,1,23,
  	1,23,4,23,470,8,23,11,23,12,23,471,1,23,1,23,1,23,3,23,477,8,23,1,24,
  	1,24,1,24,3,24,482,8,24,1,24,5,24,485,8,24,10,24,12,24,488,9,24,1,24,
  	1,24,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,3,25,
  	504,8,25,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,3,26,516,8,
  	26,1,26,3,26,519,8,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,3,
  	26,530,8,26,5,26,532,8,26,10,26,12,26,535,9,26,1,26,1,26,1,27,1,27,1,
  	28,1,28,1,29,5,29,544,8,29,10,29,12,29,547,9,29,1,29,1,29,1,30,1,30,1,
  	30,1,30,1,30,1,31,5,31,557,8,31,10,31,12,31,560,9,31,1,31,1,31,1,32,1,
  	32,3,32,566,8,32,1,32,1,32,1,32,3,32,571,8,32,1,32,5,32,574,8,32,10,32,
  	12,32,577,9,32,1,32,3,32,580,8,32,1,32,3,32,583,8,32,1,32,1,32,1,33,5,
  	33,588,8,33,10,33,12,33,591,9,33,1,33,1,33,1,34,1,34,1,34,1,34,3,34,599,
  	8,34,1,34,1,34,1,34,1,35,5,35,605,8,35,10,35,12,35,608,9,35,1,35,1,35,
  	1,36,1,36,1,36,1,36,1,36,3,36,617,8,36,1,36,3,36,620,8,36,1,36,1,36,1,
  	36,4,36,625,8,36,11,36,12,36,626,1,36,3,36,630,8,36,1,36,3,36,633,8,36,
  	1,36,1,36,1,36,1,36,4,36,639,8,36,11,36,12,36,640,1,36,1,36,1,36,1,36,
  	1,36,3,36,648,8,36,1,36,3,36,651,8,36,1,36,3,36,654,8,36,1,36,3,36,657,
  	8,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,3,36,668,8,36,1,36,
  	3,36,671,8,36,1,36,3,36,674,8,36,1,36,3,36,677,8,36,1,36,1,36,1,36,1,
  	36,1,36,1,36,1,36,3,36,686,8,36,1,36,3,36,689,8,36,1,36,1,36,1,36,1,36,
  	1,36,1,36,1,36,3,36,698,8,36,1,36,3,36,701,8,36,1,36,1,36,3,36,705,8,
  	36,1,37,1,37,1,37,1,37,1,37,5,37,712,8,37,10,37,12,37,715,9,37,1,37,1,
  	37,3,37,719,8,37,1,38,1,38,3,38,723,8,38,1,38,3,38,726,8,38,1,38,1,38,
  	1,38,3,38,731,8,38,1,39,1,39,3,39,735,8,39,1,39,1,39,1,39,1,39,5,39,741,
  	8,39,10,39,12,39,744,9,39,1,39,1,39,3,39,748,8,39,1,40,1,40,1,41,1,41,
  	1,42,1,42,1,43,1,43,1,43,1,43,5,43,760,8,43,10,43,12,43,763,9,43,1,43,
  	1,43,1,44,1,44,1,44,1,44,1,44,1,44,1,45,1,45,5,45,775,8,45,10,45,12,45,
  	778,9,45,1,45,1,45,1,46,1,46,1,46,5,46,785,8,46,10,46,12,46,788,9,46,
  	1,46,1,46,1,47,1,47,1,47,5,47,795,8,47,10,47,12,47,798,9,47,1,47,1,47,
  	1,48,5,48,803,8,48,10,48,12,48,806,9,48,1,48,1,48,1,49,1,49,1,49,1,49,
  	1,49,1,49,4,49,816,8,49,11,49,12,49,817,1,49,1,49,1,50,5,50,823,8,50,
  	10,50,12,50,826,9,50,1,50,1,50,1,51,1,51,1,51,3,51,833,8,51,1,51,5,51,
  	836,8,51,10,51,12,51,839,9,51,1,51,1,51,1,52,1,52,1,53,1,53,1,54,1,54,
  	1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,3,54,
  	862,8,54,1,55,1,55,5,55,866,8,55,10,55,12,55,869,9,55,1,55,1,55,1,56,
  	1,56,5,56,875,8,56,10,56,12,56,878,9,56,1,56,3,56,881,8,56,1,56,1,56,
  	1,56,3,56,886,8,56,1,56,1,56,1,57,1,57,5,57,892,8,57,10,57,12,57,895,
  	9,57,1,57,3,57,898,8,57,1,57,1,57,1,57,3,57,903,8,57,1,57,1,57,1,58,1,
  	58,1,58,1,58,1,58,1,58,1,58,1,58,1,58,1,58,3,58,917,8,58,1,59,1,59,1,
  	59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,3,59,929,8,59,1,60,1,60,3,60,933,
  	8,60,1,61,1,61,3,61,937,8,61,1,61,3,61,940,8,61,4,61,942,8,61,11,61,12,
  	61,943,1,62,1,62,3,62,948,8,62,1,62,3,62,951,8,62,1,62,3,62,954,8,62,
  	1,62,1,62,3,62,958,8,62,1,62,3,62,961,8,62,1,62,3,62,964,8,62,3,62,966,
  	8,62,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,3,63,978,8,63,
  	1,64,1,64,3,64,982,8,64,1,64,3,64,985,8,64,1,64,3,64,988,8,64,1,64,1,
  	64,3,64,992,8,64,1,64,3,64,995,8,64,1,64,3,64,998,8,64,3,64,1000,8,64,
  	1,65,1,65,1,65,1,65,1,65,3,65,1007,8,65,1,65,1,65,3,65,1011,8,65,1,66,
  	1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,
  	1,66,1,66,1,66,1,66,1,66,1,66,1,66,3,66,1035,8,66,1,67,1,67,1,67,1,67,
  	1,67,1,67,1,67,1,67,1,67,1,67,3,67,1047,8,67,1,68,1,68,1,69,1,69,1,69,
  	1,69,1,70,5,70,1056,8,70,10,70,12,70,1059,9,70,1,70,1,70,1,71,1,71,1,
  	71,1,71,1,71,1,71,4,71,1069,8,71,11,71,12,71,1070,1,71,1,71,1,72,5,72,
  	1076,8,72,10,72,12,72,1079,9,72,1,72,1,72,1,73,1,73,3,73,1085,8,73,1,
  	73,1,73,1,73,6,406,713,742,761,786,796,3,10,12,24,74,0,2,4,6,8,10,12,
  	14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,
  	60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
  	106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,
  	142,144,146,0,19,1,0,215,216,2,0,214,214,217,218,1,0,2,3,1,0,172,177,
  	1,0,179,184,1,0,186,187,2,0,178,178,185,185,2,0,191,199,201,201,1,0,210,
  	210,1,0,163,168,1,0,197,199,1,0,221,222,2,0,118,119,132,132,2,0,58,58,
  	123,124,1,0,125,126,1,0,128,129,4,0,125,126,128,129,197,197,200,200,1,
  	0,133,142,2,0,6,9,213,213,1227,0,151,1,0,0,0,2,174,1,0,0,0,4,176,1,0,
  	0,0,6,180,1,0,0,0,8,188,1,0,0,0,10,202,1,0,0,0,12,258,1,0,0,0,14,315,
  	1,0,0,0,16,321,1,0,0,0,18,343,1,0,0,0,20,345,1,0,0,0,22,349,1,0,0,0,24,
  	356,1,0,0,0,26,369,1,0,0,0,28,374,1,0,0,0,30,391,1,0,0,0,32,396,1,0,0,
  	0,34,401,1,0,0,0,36,411,1,0,0,0,38,416,1,0,0,0,40,421,1,0,0,0,42,440,
  	1,0,0,0,44,463,1,0,0,0,46,476,1,0,0,0,48,478,1,0,0,0,50,503,1,0,0,0,52,
  	505,1,0,0,0,54,538,1,0,0,0,56,540,1,0,0,0,58,545,1,0,0,0,60,550,1,0,0,
  	0,62,558,1,0,0,0,64,563,1,0,0,0,66,589,1,0,0,0,68,594,1,0,0,0,70,606,
  	1,0,0,0,72,704,1,0,0,0,74,706,1,0,0,0,76,720,1,0,0,0,78,732,1,0,0,0,80,
  	749,1,0,0,0,82,751,1,0,0,0,84,753,1,0,0,0,86,755,1,0,0,0,88,766,1,0,0,
  	0,90,776,1,0,0,0,92,781,1,0,0,0,94,791,1,0,0,0,96,804,1,0,0,0,98,809,
  	1,0,0,0,100,824,1,0,0,0,102,829,1,0,0,0,104,842,1,0,0,0,106,844,1,0,0,
  	0,108,861,1,0,0,0,110,867,1,0,0,0,112,872,1,0,0,0,114,889,1,0,0,0,116,
  	916,1,0,0,0,118,928,1,0,0,0,120,932,1,0,0,0,122,941,1,0,0,0,124,965,1,
  	0,0,0,126,977,1,0,0,0,128,999,1,0,0,0,130,1010,1,0,0,0,132,1034,1,0,0,
  	0,134,1046,1,0,0,0,136,1048,1,0,0,0,138,1050,1,0,0,0,140,1057,1,0,0,0,
  	142,1062,1,0,0,0,144,1077,1,0,0,0,146,1082,1,0,0,0,148,150,3,2,1,0,149,
  	148,1,0,0,0,150,153,1,0,0,0,151,149,1,0,0,0,151,152,1,0,0,0,152,154,1,
  	0,0,0,153,151,1,0,0,0,154,155,5,0,0,1,155,1,1,0,0,0,156,175,3,28,14,0,
  	157,175,3,40,20,0,158,175,3,64,32,0,159,175,3,68,34,0,160,175,3,92,46,
  	0,161,175,3,94,47,0,162,175,3,8,4,0,163,175,3,98,49,0,164,175,3,72,36,
  	0,165,175,3,4,2,0,166,175,3,6,3,0,167,175,3,102,51,0,168,175,3,112,56,
  	0,169,175,3,114,57,0,170,175,3,142,71,0,171,175,3,34,17,0,172,175,3,60,
  	30,0,173,175,3,146,73,0,174,156,1,0,0,0,174,157,1,0,0,0,174,158,1,0,0,
  	0,174,159,1,0,0,0,174,160,1,0,0,0,174,161,1,0,0,0,174,162,1,0,0,0,174,
  	163,1,0,0,0,174,164,1,0,0,0,174,165,1,0,0,0,174,166,1,0,0,0,174,167,1,
  	0,0,0,174,168,1,0,0,0,174,169,1,0,0,0,174,170,1,0,0,0,174,171,1,0,0,0,
  	174,172,1,0,0,0,174,173,1,0,0,0,175,3,1,0,0,0,176,177,5,41,0,0,177,178,
  	3,10,5,0,178,179,5,210,0,0,179,5,1,0,0,0,180,181,5,41,0,0,181,182,3,10,
  	5,0,182,183,5,39,0,0,183,186,3,2,1,0,184,185,5,100,0,0,185,187,3,2,1,
  	0,186,184,1,0,0,0,186,187,1,0,0,0,187,7,1,0,0,0,188,189,5,75,0,0,189,
  	190,5,210,0,0,190,9,1,0,0,0,191,192,6,5,-1,0,192,203,3,22,11,0,193,203,
  	5,200,0,0,194,195,5,221,0,0,195,196,3,10,5,0,196,197,5,222,0,0,197,203,
  	1,0,0,0,198,199,7,0,0,0,199,203,3,10,5,12,200,201,5,188,0,0,201,203,3,
  	10,5,11,202,191,1,0,0,0,202,193,1,0,0,0,202,194,1,0,0,0,202,198,1,0,0,
  	0,202,200,1,0,0,0,203,255,1,0,0,0,204,205,10,13,0,0,205,206,5,1,0,0,206,
  	254,3,10,5,13,207,208,10,10,0,0,208,209,5,189,0,0,209,254,3,10,5,11,210,
  	211,10,9,0,0,211,212,5,190,0,0,212,254,3,10,5,10,213,214,10,8,0,0,214,
  	215,7,1,0,0,215,254,3,10,5,9,216,217,10,7,0,0,217,218,7,0,0,0,218,254,
  	3,10,5,8,219,220,10,6,0,0,220,221,7,2,0,0,221,254,3,10,5,7,222,223,10,
  	5,0,0,223,224,7,3,0,0,224,254,3,10,5,6,225,226,10,4,0,0,226,227,7,4,0,
  	0,227,254,3,10,5,5,228,229,10,2,0,0,229,230,7,5,0,0,230,254,3,10,5,3,
  	231,232,10,1,0,0,232,233,5,203,0,0,233,254,3,10,5,1,234,235,10,16,0,0,
  	235,237,5,221,0,0,236,238,3,12,6,0,237,236,1,0,0,0,237,238,1,0,0,0,238,
  	239,1,0,0,0,239,254,5,222,0,0,240,241,10,15,0,0,241,242,5,223,0,0,242,
  	243,3,10,5,0,243,244,5,224,0,0,244,254,1,0,0,0,245,246,10,14,0,0,246,
  	247,5,225,0,0,247,248,3,10,5,0,248,249,5,226,0,0,249,254,1,0,0,0,250,
  	251,10,3,0,0,251,252,7,6,0,0,252,254,3,18,9,0,253,204,1,0,0,0,253,207,
  	1,0,0,0,253,210,1,0,0,0,253,213,1,0,0,0,253,216,1,0,0,0,253,219,1,0,0,
  	0,253,222,1,0,0,0,253,225,1,0,0,0,253,228,1,0,0,0,253,231,1,0,0,0,253,
  	234,1,0,0,0,253,240,1,0,0,0,253,245,1,0,0,0,253,250,1,0,0,0,254,257,1,
  	0,0,0,255,253,1,0,0,0,255,256,1,0,0,0,256,11,1,0,0,0,257,255,1,0,0,0,
  	258,261,6,6,-1,0,259,262,3,10,5,0,260,262,3,14,7,0,261,259,1,0,0,0,261,
  	260,1,0,0,0,262,270,1,0,0,0,263,266,5,204,0,0,264,267,3,10,5,0,265,267,
  	3,14,7,0,266,264,1,0,0,0,266,265,1,0,0,0,267,269,1,0,0,0,268,263,1,0,
  	0,0,269,272,1,0,0,0,270,268,1,0,0,0,270,271,1,0,0,0,271,282,1,0,0,0,272,
  	270,1,0,0,0,273,275,10,1,0,0,274,276,5,204,0,0,275,274,1,0,0,0,276,277,
  	1,0,0,0,277,275,1,0,0,0,277,278,1,0,0,0,278,279,1,0,0,0,279,281,3,12,
  	6,2,280,273,1,0,0,0,281,284,1,0,0,0,282,280,1,0,0,0,282,283,1,0,0,0,283,
  	13,1,0,0,0,284,282,1,0,0,0,285,286,5,4,0,0,286,287,5,200,0,0,287,288,
  	5,216,0,0,288,289,5,200,0,0,289,299,1,0,0,0,290,291,5,204,0,0,291,293,
  	5,4,0,0,292,290,1,0,0,0,292,293,1,0,0,0,293,294,1,0,0,0,294,295,5,200,
  	0,0,295,296,5,216,0,0,296,298,5,200,0,0,297,292,1,0,0,0,298,301,1,0,0,
  	0,299,297,1,0,0,0,299,300,1,0,0,0,300,316,1,0,0,0,301,299,1,0,0,0,302,
  	303,5,4,0,0,303,307,5,200,0,0,304,306,5,200,0,0,305,304,1,0,0,0,306,309,
  	1,0,0,0,307,305,1,0,0,0,307,308,1,0,0,0,308,316,1,0,0,0,309,307,1,0,0,
  	0,310,311,5,4,0,0,311,312,5,200,0,0,312,313,5,225,0,0,313,314,5,217,0,
  	0,314,316,5,226,0,0,315,285,1,0,0,0,315,302,1,0,0,0,315,310,1,0,0,0,316,
  	15,1,0,0,0,317,322,5,200,0,0,318,319,5,200,0,0,319,320,5,216,0,0,320,
  	322,5,200,0,0,321,317,1,0,0,0,321,318,1,0,0,0,322,323,1,0,0,0,323,321,
  	1,0,0,0,323,324,1,0,0,0,324,17,1,0,0,0,325,344,5,200,0,0,326,329,5,221,
  	0,0,327,330,3,22,11,0,328,330,3,20,10,0,329,327,1,0,0,0,329,328,1,0,0,
  	0,330,338,1,0,0,0,331,334,5,204,0,0,332,335,3,22,11,0,333,335,3,20,10,
  	0,334,332,1,0,0,0,334,333,1,0,0,0,335,337,1,0,0,0,336,331,1,0,0,0,337,
  	340,1,0,0,0,338,336,1,0,0,0,338,339,1,0,0,0,339,341,1,0,0,0,340,338,1,
  	0,0,0,341,342,5,222,0,0,342,344,1,0,0,0,343,325,1,0,0,0,343,326,1,0,0,
  	0,344,19,1,0,0,0,345,346,5,198,0,0,346,347,5,213,0,0,347,348,5,198,0,
  	0,348,21,1,0,0,0,349,350,7,7,0,0,350,23,1,0,0,0,351,352,6,12,-1,0,352,
  	357,5,200,0,0,353,357,5,156,0,0,354,357,5,132,0,0,355,357,5,161,0,0,356,
  	351,1,0,0,0,356,353,1,0,0,0,356,354,1,0,0,0,356,355,1,0,0,0,357,363,1,
  	0,0,0,358,359,10,5,0,0,359,360,5,201,0,0,360,362,3,24,12,6,361,358,1,
  	0,0,0,362,365,1,0,0,0,363,361,1,0,0,0,363,364,1,0,0,0,364,25,1,0,0,0,
  	365,363,1,0,0,0,366,368,3,28,14,0,367,366,1,0,0,0,368,371,1,0,0,0,369,
  	367,1,0,0,0,369,370,1,0,0,0,370,372,1,0,0,0,371,369,1,0,0,0,372,373,5,
  	0,0,1,373,27,1,0,0,0,374,381,5,15,0,0,375,382,5,10,0,0,376,378,5,105,
  	0,0,377,379,3,30,15,0,378,377,1,0,0,0,378,379,1,0,0,0,379,382,1,0,0,0,
  	380,382,5,48,0,0,381,375,1,0,0,0,381,376,1,0,0,0,381,380,1,0,0,0,381,
  	382,1,0,0,0,382,384,1,0,0,0,383,385,5,198,0,0,384,383,1,0,0,0,384,385,
  	1,0,0,0,385,387,1,0,0,0,386,388,5,106,0,0,387,386,1,0,0,0,387,388,1,0,
  	0,0,388,389,1,0,0,0,389,390,5,210,0,0,390,29,1,0,0,0,391,392,5,197,0,
  	0,392,31,1,0,0,0,393,395,3,34,17,0,394,393,1,0,0,0,395,398,1,0,0,0,396,
  	394,1,0,0,0,396,397,1,0,0,0,397,399,1,0,0,0,398,396,1,0,0,0,399,400,5,
  	0,0,1,400,33,1,0,0,0,401,402,5,162,0,0,402,406,3,36,18,0,403,405,8,8,
  	0,0,404,403,1,0,0,0,405,408,1,0,0,0,406,407,1,0,0,0,406,404,1,0,0,0,407,
  	409,1,0,0,0,408,406,1,0,0,0,409,410,5,210,0,0,410,35,1,0,0,0,411,412,
  	7,9,0,0,412,37,1,0,0,0,413,415,3,40,20,0,414,413,1,0,0,0,415,418,1,0,
  	0,0,416,414,1,0,0,0,416,417,1,0,0,0,417,419,1,0,0,0,418,416,1,0,0,0,419,
  	420,5,0,0,1,420,39,1,0,0,0,421,422,5,107,0,0,422,423,3,42,21,0,423,424,
  	5,205,0,0,424,425,3,44,22,0,425,427,5,206,0,0,426,428,5,171,0,0,427,426,
  	1,0,0,0,427,428,1,0,0,0,428,430,1,0,0,0,429,431,5,198,0,0,430,429,1,0,
  	0,0,430,431,1,0,0,0,431,433,1,0,0,0,432,434,3,46,23,0,433,432,1,0,0,0,
  	433,434,1,0,0,0,434,436,1,0,0,0,435,437,3,48,24,0,436,435,1,0,0,0,436,
  	437,1,0,0,0,437,438,1,0,0,0,438,439,5,210,0,0,439,41,1,0,0,0,440,441,
  	5,200,0,0,441,43,1,0,0,0,442,464,5,217,0,0,443,448,5,198,0,0,444,445,
  	5,204,0,0,445,447,5,198,0,0,446,444,1,0,0,0,447,450,1,0,0,0,448,446,1,
  	0,0,0,448,449,1,0,0,0,449,464,1,0,0,0,450,448,1,0,0,0,451,452,5,198,0,
  	0,452,453,5,213,0,0,453,460,5,198,0,0,454,455,5,204,0,0,455,456,5,198,
  	0,0,456,457,5,213,0,0,457,459,5,198,0,0,458,454,1,0,0,0,459,462,1,0,0,
  	0,460,458,1,0,0,0,460,461,1,0,0,0,461,464,1,0,0,0,462,460,1,0,0,0,463,
  	442,1,0,0,0,463,443,1,0,0,0,463,451,1,0,0,0,464,45,1,0,0,0,465,477,5,
  	108,0,0,466,477,5,109,0,0,467,477,5,110,0,0,468,470,5,200,0,0,469,468,
  	1,0,0,0,470,471,1,0,0,0,471,469,1,0,0,0,471,472,1,0,0,0,472,477,1,0,0,
  	0,473,474,5,200,0,0,474,475,5,216,0,0,475,477,5,200,0,0,476,465,1,0,0,
  	0,476,466,1,0,0,0,476,467,1,0,0,0,476,469,1,0,0,0,476,473,1,0,0,0,477,
  	47,1,0,0,0,478,479,5,221,0,0,479,486,3,50,25,0,480,482,5,204,0,0,481,
  	480,1,0,0,0,481,482,1,0,0,0,482,483,1,0,0,0,483,485,3,50,25,0,484,481,
  	1,0,0,0,485,488,1,0,0,0,486,484,1,0,0,0,486,487,1,0,0,0,487,489,1,0,0,
  	0,488,486,1,0,0,0,489,490,5,222,0,0,490,49,1,0,0,0,491,492,5,198,0,0,
  	492,493,5,213,0,0,493,504,5,198,0,0,494,495,3,54,27,0,495,496,5,217,0,
  	0,496,497,3,48,24,0,497,504,1,0,0,0,498,499,3,54,27,0,499,500,5,217,0,
  	0,500,501,3,56,28,0,501,504,1,0,0,0,502,504,3,56,28,0,503,491,1,0,0,0,
  	503,494,1,0,0,0,503,498,1,0,0,0,503,502,1,0,0,0,504,51,1,0,0,0,505,515,
  	5,221,0,0,506,507,3,54,27,0,507,508,5,217,0,0,508,509,3,48,24,0,509,516,
  	1,0,0,0,510,511,3,54,27,0,511,512,5,217,0,0,512,513,3,56,28,0,513,516,
  	1,0,0,0,514,516,3,56,28,0,515,506,1,0,0,0,515,510,1,0,0,0,515,514,1,0,
  	0,0,516,533,1,0,0,0,517,519,5,204,0,0,518,517,1,0,0,0,518,519,1,0,0,0,
  	519,529,1,0,0,0,520,521,3,54,27,0,521,522,5,217,0,0,522,523,3,48,24,0,
  	523,530,1,0,0,0,524,525,3,54,27,0,525,526,5,217,0,0,526,527,3,56,28,0,
  	527,530,1,0,0,0,528,530,3,56,28,0,529,520,1,0,0,0,529,524,1,0,0,0,529,
  	528,1,0,0,0,530,532,1,0,0,0,531,518,1,0,0,0,532,535,1,0,0,0,533,531,1,
  	0,0,0,533,534,1,0,0,0,534,536,1,0,0,0,535,533,1,0,0,0,536,537,5,222,0,
  	0,537,53,1,0,0,0,538,539,5,198,0,0,539,55,1,0,0,0,540,541,7,10,0,0,541,
  	57,1,0,0,0,542,544,3,60,30,0,543,542,1,0,0,0,544,547,1,0,0,0,545,543,
  	1,0,0,0,545,546,1,0,0,0,546,548,1,0,0,0,547,545,1,0,0,0,548,549,5,0,0,
  	1,549,59,1,0,0,0,550,551,5,200,0,0,551,552,5,203,0,0,552,553,3,10,5,0,
  	553,554,5,210,0,0,554,61,1,0,0,0,555,557,3,64,32,0,556,555,1,0,0,0,557,
  	560,1,0,0,0,558,556,1,0,0,0,558,559,1,0,0,0,559,561,1,0,0,0,560,558,1,
  	0,0,0,561,562,5,0,0,1,562,63,1,0,0,0,563,565,5,35,0,0,564,566,5,113,0,
  	0,565,564,1,0,0,0,565,566,1,0,0,0,566,567,1,0,0,0,567,568,5,200,0,0,568,
  	575,1,0,0,0,569,571,5,113,0,0,570,569,1,0,0,0,570,571,1,0,0,0,571,572,
  	1,0,0,0,572,574,5,200,0,0,573,570,1,0,0,0,574,577,1,0,0,0,575,573,1,0,
  	0,0,575,576,1,0,0,0,576,579,1,0,0,0,577,575,1,0,0,0,578,580,5,112,0,0,
  	579,578,1,0,0,0,579,580,1,0,0,0,580,582,1,0,0,0,581,583,5,111,0,0,582,
  	581,1,0,0,0,582,583,1,0,0,0,583,584,1,0,0,0,584,585,5,210,0,0,585,65,
  	1,0,0,0,586,588,3,68,34,0,587,586,1,0,0,0,588,591,1,0,0,0,589,587,1,0,
  	0,0,589,590,1,0,0,0,590,592,1,0,0,0,591,589,1,0,0,0,592,593,5,0,0,1,593,
  	67,1,0,0,0,594,595,5,114,0,0,595,596,3,10,5,0,596,598,5,221,0,0,597,599,
  	3,12,6,0,598,597,1,0,0,0,598,599,1,0,0,0,599,600,1,0,0,0,600,601,5,222,
  	0,0,601,602,5,210,0,0,602,69,1,0,0,0,603,605,3,72,36,0,604,603,1,0,0,
  	0,605,608,1,0,0,0,606,604,1,0,0,0,606,607,1,0,0,0,607,609,1,0,0,0,608,
  	606,1,0,0,0,609,610,5,0,0,1,610,71,1,0,0,0,611,612,5,169,0,0,612,705,
  	5,210,0,0,613,614,5,169,0,0,614,616,5,104,0,0,615,617,3,76,38,0,616,615,
  	1,0,0,0,616,617,1,0,0,0,617,619,1,0,0,0,618,620,5,106,0,0,619,618,1,0,
  	0,0,619,620,1,0,0,0,620,621,1,0,0,0,621,705,5,210,0,0,622,624,5,169,0,
  	0,623,625,3,74,37,0,624,623,1,0,0,0,625,626,1,0,0,0,626,624,1,0,0,0,626,
  	627,1,0,0,0,627,629,1,0,0,0,628,630,3,76,38,0,629,628,1,0,0,0,629,630,
  	1,0,0,0,630,632,1,0,0,0,631,633,5,106,0,0,632,631,1,0,0,0,632,633,1,0,
  	0,0,633,634,1,0,0,0,634,635,5,210,0,0,635,705,1,0,0,0,636,638,5,169,0,
  	0,637,639,3,78,39,0,638,637,1,0,0,0,639,640,1,0,0,0,640,638,1,0,0,0,640,
  	641,1,0,0,0,641,642,1,0,0,0,642,643,5,218,0,0,643,644,5,121,0,0,644,645,
  	5,203,0,0,645,647,3,80,40,0,646,648,3,86,43,0,647,646,1,0,0,0,647,648,
  	1,0,0,0,648,650,1,0,0,0,649,651,3,88,44,0,650,649,1,0,0,0,650,651,1,0,
  	0,0,651,653,1,0,0,0,652,654,5,116,0,0,653,652,1,0,0,0,653,654,1,0,0,0,
  	654,656,1,0,0,0,655,657,5,106,0,0,656,655,1,0,0,0,656,657,1,0,0,0,657,
  	658,1,0,0,0,658,659,5,210,0,0,659,705,1,0,0,0,660,661,5,169,0,0,661,662,
  	3,82,41,0,662,663,5,218,0,0,663,664,5,122,0,0,664,665,5,203,0,0,665,667,
  	3,84,42,0,666,668,3,86,43,0,667,666,1,0,0,0,667,668,1,0,0,0,668,670,1,
  	0,0,0,669,671,3,88,44,0,670,669,1,0,0,0,670,671,1,0,0,0,671,673,1,0,0,
  	0,672,674,5,116,0,0,673,672,1,0,0,0,673,674,1,0,0,0,674,676,1,0,0,0,675,
  	677,5,106,0,0,676,675,1,0,0,0,676,677,1,0,0,0,677,678,1,0,0,0,678,679,
  	5,210,0,0,679,705,1,0,0,0,680,681,5,169,0,0,681,682,5,121,0,0,682,683,
  	5,203,0,0,683,685,3,80,40,0,684,686,3,86,43,0,685,684,1,0,0,0,685,686,
  	1,0,0,0,686,688,1,0,0,0,687,689,5,106,0,0,688,687,1,0,0,0,688,689,1,0,
  	0,0,689,690,1,0,0,0,690,691,5,210,0,0,691,705,1,0,0,0,692,693,5,169,0,
  	0,693,694,5,122,0,0,694,695,5,203,0,0,695,697,3,84,42,0,696,698,3,86,
  	43,0,697,696,1,0,0,0,697,698,1,0,0,0,698,700,1,0,0,0,699,701,5,106,0,
  	0,700,699,1,0,0,0,700,701,1,0,0,0,701,702,1,0,0,0,702,703,5,210,0,0,703,
  	705,1,0,0,0,704,611,1,0,0,0,704,613,1,0,0,0,704,622,1,0,0,0,704,636,1,
  	0,0,0,704,660,1,0,0,0,704,680,1,0,0,0,704,692,1,0,0,0,705,73,1,0,0,0,
  	706,718,3,82,41,0,707,708,5,221,0,0,708,709,3,24,12,0,709,713,5,203,0,
  	0,710,712,8,11,0,0,711,710,1,0,0,0,712,715,1,0,0,0,713,714,1,0,0,0,713,
  	711,1,0,0,0,714,716,1,0,0,0,715,713,1,0,0,0,716,717,5,222,0,0,717,719,
  	1,0,0,0,718,707,1,0,0,0,718,719,1,0,0,0,719,75,1,0,0,0,720,722,5,218,
  	0,0,721,723,5,115,0,0,722,721,1,0,0,0,722,723,1,0,0,0,723,725,1,0,0,0,
  	724,726,5,116,0,0,725,724,1,0,0,0,725,726,1,0,0,0,726,730,1,0,0,0,727,
  	728,5,117,0,0,728,729,5,203,0,0,729,731,5,198,0,0,730,727,1,0,0,0,730,
  	731,1,0,0,0,731,77,1,0,0,0,732,734,3,24,12,0,733,735,3,24,12,0,734,733,
  	1,0,0,0,734,735,1,0,0,0,735,747,1,0,0,0,736,737,5,221,0,0,737,738,3,24,
  	12,0,738,742,5,203,0,0,739,741,8,11,0,0,740,739,1,0,0,0,741,744,1,0,0,
  	0,742,743,1,0,0,0,742,740,1,0,0,0,743,745,1,0,0,0,744,742,1,0,0,0,745,
  	746,5,222,0,0,746,748,1,0,0,0,747,736,1,0,0,0,747,748,1,0,0,0,748,79,
  	1,0,0,0,749,750,3,24,12,0,750,81,1,0,0,0,751,752,3,24,12,0,752,83,1,0,
  	0,0,753,754,3,24,12,0,754,85,1,0,0,0,755,756,5,221,0,0,756,757,7,12,0,
  	0,757,761,5,203,0,0,758,760,8,11,0,0,759,758,1,0,0,0,760,763,1,0,0,0,
  	761,762,1,0,0,0,761,759,1,0,0,0,762,764,1,0,0,0,763,761,1,0,0,0,764,765,
  	5,222,0,0,765,87,1,0,0,0,766,767,5,221,0,0,767,768,5,120,0,0,768,769,
  	5,203,0,0,769,770,7,13,0,0,770,771,5,222,0,0,771,89,1,0,0,0,772,775,3,
  	92,46,0,773,775,3,94,47,0,774,772,1,0,0,0,774,773,1,0,0,0,775,778,1,0,
  	0,0,776,774,1,0,0,0,776,777,1,0,0,0,777,779,1,0,0,0,778,776,1,0,0,0,779,
  	780,5,0,0,1,780,91,1,0,0,0,781,782,7,14,0,0,782,786,5,210,0,0,783,785,
  	8,8,0,0,784,783,1,0,0,0,785,788,1,0,0,0,786,787,1,0,0,0,786,784,1,0,0,
  	0,787,789,1,0,0,0,788,786,1,0,0,0,789,790,5,210,0,0,790,93,1,0,0,0,791,
  	792,7,15,0,0,792,796,5,210,0,0,793,795,9,0,0,0,794,793,1,0,0,0,795,798,
  	1,0,0,0,796,797,1,0,0,0,796,794,1,0,0,0,797,799,1,0,0,0,798,796,1,0,0,
  	0,799,800,5,131,0,0,800,95,1,0,0,0,801,803,3,98,49,0,802,801,1,0,0,0,
  	803,806,1,0,0,0,804,802,1,0,0,0,804,805,1,0,0,0,805,807,1,0,0,0,806,804,
  	1,0,0,0,807,808,5,0,0,1,808,97,1,0,0,0,809,815,5,161,0,0,810,816,3,24,
  	12,0,811,812,3,24,12,0,812,813,5,216,0,0,813,814,3,24,12,0,814,816,1,
  	0,0,0,815,810,1,0,0,0,815,811,1,0,0,0,816,817,1,0,0,0,817,815,1,0,0,0,
  	817,818,1,0,0,0,818,819,1,0,0,0,819,820,5,210,0,0,820,99,1,0,0,0,821,
  	823,3,102,51,0,822,821,1,0,0,0,823,826,1,0,0,0,824,822,1,0,0,0,824,825,
  	1,0,0,0,825,827,1,0,0,0,826,824,1,0,0,0,827,828,5,0,0,1,828,101,1,0,0,
  	0,829,830,5,61,0,0,830,832,3,104,52,0,831,833,3,106,53,0,832,831,1,0,
  	0,0,832,833,1,0,0,0,833,837,1,0,0,0,834,836,3,108,54,0,835,834,1,0,0,
  	0,836,839,1,0,0,0,837,835,1,0,0,0,837,838,1,0,0,0,838,840,1,0,0,0,839,
  	837,1,0,0,0,840,841,5,210,0,0,841,103,1,0,0,0,842,843,7,16,0,0,843,105,
  	1,0,0,0,844,845,7,17,0,0,845,107,1,0,0,0,846,847,5,200,0,0,847,848,5,
  	203,0,0,848,862,3,10,5,0,849,862,5,143,0,0,850,862,5,144,0,0,851,862,
  	5,145,0,0,852,862,5,146,0,0,853,862,5,147,0,0,854,862,5,148,0,0,855,862,
  	5,149,0,0,856,862,5,150,0,0,857,862,5,151,0,0,858,862,5,152,0,0,859,862,
  	5,153,0,0,860,862,5,154,0,0,861,846,1,0,0,0,861,849,1,0,0,0,861,850,1,
  	0,0,0,861,851,1,0,0,0,861,852,1,0,0,0,861,853,1,0,0,0,861,854,1,0,0,0,
  	861,855,1,0,0,0,861,856,1,0,0,0,861,857,1,0,0,0,861,858,1,0,0,0,861,859,
  	1,0,0,0,861,860,1,0,0,0,862,109,1,0,0,0,863,866,3,112,56,0,864,866,3,
  	114,57,0,865,863,1,0,0,0,865,864,1,0,0,0,866,869,1,0,0,0,867,865,1,0,
  	0,0,867,868,1,0,0,0,868,870,1,0,0,0,869,867,1,0,0,0,870,871,5,0,0,1,871,
  	111,1,0,0,0,872,876,5,66,0,0,873,875,3,116,58,0,874,873,1,0,0,0,875,878,
  	1,0,0,0,876,874,1,0,0,0,876,877,1,0,0,0,877,880,1,0,0,0,878,876,1,0,0,
  	0,879,881,5,155,0,0,880,879,1,0,0,0,880,881,1,0,0,0,881,885,1,0,0,0,882,
  	886,5,202,0,0,883,884,5,202,0,0,884,886,5,202,0,0,885,882,1,0,0,0,885,
  	883,1,0,0,0,885,886,1,0,0,0,886,887,1,0,0,0,887,888,5,210,0,0,888,113,
  	1,0,0,0,889,893,5,67,0,0,890,892,3,118,59,0,891,890,1,0,0,0,892,895,1,
  	0,0,0,893,891,1,0,0,0,893,894,1,0,0,0,894,897,1,0,0,0,895,893,1,0,0,0,
  	896,898,5,155,0,0,897,896,1,0,0,0,897,898,1,0,0,0,898,902,1,0,0,0,899,
  	903,5,202,0,0,900,901,5,202,0,0,901,903,5,202,0,0,902,899,1,0,0,0,902,
  	900,1,0,0,0,902,903,1,0,0,0,903,904,1,0,0,0,904,905,5,210,0,0,905,115,
  	1,0,0,0,906,917,3,120,60,0,907,917,3,124,62,0,908,917,3,138,69,0,909,
  	910,5,221,0,0,910,911,3,16,8,0,911,912,5,222,0,0,912,913,5,221,0,0,913,
  	914,3,122,61,0,914,915,5,222,0,0,915,917,1,0,0,0,916,906,1,0,0,0,916,
  	907,1,0,0,0,916,908,1,0,0,0,916,909,1,0,0,0,917,117,1,0,0,0,918,929,3,
  	120,60,0,919,929,3,128,64,0,920,929,3,138,69,0,921,922,5,221,0,0,922,
  	923,3,16,8,0,923,924,5,222,0,0,924,925,5,221,0,0,925,926,3,122,61,0,926,
  	927,5,222,0,0,927,929,1,0,0,0,928,918,1,0,0,0,928,919,1,0,0,0,928,920,
  	1,0,0,0,928,921,1,0,0,0,929,119,1,0,0,0,930,933,3,134,67,0,931,933,3,
  	132,66,0,932,930,1,0,0,0,932,931,1,0,0,0,933,121,1,0,0,0,934,936,5,170,
  	0,0,935,937,5,204,0,0,936,935,1,0,0,0,936,937,1,0,0,0,937,939,1,0,0,0,
  	938,940,3,120,60,0,939,938,1,0,0,0,939,940,1,0,0,0,940,942,1,0,0,0,941,
  	934,1,0,0,0,942,943,1,0,0,0,943,941,1,0,0,0,943,944,1,0,0,0,944,123,1,
  	0,0,0,945,947,3,126,63,0,946,948,5,203,0,0,947,946,1,0,0,0,947,948,1,
  	0,0,0,948,950,1,0,0,0,949,951,3,136,68,0,950,949,1,0,0,0,950,951,1,0,
  	0,0,951,953,1,0,0,0,952,954,5,170,0,0,953,952,1,0,0,0,953,954,1,0,0,0,
  	954,966,1,0,0,0,955,957,3,126,63,0,956,958,5,203,0,0,957,956,1,0,0,0,
  	957,958,1,0,0,0,958,960,1,0,0,0,959,961,3,136,68,0,960,959,1,0,0,0,960,
  	961,1,0,0,0,961,963,1,0,0,0,962,964,5,171,0,0,963,962,1,0,0,0,963,964,
  	1,0,0,0,964,966,1,0,0,0,965,945,1,0,0,0,965,955,1,0,0,0,966,125,1,0,0,
  	0,967,978,3,24,12,0,968,969,3,24,12,0,969,970,5,216,0,0,970,971,3,24,
  	12,0,971,978,1,0,0,0,972,973,3,24,12,0,973,974,5,223,0,0,974,975,5,217,
  	0,0,975,976,5,224,0,0,976,978,1,0,0,0,977,967,1,0,0,0,977,968,1,0,0,0,
  	977,972,1,0,0,0,978,127,1,0,0,0,979,981,3,130,65,0,980,982,5,203,0,0,
  	981,980,1,0,0,0,981,982,1,0,0,0,982,984,1,0,0,0,983,985,3,136,68,0,984,
  	983,1,0,0,0,984,985,1,0,0,0,985,987,1,0,0,0,986,988,5,170,0,0,987,986,
  	1,0,0,0,987,988,1,0,0,0,988,1000,1,0,0,0,989,991,3,130,65,0,990,992,5,
  	203,0,0,991,990,1,0,0,0,991,992,1,0,0,0,992,994,1,0,0,0,993,995,3,136,
  	68,0,994,993,1,0,0,0,994,995,1,0,0,0,995,997,1,0,0,0,996,998,5,171,0,
  	0,997,996,1,0,0,0,997,998,1,0,0,0,998,1000,1,0,0,0,999,979,1,0,0,0,999,
  	989,1,0,0,0,1000,129,1,0,0,0,1001,1011,5,154,0,0,1002,1011,5,110,0,0,
  	1003,1011,3,126,63,0,1004,1005,5,198,0,0,1005,1007,5,217,0,0,1006,1004,
  	1,0,0,0,1006,1007,1,0,0,0,1007,1008,1,0,0,0,1008,1011,5,197,0,0,1009,
  	1011,3,22,11,0,1010,1001,1,0,0,0,1010,1002,1,0,0,0,1010,1003,1,0,0,0,
  	1010,1006,1,0,0,0,1010,1009,1,0,0,0,1011,131,1,0,0,0,1012,1013,5,202,
  	0,0,1013,1035,5,198,0,0,1014,1015,5,202,0,0,1015,1035,5,199,0,0,1016,
  	1017,5,202,0,0,1017,1035,5,200,0,0,1018,1019,5,202,0,0,1019,1020,5,221,
  	0,0,1020,1021,3,10,5,0,1021,1022,5,222,0,0,1022,1035,1,0,0,0,1023,1024,
  	5,215,0,0,1024,1035,5,198,0,0,1025,1026,5,215,0,0,1026,1035,5,200,0,0,
  	1027,1028,5,215,0,0,1028,1035,5,199,0,0,1029,1030,5,215,0,0,1030,1031,
  	5,221,0,0,1031,1032,3,10,5,0,1032,1033,5,222,0,0,1033,1035,1,0,0,0,1034,
  	1012,1,0,0,0,1034,1014,1,0,0,0,1034,1016,1,0,0,0,1034,1018,1,0,0,0,1034,
  	1023,1,0,0,0,1034,1025,1,0,0,0,1034,1027,1,0,0,0,1034,1029,1,0,0,0,1035,
  	133,1,0,0,0,1036,1037,5,5,0,0,1037,1047,5,198,0,0,1038,1039,5,5,0,0,1039,
  	1047,5,199,0,0,1040,1041,5,5,0,0,1041,1042,5,221,0,0,1042,1043,3,10,5,
  	0,1043,1044,5,222,0,0,1044,1047,1,0,0,0,1045,1047,5,218,0,0,1046,1036,
  	1,0,0,0,1046,1038,1,0,0,0,1046,1040,1,0,0,0,1046,1045,1,0,0,0,1047,135,
  	1,0,0,0,1048,1049,7,18,0,0,1049,137,1,0,0,0,1050,1051,5,198,0,0,1051,
  	1052,5,216,0,0,1052,1053,5,198,0,0,1053,139,1,0,0,0,1054,1056,3,142,71,
  	0,1055,1054,1,0,0,0,1056,1059,1,0,0,0,1057,1055,1,0,0,0,1057,1058,1,0,
  	0,0,1058,1060,1,0,0,0,1059,1057,1,0,0,0,1060,1061,5,0,0,1,1061,141,1,
  	0,0,0,1062,1068,5,161,0,0,1063,1069,3,24,12,0,1064,1065,3,24,12,0,1065,
  	1066,5,216,0,0,1066,1067,3,24,12,0,1067,1069,1,0,0,0,1068,1063,1,0,0,
  	0,1068,1064,1,0,0,0,1069,1070,1,0,0,0,1070,1068,1,0,0,0,1070,1071,1,0,
  	0,0,1071,1072,1,0,0,0,1072,1073,5,210,0,0,1073,143,1,0,0,0,1074,1076,
  	3,146,73,0,1075,1074,1,0,0,0,1076,1079,1,0,0,0,1077,1075,1,0,0,0,1077,
  	1078,1,0,0,0,1078,1080,1,0,0,0,1079,1077,1,0,0,0,1080,1081,5,0,0,1,1081,
  	145,1,0,0,0,1082,1084,5,53,0,0,1083,1085,5,105,0,0,1084,1083,1,0,0,0,
  	1084,1085,1,0,0,0,1085,1086,1,0,0,0,1086,1087,5,210,0,0,1087,147,1,0,
  	0,0,135,151,174,186,202,237,253,255,261,266,270,277,282,292,299,307,315,
  	321,323,329,334,338,343,356,363,369,378,381,384,387,396,406,416,427,430,
  	433,436,448,460,463,471,476,481,486,503,515,518,529,533,545,558,565,570,
  	575,579,582,589,598,606,616,619,626,629,632,640,647,650,653,656,667,670,
  	673,676,685,688,697,700,704,713,718,722,725,730,734,742,747,761,774,776,
  	786,796,804,815,817,824,832,837,861,865,867,876,880,885,893,897,902,916,
  	928,932,936,939,943,947,950,953,957,960,963,965,977,981,984,987,991,994,
  	997,999,1006,1010,1034,1046,1057,1068,1070,1077,1084
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  dapParserStaticData = staticData.release();
}

}

DapParser::DapParser(TokenStream *input) : DapParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

DapParser::DapParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  DapParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *dapParserStaticData->atn, dapParserStaticData->decisionToDFA, dapParserStaticData->sharedContextCache, options);
}

DapParser::~DapParser() {
  delete _interpreter;
}

const atn::ATN& DapParser::getATN() const {
  return *dapParserStaticData->atn;
}

std::string DapParser::getGrammarFileName() const {
  return "Dap.g4";
}

const std::vector<std::string>& DapParser::getRuleNames() const {
  return dapParserStaticData->ruleNames;
}

const dfa::Vocabulary& DapParser::getVocabulary() const {
  return dapParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView DapParser::getSerializedATN() const {
  return dapParserStaticData->serializedATN;
}


//----------------- ParseContext ------------------------------------------------------------------

DapParser::ParseContext::ParseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::ParseContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Sas_stmt_listContext *> DapParser::ParseContext::sas_stmt_list() {
  return getRuleContexts<DapParser::Sas_stmt_listContext>();
}

DapParser::Sas_stmt_listContext* DapParser::ParseContext::sas_stmt_list(size_t i) {
  return getRuleContext<DapParser::Sas_stmt_listContext>(i);
}


size_t DapParser::ParseContext::getRuleIndex() const {
  return DapParser::RuleParse;
}

void DapParser::ParseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParse(this);
}

void DapParser::ParseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParse(this);
}


std::any DapParser::ParseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitParse(this);
  else
    return visitor->visitChildren(this);
}

DapParser::ParseContext* DapParser::parse() {
  ParseContext *_localctx = _tracker.createInstance<ParseContext>(_ctx, getState());
  enterRule(_localctx, 0, DapParser::RuleParse);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(151);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2314852441851461632) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -2882020087517150717) != 0) || ((((_la - 161) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 161)) & 549755814147) != 0)) {
      setState(148);
      sas_stmt_list();
      setState(153);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(154);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sas_stmt_listContext ------------------------------------------------------------------

DapParser::Sas_stmt_listContext::Sas_stmt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::Abort_stmtContext* DapParser::Sas_stmt_listContext::abort_stmt() {
  return getRuleContext<DapParser::Abort_stmtContext>(0);
}

DapParser::Array_stmtContext* DapParser::Sas_stmt_listContext::array_stmt() {
  return getRuleContext<DapParser::Array_stmtContext>(0);
}

DapParser::By_stmtContext* DapParser::Sas_stmt_listContext::by_stmt() {
  return getRuleContext<DapParser::By_stmtContext>(0);
}

DapParser::Call_stmtContext* DapParser::Sas_stmt_listContext::call_stmt() {
  return getRuleContext<DapParser::Call_stmtContext>(0);
}

DapParser::Datalines_stmtContext* DapParser::Sas_stmt_listContext::datalines_stmt() {
  return getRuleContext<DapParser::Datalines_stmtContext>(0);
}

DapParser::Datalines4_stmtContext* DapParser::Sas_stmt_listContext::datalines4_stmt() {
  return getRuleContext<DapParser::Datalines4_stmtContext>(0);
}

DapParser::Delete_stmtContext* DapParser::Sas_stmt_listContext::delete_stmt() {
  return getRuleContext<DapParser::Delete_stmtContext>(0);
}

DapParser::Drop_stmtContext* DapParser::Sas_stmt_listContext::drop_stmt() {
  return getRuleContext<DapParser::Drop_stmtContext>(0);
}

DapParser::Data_stmtContext* DapParser::Sas_stmt_listContext::data_stmt() {
  return getRuleContext<DapParser::Data_stmtContext>(0);
}

DapParser::If_stmtContext* DapParser::Sas_stmt_listContext::if_stmt() {
  return getRuleContext<DapParser::If_stmtContext>(0);
}

DapParser::If_then_else_stmtContext* DapParser::Sas_stmt_listContext::if_then_else_stmt() {
  return getRuleContext<DapParser::If_then_else_stmtContext>(0);
}

DapParser::Infile_stmtContext* DapParser::Sas_stmt_listContext::infile_stmt() {
  return getRuleContext<DapParser::Infile_stmtContext>(0);
}

DapParser::Input_stmtContext* DapParser::Sas_stmt_listContext::input_stmt() {
  return getRuleContext<DapParser::Input_stmtContext>(0);
}

DapParser::Put_stmtContext* DapParser::Sas_stmt_listContext::put_stmt() {
  return getRuleContext<DapParser::Put_stmtContext>(0);
}

DapParser::Means_procContext* DapParser::Sas_stmt_listContext::means_proc() {
  return getRuleContext<DapParser::Means_procContext>(0);
}

DapParser::Proc_stmtContext* DapParser::Sas_stmt_listContext::proc_stmt() {
  return getRuleContext<DapParser::Proc_stmtContext>(0);
}

DapParser::Assign_stmtContext* DapParser::Sas_stmt_listContext::assign_stmt() {
  return getRuleContext<DapParser::Assign_stmtContext>(0);
}

DapParser::Run_stmtContext* DapParser::Sas_stmt_listContext::run_stmt() {
  return getRuleContext<DapParser::Run_stmtContext>(0);
}


size_t DapParser::Sas_stmt_listContext::getRuleIndex() const {
  return DapParser::RuleSas_stmt_list;
}

void DapParser::Sas_stmt_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSas_stmt_list(this);
}

void DapParser::Sas_stmt_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSas_stmt_list(this);
}


std::any DapParser::Sas_stmt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitSas_stmt_list(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Sas_stmt_listContext* DapParser::sas_stmt_list() {
  Sas_stmt_listContext *_localctx = _tracker.createInstance<Sas_stmt_listContext>(_ctx, getState());
  enterRule(_localctx, 2, DapParser::RuleSas_stmt_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(174);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(156);
      abort_stmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(157);
      array_stmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(158);
      by_stmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(159);
      call_stmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(160);
      datalines_stmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(161);
      datalines4_stmt();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(162);
      delete_stmt();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(163);
      drop_stmt();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(164);
      data_stmt();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(165);
      if_stmt();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(166);
      if_then_else_stmt();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(167);
      infile_stmt();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(168);
      input_stmt();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(169);
      put_stmt();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(170);
      means_proc();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(171);
      proc_stmt();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(172);
      assign_stmt();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(173);
      run_stmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_stmtContext ------------------------------------------------------------------

DapParser::If_stmtContext::If_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::If_stmtContext::IF() {
  return getToken(DapParser::IF, 0);
}

DapParser::ExpressionContext* DapParser::If_stmtContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::If_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}


size_t DapParser::If_stmtContext::getRuleIndex() const {
  return DapParser::RuleIf_stmt;
}

void DapParser::If_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_stmt(this);
}

void DapParser::If_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_stmt(this);
}


std::any DapParser::If_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitIf_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::If_stmtContext* DapParser::if_stmt() {
  If_stmtContext *_localctx = _tracker.createInstance<If_stmtContext>(_ctx, getState());
  enterRule(_localctx, 4, DapParser::RuleIf_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(176);
    match(DapParser::IF);
    setState(177);
    expression(0);
    setState(178);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_then_else_stmtContext ------------------------------------------------------------------

DapParser::If_then_else_stmtContext::If_then_else_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::If_then_else_stmtContext::IF() {
  return getToken(DapParser::IF, 0);
}

DapParser::ExpressionContext* DapParser::If_then_else_stmtContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::If_then_else_stmtContext::THEN() {
  return getToken(DapParser::THEN, 0);
}

std::vector<DapParser::Sas_stmt_listContext *> DapParser::If_then_else_stmtContext::sas_stmt_list() {
  return getRuleContexts<DapParser::Sas_stmt_listContext>();
}

DapParser::Sas_stmt_listContext* DapParser::If_then_else_stmtContext::sas_stmt_list(size_t i) {
  return getRuleContext<DapParser::Sas_stmt_listContext>(i);
}

tree::TerminalNode* DapParser::If_then_else_stmtContext::ELSE() {
  return getToken(DapParser::ELSE, 0);
}


size_t DapParser::If_then_else_stmtContext::getRuleIndex() const {
  return DapParser::RuleIf_then_else_stmt;
}

void DapParser::If_then_else_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_then_else_stmt(this);
}

void DapParser::If_then_else_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_then_else_stmt(this);
}


std::any DapParser::If_then_else_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitIf_then_else_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::If_then_else_stmtContext* DapParser::if_then_else_stmt() {
  If_then_else_stmtContext *_localctx = _tracker.createInstance<If_then_else_stmtContext>(_ctx, getState());
  enterRule(_localctx, 6, DapParser::RuleIf_then_else_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(180);
    match(DapParser::IF);
    setState(181);
    expression(0);
    setState(182);
    match(DapParser::THEN);
    setState(183);
    sas_stmt_list();
    setState(186);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      setState(184);
      match(DapParser::ELSE);
      setState(185);
      sas_stmt_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_stmtContext ------------------------------------------------------------------

DapParser::Delete_stmtContext::Delete_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Delete_stmtContext::DELETE() {
  return getToken(DapParser::DELETE, 0);
}

tree::TerminalNode* DapParser::Delete_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}


size_t DapParser::Delete_stmtContext::getRuleIndex() const {
  return DapParser::RuleDelete_stmt;
}

void DapParser::Delete_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_stmt(this);
}

void DapParser::Delete_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_stmt(this);
}


std::any DapParser::Delete_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDelete_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Delete_stmtContext* DapParser::delete_stmt() {
  Delete_stmtContext *_localctx = _tracker.createInstance<Delete_stmtContext>(_ctx, getState());
  enterRule(_localctx, 8, DapParser::RuleDelete_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(188);
    match(DapParser::DELETE);
    setState(189);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

DapParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::LiteralContext* DapParser::ExpressionContext::literal() {
  return getRuleContext<DapParser::LiteralContext>(0);
}

tree::TerminalNode* DapParser::ExpressionContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

std::vector<DapParser::ExpressionContext *> DapParser::ExpressionContext::expression() {
  return getRuleContexts<DapParser::ExpressionContext>();
}

DapParser::ExpressionContext* DapParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<DapParser::ExpressionContext>(i);
}

tree::TerminalNode* DapParser::ExpressionContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::ADD() {
  return getToken(DapParser::ADD, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::SUB() {
  return getToken(DapParser::SUB, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::NOT() {
  return getToken(DapParser::NOT, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::MIN() {
  return getToken(DapParser::MIN, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::MAX() {
  return getToken(DapParser::MAX, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::MUL() {
  return getToken(DapParser::MUL, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::DIV() {
  return getToken(DapParser::DIV, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::PERCENT() {
  return getToken(DapParser::PERCENT, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::EQ() {
  return getToken(DapParser::EQ, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::NE() {
  return getToken(DapParser::NE, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::GT() {
  return getToken(DapParser::GT, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::LT() {
  return getToken(DapParser::LT, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::GE() {
  return getToken(DapParser::GE, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::LE() {
  return getToken(DapParser::LE, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::EQC() {
  return getToken(DapParser::EQC, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::NEC() {
  return getToken(DapParser::NEC, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::GTC() {
  return getToken(DapParser::GTC, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::LTC() {
  return getToken(DapParser::LTC, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::GEC() {
  return getToken(DapParser::GEC, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::LEC() {
  return getToken(DapParser::LEC, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::AND() {
  return getToken(DapParser::AND, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::OR() {
  return getToken(DapParser::OR, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

DapParser::ExpressionListContext* DapParser::ExpressionContext::expressionList() {
  return getRuleContext<DapParser::ExpressionListContext>(0);
}

tree::TerminalNode* DapParser::ExpressionContext::LBraces() {
  return getToken(DapParser::LBraces, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::RBraces() {
  return getToken(DapParser::RBraces, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::LSqBracket() {
  return getToken(DapParser::LSqBracket, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::RSqBracket() {
  return getToken(DapParser::RSqBracket, 0);
}

DapParser::In_var_listContext* DapParser::ExpressionContext::in_var_list() {
  return getRuleContext<DapParser::In_var_listContext>(0);
}

tree::TerminalNode* DapParser::ExpressionContext::IN() {
  return getToken(DapParser::IN, 0);
}

tree::TerminalNode* DapParser::ExpressionContext::INColon() {
  return getToken(DapParser::INColon, 0);
}


size_t DapParser::ExpressionContext::getRuleIndex() const {
  return DapParser::RuleExpression;
}

void DapParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void DapParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


std::any DapParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}


DapParser::ExpressionContext* DapParser::expression() {
   return expression(0);
}

DapParser::ExpressionContext* DapParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  DapParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  DapParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 10;
  enterRecursionRule(_localctx, 10, DapParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(202);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::DateLiteral:
      case DapParser::TimeLiteral:
      case DapParser::DateTimeLiteral:
      case DapParser::BitLiteral:
      case DapParser::NameLiteral:
      case DapParser::HexLiteral:
      case DapParser::STRINGLITERAL:
      case DapParser::INT:
      case DapParser::FloatingPointLiteral:
      case DapParser::DOT: {
        setState(192);
        literal();
        break;
      }

      case DapParser::Identifier: {
        setState(193);
        match(DapParser::Identifier);
        break;
      }

      case DapParser::LParentheses: {
        setState(194);
        match(DapParser::LParentheses);
        setState(195);
        expression(0);
        setState(196);
        match(DapParser::RParentheses);
        break;
      }

      case DapParser::ADD:
      case DapParser::SUB: {
        setState(198);
        _la = _input->LA(1);
        if (!(_la == DapParser::ADD

        || _la == DapParser::SUB)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(199);
        expression(12);
        break;
      }

      case DapParser::NOT: {
        setState(200);
        match(DapParser::NOT);
        setState(201);
        expression(11);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(255);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(253);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(204);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(205);
          match(DapParser::T__0);
          setState(206);
          expression(13);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(207);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(208);
          match(DapParser::MIN);
          setState(209);
          expression(11);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(210);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(211);
          match(DapParser::MAX);
          setState(212);
          expression(10);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(213);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(214);
          _la = _input->LA(1);
          if (!(((((_la - 214) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 214)) & 25) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(215);
          expression(9);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(216);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(217);
          _la = _input->LA(1);
          if (!(_la == DapParser::ADD

          || _la == DapParser::SUB)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(218);
          expression(8);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(219);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(220);
          _la = _input->LA(1);
          if (!(_la == DapParser::T__1

          || _la == DapParser::T__2)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(221);
          expression(7);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(222);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(223);
          _la = _input->LA(1);
          if (!(((((_la - 172) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 172)) & 63) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(224);
          expression(6);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(225);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(226);
          _la = _input->LA(1);
          if (!(((((_la - 179) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 179)) & 63) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(227);
          expression(5);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(228);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(229);
          _la = _input->LA(1);
          if (!(_la == DapParser::AND

          || _la == DapParser::OR)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(230);
          expression(3);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(231);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(232);
          match(DapParser::EQUAL);
          setState(233);
          expression(1);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(234);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(235);
          match(DapParser::LParentheses);
          setState(237);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == DapParser::T__3 || ((((_la - 188) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 188)) & 8992604153) != 0)) {
            setState(236);
            expressionList(0);
          }
          setState(239);
          match(DapParser::RParentheses);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(240);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(241);
          match(DapParser::LBraces);
          setState(242);
          expression(0);
          setState(243);
          match(DapParser::RBraces);
          break;
        }

        case 13: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(245);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(246);
          match(DapParser::LSqBracket);
          setState(247);
          expression(0);
          setState(248);
          match(DapParser::RSqBracket);
          break;
        }

        case 14: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(250);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(251);
          _la = _input->LA(1);
          if (!(_la == DapParser::IN

          || _la == DapParser::INColon)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(252);
          in_var_list();
          break;
        }

        default:
          break;
        } 
      }
      setState(257);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ExpressionListContext ------------------------------------------------------------------

DapParser::ExpressionListContext::ExpressionListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<DapParser::ExpressionContext *> DapParser::ExpressionListContext::expression() {
  return getRuleContexts<DapParser::ExpressionContext>();
}

DapParser::ExpressionContext* DapParser::ExpressionListContext::expression(size_t i) {
  return getRuleContext<DapParser::ExpressionContext>(i);
}

std::vector<DapParser::Of_var_listContext *> DapParser::ExpressionListContext::of_var_list() {
  return getRuleContexts<DapParser::Of_var_listContext>();
}

DapParser::Of_var_listContext* DapParser::ExpressionListContext::of_var_list(size_t i) {
  return getRuleContext<DapParser::Of_var_listContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::ExpressionListContext::COMMA() {
  return getTokens(DapParser::COMMA);
}

tree::TerminalNode* DapParser::ExpressionListContext::COMMA(size_t i) {
  return getToken(DapParser::COMMA, i);
}

std::vector<DapParser::ExpressionListContext *> DapParser::ExpressionListContext::expressionList() {
  return getRuleContexts<DapParser::ExpressionListContext>();
}

DapParser::ExpressionListContext* DapParser::ExpressionListContext::expressionList(size_t i) {
  return getRuleContext<DapParser::ExpressionListContext>(i);
}


size_t DapParser::ExpressionListContext::getRuleIndex() const {
  return DapParser::RuleExpressionList;
}

void DapParser::ExpressionListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionList(this);
}

void DapParser::ExpressionListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionList(this);
}


std::any DapParser::ExpressionListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitExpressionList(this);
  else
    return visitor->visitChildren(this);
}


DapParser::ExpressionListContext* DapParser::expressionList() {
   return expressionList(0);
}

DapParser::ExpressionListContext* DapParser::expressionList(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  DapParser::ExpressionListContext *_localctx = _tracker.createInstance<ExpressionListContext>(_ctx, parentState);
  DapParser::ExpressionListContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 12;
  enterRecursionRule(_localctx, 12, DapParser::RuleExpressionList, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(261);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::NOT:
      case DapParser::DateLiteral:
      case DapParser::TimeLiteral:
      case DapParser::DateTimeLiteral:
      case DapParser::BitLiteral:
      case DapParser::NameLiteral:
      case DapParser::HexLiteral:
      case DapParser::STRINGLITERAL:
      case DapParser::INT:
      case DapParser::FloatingPointLiteral:
      case DapParser::Identifier:
      case DapParser::DOT:
      case DapParser::ADD:
      case DapParser::SUB:
      case DapParser::LParentheses: {
        setState(259);
        expression(0);
        break;
      }

      case DapParser::T__3: {
        setState(260);
        of_var_list();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(270);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(263);
        match(DapParser::COMMA);
        setState(266);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case DapParser::NOT:
          case DapParser::DateLiteral:
          case DapParser::TimeLiteral:
          case DapParser::DateTimeLiteral:
          case DapParser::BitLiteral:
          case DapParser::NameLiteral:
          case DapParser::HexLiteral:
          case DapParser::STRINGLITERAL:
          case DapParser::INT:
          case DapParser::FloatingPointLiteral:
          case DapParser::Identifier:
          case DapParser::DOT:
          case DapParser::ADD:
          case DapParser::SUB:
          case DapParser::LParentheses: {
            setState(264);
            expression(0);
            break;
          }

          case DapParser::T__3: {
            setState(265);
            of_var_list();
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(272);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    }
    _ctx->stop = _input->LT(-1);
    setState(282);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<ExpressionListContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleExpressionList);
        setState(273);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(275); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(274);
          match(DapParser::COMMA);
          setState(277); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == DapParser::COMMA);
        setState(279);
        expressionList(2); 
      }
      setState(284);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Of_var_listContext ------------------------------------------------------------------

DapParser::Of_var_listContext::Of_var_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::Of_var_listContext::Identifier() {
  return getTokens(DapParser::Identifier);
}

tree::TerminalNode* DapParser::Of_var_listContext::Identifier(size_t i) {
  return getToken(DapParser::Identifier, i);
}

std::vector<tree::TerminalNode *> DapParser::Of_var_listContext::SUB() {
  return getTokens(DapParser::SUB);
}

tree::TerminalNode* DapParser::Of_var_listContext::SUB(size_t i) {
  return getToken(DapParser::SUB, i);
}

std::vector<tree::TerminalNode *> DapParser::Of_var_listContext::COMMA() {
  return getTokens(DapParser::COMMA);
}

tree::TerminalNode* DapParser::Of_var_listContext::COMMA(size_t i) {
  return getToken(DapParser::COMMA, i);
}

tree::TerminalNode* DapParser::Of_var_listContext::LSqBracket() {
  return getToken(DapParser::LSqBracket, 0);
}

tree::TerminalNode* DapParser::Of_var_listContext::MUL() {
  return getToken(DapParser::MUL, 0);
}

tree::TerminalNode* DapParser::Of_var_listContext::RSqBracket() {
  return getToken(DapParser::RSqBracket, 0);
}


size_t DapParser::Of_var_listContext::getRuleIndex() const {
  return DapParser::RuleOf_var_list;
}

void DapParser::Of_var_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOf_var_list(this);
}

void DapParser::Of_var_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOf_var_list(this);
}


std::any DapParser::Of_var_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitOf_var_list(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Of_var_listContext* DapParser::of_var_list() {
  Of_var_listContext *_localctx = _tracker.createInstance<Of_var_listContext>(_ctx, getState());
  enterRule(_localctx, 14, DapParser::RuleOf_var_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(315);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(285);
      match(DapParser::T__3);

      setState(286);
      match(DapParser::Identifier);
      setState(287);
      match(DapParser::SUB);
      setState(288);
      match(DapParser::Identifier);
      setState(299);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(292);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == DapParser::COMMA) {
            setState(290);
            match(DapParser::COMMA);
            setState(291);
            match(DapParser::T__3);
          }

          setState(294);
          match(DapParser::Identifier);
          setState(295);
          match(DapParser::SUB);
          setState(296);
          match(DapParser::Identifier); 
        }
        setState(301);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(302);
      match(DapParser::T__3);
      setState(303);
      match(DapParser::Identifier);
      setState(307);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(304);
          match(DapParser::Identifier); 
        }
        setState(309);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(310);
      match(DapParser::T__3);
      setState(311);
      match(DapParser::Identifier);
      setState(312);
      match(DapParser::LSqBracket);
      setState(313);
      match(DapParser::MUL);
      setState(314);
      match(DapParser::RSqBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Identifiers_listContext ------------------------------------------------------------------

DapParser::Identifiers_listContext::Identifiers_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::Identifiers_listContext::Identifier() {
  return getTokens(DapParser::Identifier);
}

tree::TerminalNode* DapParser::Identifiers_listContext::Identifier(size_t i) {
  return getToken(DapParser::Identifier, i);
}

std::vector<tree::TerminalNode *> DapParser::Identifiers_listContext::SUB() {
  return getTokens(DapParser::SUB);
}

tree::TerminalNode* DapParser::Identifiers_listContext::SUB(size_t i) {
  return getToken(DapParser::SUB, i);
}


size_t DapParser::Identifiers_listContext::getRuleIndex() const {
  return DapParser::RuleIdentifiers_list;
}

void DapParser::Identifiers_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifiers_list(this);
}

void DapParser::Identifiers_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifiers_list(this);
}


std::any DapParser::Identifiers_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitIdentifiers_list(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Identifiers_listContext* DapParser::identifiers_list() {
  Identifiers_listContext *_localctx = _tracker.createInstance<Identifiers_listContext>(_ctx, getState());
  enterRule(_localctx, 16, DapParser::RuleIdentifiers_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(321); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(321);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
      case 1: {
        setState(317);
        match(DapParser::Identifier);
        break;
      }

      case 2: {
        setState(318);
        match(DapParser::Identifier);
        setState(319);
        match(DapParser::SUB);
        setState(320);
        match(DapParser::Identifier);
        break;
      }

      default:
        break;
      }
      setState(323); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == DapParser::Identifier);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- In_var_listContext ------------------------------------------------------------------

DapParser::In_var_listContext::In_var_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::In_var_listContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}

tree::TerminalNode* DapParser::In_var_listContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

tree::TerminalNode* DapParser::In_var_listContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

std::vector<DapParser::LiteralContext *> DapParser::In_var_listContext::literal() {
  return getRuleContexts<DapParser::LiteralContext>();
}

DapParser::LiteralContext* DapParser::In_var_listContext::literal(size_t i) {
  return getRuleContext<DapParser::LiteralContext>(i);
}

std::vector<DapParser::ColonIntsContext *> DapParser::In_var_listContext::colonInts() {
  return getRuleContexts<DapParser::ColonIntsContext>();
}

DapParser::ColonIntsContext* DapParser::In_var_listContext::colonInts(size_t i) {
  return getRuleContext<DapParser::ColonIntsContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::In_var_listContext::COMMA() {
  return getTokens(DapParser::COMMA);
}

tree::TerminalNode* DapParser::In_var_listContext::COMMA(size_t i) {
  return getToken(DapParser::COMMA, i);
}


size_t DapParser::In_var_listContext::getRuleIndex() const {
  return DapParser::RuleIn_var_list;
}

void DapParser::In_var_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIn_var_list(this);
}

void DapParser::In_var_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIn_var_list(this);
}


std::any DapParser::In_var_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitIn_var_list(this);
  else
    return visitor->visitChildren(this);
}

DapParser::In_var_listContext* DapParser::in_var_list() {
  In_var_listContext *_localctx = _tracker.createInstance<In_var_listContext>(_ctx, getState());
  enterRule(_localctx, 18, DapParser::RuleIn_var_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(343);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(325);
        match(DapParser::Identifier);
        break;
      }

      case DapParser::LParentheses: {
        enterOuterAlt(_localctx, 2);
        setState(326);
        match(DapParser::LParentheses);
        setState(329);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
        case 1: {
          setState(327);
          literal();
          break;
        }

        case 2: {
          setState(328);
          colonInts();
          break;
        }

        default:
          break;
        }
        setState(338);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == DapParser::COMMA) {
          setState(331);
          match(DapParser::COMMA);
          setState(334);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
          case 1: {
            setState(332);
            literal();
            break;
          }

          case 2: {
            setState(333);
            colonInts();
            break;
          }

          default:
            break;
          }
          setState(340);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(341);
        match(DapParser::RParentheses);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColonIntsContext ------------------------------------------------------------------

DapParser::ColonIntsContext::ColonIntsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::ColonIntsContext::INT() {
  return getTokens(DapParser::INT);
}

tree::TerminalNode* DapParser::ColonIntsContext::INT(size_t i) {
  return getToken(DapParser::INT, i);
}

tree::TerminalNode* DapParser::ColonIntsContext::COLON() {
  return getToken(DapParser::COLON, 0);
}


size_t DapParser::ColonIntsContext::getRuleIndex() const {
  return DapParser::RuleColonInts;
}

void DapParser::ColonIntsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColonInts(this);
}

void DapParser::ColonIntsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColonInts(this);
}


std::any DapParser::ColonIntsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitColonInts(this);
  else
    return visitor->visitChildren(this);
}

DapParser::ColonIntsContext* DapParser::colonInts() {
  ColonIntsContext *_localctx = _tracker.createInstance<ColonIntsContext>(_ctx, getState());
  enterRule(_localctx, 20, DapParser::RuleColonInts);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(345);
    match(DapParser::INT);
    setState(346);
    match(DapParser::COLON);
    setState(347);
    match(DapParser::INT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

DapParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::LiteralContext::INT() {
  return getToken(DapParser::INT, 0);
}

tree::TerminalNode* DapParser::LiteralContext::FloatingPointLiteral() {
  return getToken(DapParser::FloatingPointLiteral, 0);
}

tree::TerminalNode* DapParser::LiteralContext::STRINGLITERAL() {
  return getToken(DapParser::STRINGLITERAL, 0);
}

tree::TerminalNode* DapParser::LiteralContext::DateLiteral() {
  return getToken(DapParser::DateLiteral, 0);
}

tree::TerminalNode* DapParser::LiteralContext::TimeLiteral() {
  return getToken(DapParser::TimeLiteral, 0);
}

tree::TerminalNode* DapParser::LiteralContext::DateTimeLiteral() {
  return getToken(DapParser::DateTimeLiteral, 0);
}

tree::TerminalNode* DapParser::LiteralContext::BitLiteral() {
  return getToken(DapParser::BitLiteral, 0);
}

tree::TerminalNode* DapParser::LiteralContext::NameLiteral() {
  return getToken(DapParser::NameLiteral, 0);
}

tree::TerminalNode* DapParser::LiteralContext::HexLiteral() {
  return getToken(DapParser::HexLiteral, 0);
}

tree::TerminalNode* DapParser::LiteralContext::DOT() {
  return getToken(DapParser::DOT, 0);
}


size_t DapParser::LiteralContext::getRuleIndex() const {
  return DapParser::RuleLiteral;
}

void DapParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void DapParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}


std::any DapParser::LiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitLiteral(this);
  else
    return visitor->visitChildren(this);
}

DapParser::LiteralContext* DapParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 22, DapParser::RuleLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(349);
    _la = _input->LA(1);
    if (!(((((_la - 191) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 191)) & 1535) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariablesContext ------------------------------------------------------------------

DapParser::VariablesContext::VariablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::VariablesContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}

tree::TerminalNode* DapParser::VariablesContext::DATE() {
  return getToken(DapParser::DATE, 0);
}

tree::TerminalNode* DapParser::VariablesContext::ALTER() {
  return getToken(DapParser::ALTER, 0);
}

tree::TerminalNode* DapParser::VariablesContext::DROP() {
  return getToken(DapParser::DROP, 0);
}

std::vector<DapParser::VariablesContext *> DapParser::VariablesContext::variables() {
  return getRuleContexts<DapParser::VariablesContext>();
}

DapParser::VariablesContext* DapParser::VariablesContext::variables(size_t i) {
  return getRuleContext<DapParser::VariablesContext>(i);
}

tree::TerminalNode* DapParser::VariablesContext::DOT() {
  return getToken(DapParser::DOT, 0);
}


size_t DapParser::VariablesContext::getRuleIndex() const {
  return DapParser::RuleVariables;
}

void DapParser::VariablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariables(this);
}

void DapParser::VariablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariables(this);
}


std::any DapParser::VariablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitVariables(this);
  else
    return visitor->visitChildren(this);
}


DapParser::VariablesContext* DapParser::variables() {
   return variables(0);
}

DapParser::VariablesContext* DapParser::variables(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  DapParser::VariablesContext *_localctx = _tracker.createInstance<VariablesContext>(_ctx, parentState);
  DapParser::VariablesContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 24;
  enterRecursionRule(_localctx, 24, DapParser::RuleVariables, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(356);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::Identifier: {
        setState(352);
        match(DapParser::Identifier);
        break;
      }

      case DapParser::DATE: {
        setState(353);
        match(DapParser::DATE);
        break;
      }

      case DapParser::ALTER: {
        setState(354);
        match(DapParser::ALTER);
        break;
      }

      case DapParser::DROP: {
        setState(355);
        match(DapParser::DROP);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(363);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<VariablesContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleVariables);
        setState(358);

        if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
        setState(359);
        match(DapParser::DOT);
        setState(360);
        variables(6); 
      }
      setState(365);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Abort_mainContext ------------------------------------------------------------------

DapParser::Abort_mainContext::Abort_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Abort_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Abort_stmtContext *> DapParser::Abort_mainContext::abort_stmt() {
  return getRuleContexts<DapParser::Abort_stmtContext>();
}

DapParser::Abort_stmtContext* DapParser::Abort_mainContext::abort_stmt(size_t i) {
  return getRuleContext<DapParser::Abort_stmtContext>(i);
}


size_t DapParser::Abort_mainContext::getRuleIndex() const {
  return DapParser::RuleAbort_main;
}

void DapParser::Abort_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAbort_main(this);
}

void DapParser::Abort_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAbort_main(this);
}


std::any DapParser::Abort_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitAbort_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Abort_mainContext* DapParser::abort_main() {
  Abort_mainContext *_localctx = _tracker.createInstance<Abort_mainContext>(_ctx, getState());
  enterRule(_localctx, 26, DapParser::RuleAbort_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(369);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::ABORT) {
      setState(366);
      abort_stmt();
      setState(371);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(372);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Abort_stmtContext ------------------------------------------------------------------

DapParser::Abort_stmtContext::Abort_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Abort_stmtContext::ABORT() {
  return getToken(DapParser::ABORT, 0);
}

tree::TerminalNode* DapParser::Abort_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

tree::TerminalNode* DapParser::Abort_stmtContext::ABEND() {
  return getToken(DapParser::ABEND, 0);
}

tree::TerminalNode* DapParser::Abort_stmtContext::CANCEL() {
  return getToken(DapParser::CANCEL, 0);
}

tree::TerminalNode* DapParser::Abort_stmtContext::RETURN() {
  return getToken(DapParser::RETURN, 0);
}

tree::TerminalNode* DapParser::Abort_stmtContext::INT() {
  return getToken(DapParser::INT, 0);
}

tree::TerminalNode* DapParser::Abort_stmtContext::NOLIST() {
  return getToken(DapParser::NOLIST, 0);
}

DapParser::File_specContext* DapParser::Abort_stmtContext::file_spec() {
  return getRuleContext<DapParser::File_specContext>(0);
}


size_t DapParser::Abort_stmtContext::getRuleIndex() const {
  return DapParser::RuleAbort_stmt;
}

void DapParser::Abort_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAbort_stmt(this);
}

void DapParser::Abort_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAbort_stmt(this);
}


std::any DapParser::Abort_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitAbort_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Abort_stmtContext* DapParser::abort_stmt() {
  Abort_stmtContext *_localctx = _tracker.createInstance<Abort_stmtContext>(_ctx, getState());
  enterRule(_localctx, 28, DapParser::RuleAbort_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(374);
    match(DapParser::ABORT);
    setState(381);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::ABEND: {
        setState(375);
        match(DapParser::ABEND);
        break;
      }

      case DapParser::CANCEL: {
        setState(376);
        match(DapParser::CANCEL);
        setState(378);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == DapParser::STRINGLITERAL) {
          setState(377);
          file_spec();
        }
        break;
      }

      case DapParser::RETURN: {
        setState(380);
        match(DapParser::RETURN);
        break;
      }

      case DapParser::NOLIST:
      case DapParser::INT:
      case DapParser::SEMICOLON: {
        break;
      }

    default:
      break;
    }
    setState(384);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::INT) {
      setState(383);
      match(DapParser::INT);
    }
    setState(387);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::NOLIST) {
      setState(386);
      match(DapParser::NOLIST);
    }
    setState(389);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_specContext ------------------------------------------------------------------

DapParser::File_specContext::File_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::File_specContext::STRINGLITERAL() {
  return getToken(DapParser::STRINGLITERAL, 0);
}


size_t DapParser::File_specContext::getRuleIndex() const {
  return DapParser::RuleFile_spec;
}

void DapParser::File_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_spec(this);
}

void DapParser::File_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_spec(this);
}


std::any DapParser::File_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitFile_spec(this);
  else
    return visitor->visitChildren(this);
}

DapParser::File_specContext* DapParser::file_spec() {
  File_specContext *_localctx = _tracker.createInstance<File_specContext>(_ctx, getState());
  enterRule(_localctx, 30, DapParser::RuleFile_spec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(391);
    match(DapParser::STRINGLITERAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Proc_mainContext ------------------------------------------------------------------

DapParser::Proc_mainContext::Proc_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Proc_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Proc_stmtContext *> DapParser::Proc_mainContext::proc_stmt() {
  return getRuleContexts<DapParser::Proc_stmtContext>();
}

DapParser::Proc_stmtContext* DapParser::Proc_mainContext::proc_stmt(size_t i) {
  return getRuleContext<DapParser::Proc_stmtContext>(i);
}


size_t DapParser::Proc_mainContext::getRuleIndex() const {
  return DapParser::RuleProc_main;
}

void DapParser::Proc_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProc_main(this);
}

void DapParser::Proc_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProc_main(this);
}


std::any DapParser::Proc_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitProc_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Proc_mainContext* DapParser::proc_main() {
  Proc_mainContext *_localctx = _tracker.createInstance<Proc_mainContext>(_ctx, getState());
  enterRule(_localctx, 32, DapParser::RuleProc_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(396);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::PROC) {
      setState(393);
      proc_stmt();
      setState(398);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(399);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Proc_stmtContext ------------------------------------------------------------------

DapParser::Proc_stmtContext::Proc_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Proc_stmtContext::PROC() {
  return getToken(DapParser::PROC, 0);
}

DapParser::Proc_nameContext* DapParser::Proc_stmtContext::proc_name() {
  return getRuleContext<DapParser::Proc_nameContext>(0);
}

std::vector<tree::TerminalNode *> DapParser::Proc_stmtContext::SEMICOLON() {
  return getTokens(DapParser::SEMICOLON);
}

tree::TerminalNode* DapParser::Proc_stmtContext::SEMICOLON(size_t i) {
  return getToken(DapParser::SEMICOLON, i);
}


size_t DapParser::Proc_stmtContext::getRuleIndex() const {
  return DapParser::RuleProc_stmt;
}

void DapParser::Proc_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProc_stmt(this);
}

void DapParser::Proc_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProc_stmt(this);
}


std::any DapParser::Proc_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitProc_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Proc_stmtContext* DapParser::proc_stmt() {
  Proc_stmtContext *_localctx = _tracker.createInstance<Proc_stmtContext>(_ctx, getState());
  enterRule(_localctx, 34, DapParser::RuleProc_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(401);
    match(DapParser::PROC);
    setState(402);
    proc_name();
    setState(406);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(403);
        _la = _input->LA(1);
        if (_la == 0 || _la == Token::EOF || (_la == DapParser::SEMICOLON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(408);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx);
    }
    setState(409);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Proc_nameContext ------------------------------------------------------------------

DapParser::Proc_nameContext::Proc_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Proc_nameContext::ANOVA() {
  return getToken(DapParser::ANOVA, 0);
}

tree::TerminalNode* DapParser::Proc_nameContext::CORR() {
  return getToken(DapParser::CORR, 0);
}

tree::TerminalNode* DapParser::Proc_nameContext::MEANS() {
  return getToken(DapParser::MEANS, 0);
}

tree::TerminalNode* DapParser::Proc_nameContext::REG() {
  return getToken(DapParser::REG, 0);
}

tree::TerminalNode* DapParser::Proc_nameContext::SGPLOT() {
  return getToken(DapParser::SGPLOT, 0);
}

tree::TerminalNode* DapParser::Proc_nameContext::PRINT() {
  return getToken(DapParser::PRINT, 0);
}


size_t DapParser::Proc_nameContext::getRuleIndex() const {
  return DapParser::RuleProc_name;
}

void DapParser::Proc_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProc_name(this);
}

void DapParser::Proc_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProc_name(this);
}


std::any DapParser::Proc_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitProc_name(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Proc_nameContext* DapParser::proc_name() {
  Proc_nameContext *_localctx = _tracker.createInstance<Proc_nameContext>(_ctx, getState());
  enterRule(_localctx, 36, DapParser::RuleProc_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(411);
    _la = _input->LA(1);
    if (!(((((_la - 163) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 163)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_mainContext ------------------------------------------------------------------

DapParser::Array_mainContext::Array_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Array_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Array_stmtContext *> DapParser::Array_mainContext::array_stmt() {
  return getRuleContexts<DapParser::Array_stmtContext>();
}

DapParser::Array_stmtContext* DapParser::Array_mainContext::array_stmt(size_t i) {
  return getRuleContext<DapParser::Array_stmtContext>(i);
}


size_t DapParser::Array_mainContext::getRuleIndex() const {
  return DapParser::RuleArray_main;
}

void DapParser::Array_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_main(this);
}

void DapParser::Array_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_main(this);
}


std::any DapParser::Array_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitArray_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Array_mainContext* DapParser::array_main() {
  Array_mainContext *_localctx = _tracker.createInstance<Array_mainContext>(_ctx, getState());
  enterRule(_localctx, 38, DapParser::RuleArray_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(416);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::ARRAY) {
      setState(413);
      array_stmt();
      setState(418);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(419);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_stmtContext ------------------------------------------------------------------

DapParser::Array_stmtContext::Array_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Array_stmtContext::ARRAY() {
  return getToken(DapParser::ARRAY, 0);
}

DapParser::Array_nameContext* DapParser::Array_stmtContext::array_name() {
  return getRuleContext<DapParser::Array_nameContext>(0);
}

tree::TerminalNode* DapParser::Array_stmtContext::LBracket() {
  return getToken(DapParser::LBracket, 0);
}

DapParser::Array_subscriptContext* DapParser::Array_stmtContext::array_subscript() {
  return getRuleContext<DapParser::Array_subscriptContext>(0);
}

tree::TerminalNode* DapParser::Array_stmtContext::RBracket() {
  return getToken(DapParser::RBracket, 0);
}

tree::TerminalNode* DapParser::Array_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

tree::TerminalNode* DapParser::Array_stmtContext::DOLLAR() {
  return getToken(DapParser::DOLLAR, 0);
}

tree::TerminalNode* DapParser::Array_stmtContext::INT() {
  return getToken(DapParser::INT, 0);
}

DapParser::Array_elementsContext* DapParser::Array_stmtContext::array_elements() {
  return getRuleContext<DapParser::Array_elementsContext>(0);
}

DapParser::Initial_value_listContext* DapParser::Array_stmtContext::initial_value_list() {
  return getRuleContext<DapParser::Initial_value_listContext>(0);
}


size_t DapParser::Array_stmtContext::getRuleIndex() const {
  return DapParser::RuleArray_stmt;
}

void DapParser::Array_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_stmt(this);
}

void DapParser::Array_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_stmt(this);
}


std::any DapParser::Array_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitArray_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Array_stmtContext* DapParser::array_stmt() {
  Array_stmtContext *_localctx = _tracker.createInstance<Array_stmtContext>(_ctx, getState());
  enterRule(_localctx, 40, DapParser::RuleArray_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(421);
    match(DapParser::ARRAY);
    setState(422);
    array_name();
    setState(423);
    match(DapParser::LBracket);
    setState(424);
    array_subscript();
    setState(425);
    match(DapParser::RBracket);
    setState(427);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::DOLLAR) {
      setState(426);
      match(DapParser::DOLLAR);
    }
    setState(430);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::INT) {
      setState(429);
      match(DapParser::INT);
    }
    setState(433);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 108) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 108)) & 7) != 0) || _la == DapParser::Identifier) {
      setState(432);
      array_elements();
    }
    setState(436);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::LParentheses) {
      setState(435);
      initial_value_list();
    }
    setState(438);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_nameContext ------------------------------------------------------------------

DapParser::Array_nameContext::Array_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Array_nameContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}


size_t DapParser::Array_nameContext::getRuleIndex() const {
  return DapParser::RuleArray_name;
}

void DapParser::Array_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_name(this);
}

void DapParser::Array_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_name(this);
}


std::any DapParser::Array_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitArray_name(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Array_nameContext* DapParser::array_name() {
  Array_nameContext *_localctx = _tracker.createInstance<Array_nameContext>(_ctx, getState());
  enterRule(_localctx, 42, DapParser::RuleArray_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(440);
    match(DapParser::Identifier);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_subscriptContext ------------------------------------------------------------------

DapParser::Array_subscriptContext::Array_subscriptContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Array_subscriptContext::MUL() {
  return getToken(DapParser::MUL, 0);
}

std::vector<tree::TerminalNode *> DapParser::Array_subscriptContext::INT() {
  return getTokens(DapParser::INT);
}

tree::TerminalNode* DapParser::Array_subscriptContext::INT(size_t i) {
  return getToken(DapParser::INT, i);
}

std::vector<tree::TerminalNode *> DapParser::Array_subscriptContext::COMMA() {
  return getTokens(DapParser::COMMA);
}

tree::TerminalNode* DapParser::Array_subscriptContext::COMMA(size_t i) {
  return getToken(DapParser::COMMA, i);
}

std::vector<tree::TerminalNode *> DapParser::Array_subscriptContext::COLON() {
  return getTokens(DapParser::COLON);
}

tree::TerminalNode* DapParser::Array_subscriptContext::COLON(size_t i) {
  return getToken(DapParser::COLON, i);
}


size_t DapParser::Array_subscriptContext::getRuleIndex() const {
  return DapParser::RuleArray_subscript;
}

void DapParser::Array_subscriptContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_subscript(this);
}

void DapParser::Array_subscriptContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_subscript(this);
}


std::any DapParser::Array_subscriptContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitArray_subscript(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Array_subscriptContext* DapParser::array_subscript() {
  Array_subscriptContext *_localctx = _tracker.createInstance<Array_subscriptContext>(_ctx, getState());
  enterRule(_localctx, 44, DapParser::RuleArray_subscript);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(463);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(442);
      match(DapParser::MUL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(443);
      match(DapParser::INT);
      setState(448);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == DapParser::COMMA) {
        setState(444);
        match(DapParser::COMMA);
        setState(445);
        match(DapParser::INT);
        setState(450);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(451);
      match(DapParser::INT);
      setState(452);
      match(DapParser::COLON);
      setState(453);
      match(DapParser::INT);
      setState(460);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == DapParser::COMMA) {
        setState(454);
        match(DapParser::COMMA);
        setState(455);
        match(DapParser::INT);
        setState(456);
        match(DapParser::COLON);
        setState(457);
        match(DapParser::INT);
        setState(462);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_elementsContext ------------------------------------------------------------------

DapParser::Array_elementsContext::Array_elementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Array_elementsContext::ARRAY_NUMERIC_ELEMENTS() {
  return getToken(DapParser::ARRAY_NUMERIC_ELEMENTS, 0);
}

tree::TerminalNode* DapParser::Array_elementsContext::ARRAY_CHARACTER_ELEMENTS() {
  return getToken(DapParser::ARRAY_CHARACTER_ELEMENTS, 0);
}

tree::TerminalNode* DapParser::Array_elementsContext::ARRAY_ALL_ELEMENTS() {
  return getToken(DapParser::ARRAY_ALL_ELEMENTS, 0);
}

std::vector<tree::TerminalNode *> DapParser::Array_elementsContext::Identifier() {
  return getTokens(DapParser::Identifier);
}

tree::TerminalNode* DapParser::Array_elementsContext::Identifier(size_t i) {
  return getToken(DapParser::Identifier, i);
}

tree::TerminalNode* DapParser::Array_elementsContext::SUB() {
  return getToken(DapParser::SUB, 0);
}


size_t DapParser::Array_elementsContext::getRuleIndex() const {
  return DapParser::RuleArray_elements;
}

void DapParser::Array_elementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_elements(this);
}

void DapParser::Array_elementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_elements(this);
}


std::any DapParser::Array_elementsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitArray_elements(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Array_elementsContext* DapParser::array_elements() {
  Array_elementsContext *_localctx = _tracker.createInstance<Array_elementsContext>(_ctx, getState());
  enterRule(_localctx, 46, DapParser::RuleArray_elements);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(476);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(465);
      match(DapParser::ARRAY_NUMERIC_ELEMENTS);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(466);
      match(DapParser::ARRAY_CHARACTER_ELEMENTS);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(467);
      match(DapParser::ARRAY_ALL_ELEMENTS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(469); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(468);
        match(DapParser::Identifier);
        setState(471); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == DapParser::Identifier);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(473);
      match(DapParser::Identifier);
      setState(474);
      match(DapParser::SUB);
      setState(475);
      match(DapParser::Identifier);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initial_value_listContext ------------------------------------------------------------------

DapParser::Initial_value_listContext::Initial_value_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Initial_value_listContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

tree::TerminalNode* DapParser::Initial_value_listContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

std::vector<DapParser::Initial_value_list_itemContext *> DapParser::Initial_value_listContext::initial_value_list_item() {
  return getRuleContexts<DapParser::Initial_value_list_itemContext>();
}

DapParser::Initial_value_list_itemContext* DapParser::Initial_value_listContext::initial_value_list_item(size_t i) {
  return getRuleContext<DapParser::Initial_value_list_itemContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::Initial_value_listContext::COMMA() {
  return getTokens(DapParser::COMMA);
}

tree::TerminalNode* DapParser::Initial_value_listContext::COMMA(size_t i) {
  return getToken(DapParser::COMMA, i);
}


size_t DapParser::Initial_value_listContext::getRuleIndex() const {
  return DapParser::RuleInitial_value_list;
}

void DapParser::Initial_value_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitial_value_list(this);
}

void DapParser::Initial_value_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitial_value_list(this);
}


std::any DapParser::Initial_value_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInitial_value_list(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Initial_value_listContext* DapParser::initial_value_list() {
  Initial_value_listContext *_localctx = _tracker.createInstance<Initial_value_listContext>(_ctx, getState());
  enterRule(_localctx, 48, DapParser::RuleInitial_value_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(478);
    match(DapParser::LParentheses);

    setState(479);
    initial_value_list_item();
    setState(486);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 197) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 197)) & 135) != 0)) {
      setState(481);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::COMMA) {
        setState(480);
        match(DapParser::COMMA);
      }
      setState(483);
      initial_value_list_item();
      setState(488);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(489);
    match(DapParser::RParentheses);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initial_value_list_itemContext ------------------------------------------------------------------

DapParser::Initial_value_list_itemContext::Initial_value_list_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::Initial_value_list_itemContext::INT() {
  return getTokens(DapParser::INT);
}

tree::TerminalNode* DapParser::Initial_value_list_itemContext::INT(size_t i) {
  return getToken(DapParser::INT, i);
}

tree::TerminalNode* DapParser::Initial_value_list_itemContext::COLON() {
  return getToken(DapParser::COLON, 0);
}

DapParser::Constant_iter_valueContext* DapParser::Initial_value_list_itemContext::constant_iter_value() {
  return getRuleContext<DapParser::Constant_iter_valueContext>(0);
}

tree::TerminalNode* DapParser::Initial_value_list_itemContext::MUL() {
  return getToken(DapParser::MUL, 0);
}

DapParser::Initial_value_listContext* DapParser::Initial_value_list_itemContext::initial_value_list() {
  return getRuleContext<DapParser::Initial_value_listContext>(0);
}

DapParser::Constant_valueContext* DapParser::Initial_value_list_itemContext::constant_value() {
  return getRuleContext<DapParser::Constant_valueContext>(0);
}


size_t DapParser::Initial_value_list_itemContext::getRuleIndex() const {
  return DapParser::RuleInitial_value_list_item;
}

void DapParser::Initial_value_list_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitial_value_list_item(this);
}

void DapParser::Initial_value_list_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitial_value_list_item(this);
}


std::any DapParser::Initial_value_list_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInitial_value_list_item(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Initial_value_list_itemContext* DapParser::initial_value_list_item() {
  Initial_value_list_itemContext *_localctx = _tracker.createInstance<Initial_value_list_itemContext>(_ctx, getState());
  enterRule(_localctx, 50, DapParser::RuleInitial_value_list_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(503);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(491);
      match(DapParser::INT);
      setState(492);
      match(DapParser::COLON);
      setState(493);
      match(DapParser::INT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(494);
      constant_iter_value();
      setState(495);
      match(DapParser::MUL);
      setState(496);
      initial_value_list();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(498);
      constant_iter_value();
      setState(499);
      match(DapParser::MUL);
      setState(500);
      constant_value();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(502);
      constant_value();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initial_value_list_bkContext ------------------------------------------------------------------

DapParser::Initial_value_list_bkContext::Initial_value_list_bkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Initial_value_list_bkContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

tree::TerminalNode* DapParser::Initial_value_list_bkContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

std::vector<DapParser::Constant_valueContext *> DapParser::Initial_value_list_bkContext::constant_value() {
  return getRuleContexts<DapParser::Constant_valueContext>();
}

DapParser::Constant_valueContext* DapParser::Initial_value_list_bkContext::constant_value(size_t i) {
  return getRuleContext<DapParser::Constant_valueContext>(i);
}

std::vector<DapParser::Constant_iter_valueContext *> DapParser::Initial_value_list_bkContext::constant_iter_value() {
  return getRuleContexts<DapParser::Constant_iter_valueContext>();
}

DapParser::Constant_iter_valueContext* DapParser::Initial_value_list_bkContext::constant_iter_value(size_t i) {
  return getRuleContext<DapParser::Constant_iter_valueContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::Initial_value_list_bkContext::MUL() {
  return getTokens(DapParser::MUL);
}

tree::TerminalNode* DapParser::Initial_value_list_bkContext::MUL(size_t i) {
  return getToken(DapParser::MUL, i);
}

std::vector<DapParser::Initial_value_listContext *> DapParser::Initial_value_list_bkContext::initial_value_list() {
  return getRuleContexts<DapParser::Initial_value_listContext>();
}

DapParser::Initial_value_listContext* DapParser::Initial_value_list_bkContext::initial_value_list(size_t i) {
  return getRuleContext<DapParser::Initial_value_listContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::Initial_value_list_bkContext::COMMA() {
  return getTokens(DapParser::COMMA);
}

tree::TerminalNode* DapParser::Initial_value_list_bkContext::COMMA(size_t i) {
  return getToken(DapParser::COMMA, i);
}


size_t DapParser::Initial_value_list_bkContext::getRuleIndex() const {
  return DapParser::RuleInitial_value_list_bk;
}

void DapParser::Initial_value_list_bkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitial_value_list_bk(this);
}

void DapParser::Initial_value_list_bkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitial_value_list_bk(this);
}


std::any DapParser::Initial_value_list_bkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInitial_value_list_bk(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Initial_value_list_bkContext* DapParser::initial_value_list_bk() {
  Initial_value_list_bkContext *_localctx = _tracker.createInstance<Initial_value_list_bkContext>(_ctx, getState());
  enterRule(_localctx, 52, DapParser::RuleInitial_value_list_bk);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(505);
    match(DapParser::LParentheses);
    setState(515);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(506);
      constant_iter_value();
      setState(507);
      match(DapParser::MUL);
      setState(508);
      initial_value_list();
      break;
    }

    case 2: {
      setState(510);
      constant_iter_value();
      setState(511);
      match(DapParser::MUL);
      setState(512);
      constant_value();
      break;
    }

    case 3: {
      setState(514);
      constant_value();
      break;
    }

    default:
      break;
    }
    setState(533);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 197) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 197)) & 135) != 0)) {
      setState(518);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::COMMA) {
        setState(517);
        match(DapParser::COMMA);
      }
      setState(529);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
      case 1: {
        setState(520);
        constant_iter_value();
        setState(521);
        match(DapParser::MUL);
        setState(522);
        initial_value_list();
        break;
      }

      case 2: {
        setState(524);
        constant_iter_value();
        setState(525);
        match(DapParser::MUL);
        setState(526);
        constant_value();
        break;
      }

      case 3: {
        setState(528);
        constant_value();
        break;
      }

      default:
        break;
      }
      setState(535);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(536);
    match(DapParser::RParentheses);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_iter_valueContext ------------------------------------------------------------------

DapParser::Constant_iter_valueContext::Constant_iter_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Constant_iter_valueContext::INT() {
  return getToken(DapParser::INT, 0);
}


size_t DapParser::Constant_iter_valueContext::getRuleIndex() const {
  return DapParser::RuleConstant_iter_value;
}

void DapParser::Constant_iter_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_iter_value(this);
}

void DapParser::Constant_iter_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_iter_value(this);
}


std::any DapParser::Constant_iter_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitConstant_iter_value(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Constant_iter_valueContext* DapParser::constant_iter_value() {
  Constant_iter_valueContext *_localctx = _tracker.createInstance<Constant_iter_valueContext>(_ctx, getState());
  enterRule(_localctx, 54, DapParser::RuleConstant_iter_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(538);
    match(DapParser::INT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_valueContext ------------------------------------------------------------------

DapParser::Constant_valueContext::Constant_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Constant_valueContext::INT() {
  return getToken(DapParser::INT, 0);
}

tree::TerminalNode* DapParser::Constant_valueContext::FloatingPointLiteral() {
  return getToken(DapParser::FloatingPointLiteral, 0);
}

tree::TerminalNode* DapParser::Constant_valueContext::STRINGLITERAL() {
  return getToken(DapParser::STRINGLITERAL, 0);
}


size_t DapParser::Constant_valueContext::getRuleIndex() const {
  return DapParser::RuleConstant_value;
}

void DapParser::Constant_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_value(this);
}

void DapParser::Constant_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_value(this);
}


std::any DapParser::Constant_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitConstant_value(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Constant_valueContext* DapParser::constant_value() {
  Constant_valueContext *_localctx = _tracker.createInstance<Constant_valueContext>(_ctx, getState());
  enterRule(_localctx, 56, DapParser::RuleConstant_value);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(540);
    _la = _input->LA(1);
    if (!(((((_la - 197) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 197)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assign_mainContext ------------------------------------------------------------------

DapParser::Assign_mainContext::Assign_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Assign_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Assign_stmtContext *> DapParser::Assign_mainContext::assign_stmt() {
  return getRuleContexts<DapParser::Assign_stmtContext>();
}

DapParser::Assign_stmtContext* DapParser::Assign_mainContext::assign_stmt(size_t i) {
  return getRuleContext<DapParser::Assign_stmtContext>(i);
}


size_t DapParser::Assign_mainContext::getRuleIndex() const {
  return DapParser::RuleAssign_main;
}

void DapParser::Assign_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssign_main(this);
}

void DapParser::Assign_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssign_main(this);
}


std::any DapParser::Assign_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitAssign_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Assign_mainContext* DapParser::assign_main() {
  Assign_mainContext *_localctx = _tracker.createInstance<Assign_mainContext>(_ctx, getState());
  enterRule(_localctx, 58, DapParser::RuleAssign_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(545);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::Identifier) {
      setState(542);
      assign_stmt();
      setState(547);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(548);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assign_stmtContext ------------------------------------------------------------------

DapParser::Assign_stmtContext::Assign_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Assign_stmtContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}

tree::TerminalNode* DapParser::Assign_stmtContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

DapParser::ExpressionContext* DapParser::Assign_stmtContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::Assign_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}


size_t DapParser::Assign_stmtContext::getRuleIndex() const {
  return DapParser::RuleAssign_stmt;
}

void DapParser::Assign_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssign_stmt(this);
}

void DapParser::Assign_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssign_stmt(this);
}


std::any DapParser::Assign_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitAssign_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Assign_stmtContext* DapParser::assign_stmt() {
  Assign_stmtContext *_localctx = _tracker.createInstance<Assign_stmtContext>(_ctx, getState());
  enterRule(_localctx, 60, DapParser::RuleAssign_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(550);
    match(DapParser::Identifier);
    setState(551);
    match(DapParser::EQUAL);
    setState(552);
    expression(0);
    setState(553);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- By_mainContext ------------------------------------------------------------------

DapParser::By_mainContext::By_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::By_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::By_stmtContext *> DapParser::By_mainContext::by_stmt() {
  return getRuleContexts<DapParser::By_stmtContext>();
}

DapParser::By_stmtContext* DapParser::By_mainContext::by_stmt(size_t i) {
  return getRuleContext<DapParser::By_stmtContext>(i);
}


size_t DapParser::By_mainContext::getRuleIndex() const {
  return DapParser::RuleBy_main;
}

void DapParser::By_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBy_main(this);
}

void DapParser::By_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBy_main(this);
}


std::any DapParser::By_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitBy_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::By_mainContext* DapParser::by_main() {
  By_mainContext *_localctx = _tracker.createInstance<By_mainContext>(_ctx, getState());
  enterRule(_localctx, 62, DapParser::RuleBy_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(558);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::BY) {
      setState(555);
      by_stmt();
      setState(560);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(561);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- By_stmtContext ------------------------------------------------------------------

DapParser::By_stmtContext::By_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::By_stmtContext::BY() {
  return getToken(DapParser::BY, 0);
}

tree::TerminalNode* DapParser::By_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

std::vector<tree::TerminalNode *> DapParser::By_stmtContext::Identifier() {
  return getTokens(DapParser::Identifier);
}

tree::TerminalNode* DapParser::By_stmtContext::Identifier(size_t i) {
  return getToken(DapParser::Identifier, i);
}

tree::TerminalNode* DapParser::By_stmtContext::NOTSORTED() {
  return getToken(DapParser::NOTSORTED, 0);
}

tree::TerminalNode* DapParser::By_stmtContext::GROUPFORMAT() {
  return getToken(DapParser::GROUPFORMAT, 0);
}

std::vector<tree::TerminalNode *> DapParser::By_stmtContext::DESCENDING() {
  return getTokens(DapParser::DESCENDING);
}

tree::TerminalNode* DapParser::By_stmtContext::DESCENDING(size_t i) {
  return getToken(DapParser::DESCENDING, i);
}


size_t DapParser::By_stmtContext::getRuleIndex() const {
  return DapParser::RuleBy_stmt;
}

void DapParser::By_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBy_stmt(this);
}

void DapParser::By_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBy_stmt(this);
}


std::any DapParser::By_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitBy_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::By_stmtContext* DapParser::by_stmt() {
  By_stmtContext *_localctx = _tracker.createInstance<By_stmtContext>(_ctx, getState());
  enterRule(_localctx, 64, DapParser::RuleBy_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(563);
    match(DapParser::BY);

    setState(565);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::DESCENDING) {
      setState(564);
      match(DapParser::DESCENDING);
    }
    setState(567);
    match(DapParser::Identifier);
    setState(575);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::DESCENDING || _la == DapParser::Identifier) {
      setState(570);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::DESCENDING) {
        setState(569);
        match(DapParser::DESCENDING);
      }
      setState(572);
      match(DapParser::Identifier);
      setState(577);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(579);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::NOTSORTED) {
      setState(578);
      match(DapParser::NOTSORTED);
    }
    setState(582);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::GROUPFORMAT) {
      setState(581);
      match(DapParser::GROUPFORMAT);
    }
    setState(584);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_mainContext ------------------------------------------------------------------

DapParser::Call_mainContext::Call_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Call_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Call_stmtContext *> DapParser::Call_mainContext::call_stmt() {
  return getRuleContexts<DapParser::Call_stmtContext>();
}

DapParser::Call_stmtContext* DapParser::Call_mainContext::call_stmt(size_t i) {
  return getRuleContext<DapParser::Call_stmtContext>(i);
}


size_t DapParser::Call_mainContext::getRuleIndex() const {
  return DapParser::RuleCall_main;
}

void DapParser::Call_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_main(this);
}

void DapParser::Call_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_main(this);
}


std::any DapParser::Call_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitCall_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Call_mainContext* DapParser::call_main() {
  Call_mainContext *_localctx = _tracker.createInstance<Call_mainContext>(_ctx, getState());
  enterRule(_localctx, 66, DapParser::RuleCall_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(589);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::CALL) {
      setState(586);
      call_stmt();
      setState(591);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(592);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_stmtContext ------------------------------------------------------------------

DapParser::Call_stmtContext::Call_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Call_stmtContext::CALL() {
  return getToken(DapParser::CALL, 0);
}

DapParser::ExpressionContext* DapParser::Call_stmtContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::Call_stmtContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

tree::TerminalNode* DapParser::Call_stmtContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

tree::TerminalNode* DapParser::Call_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

DapParser::ExpressionListContext* DapParser::Call_stmtContext::expressionList() {
  return getRuleContext<DapParser::ExpressionListContext>(0);
}


size_t DapParser::Call_stmtContext::getRuleIndex() const {
  return DapParser::RuleCall_stmt;
}

void DapParser::Call_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_stmt(this);
}

void DapParser::Call_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_stmt(this);
}


std::any DapParser::Call_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitCall_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Call_stmtContext* DapParser::call_stmt() {
  Call_stmtContext *_localctx = _tracker.createInstance<Call_stmtContext>(_ctx, getState());
  enterRule(_localctx, 68, DapParser::RuleCall_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(594);
    match(DapParser::CALL);
    setState(595);
    expression(0);
    setState(596);
    match(DapParser::LParentheses);
    setState(598);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::T__3 || ((((_la - 188) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 188)) & 8992604153) != 0)) {
      setState(597);
      expressionList(0);
    }
    setState(600);
    match(DapParser::RParentheses);
    setState(601);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_mainContext ------------------------------------------------------------------

DapParser::Data_mainContext::Data_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Data_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Data_stmtContext *> DapParser::Data_mainContext::data_stmt() {
  return getRuleContexts<DapParser::Data_stmtContext>();
}

DapParser::Data_stmtContext* DapParser::Data_mainContext::data_stmt(size_t i) {
  return getRuleContext<DapParser::Data_stmtContext>(i);
}


size_t DapParser::Data_mainContext::getRuleIndex() const {
  return DapParser::RuleData_main;
}

void DapParser::Data_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterData_main(this);
}

void DapParser::Data_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitData_main(this);
}


std::any DapParser::Data_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitData_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Data_mainContext* DapParser::data_main() {
  Data_mainContext *_localctx = _tracker.createInstance<Data_mainContext>(_ctx, getState());
  enterRule(_localctx, 70, DapParser::RuleData_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(606);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::DATA) {
      setState(603);
      data_stmt();
      setState(608);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(609);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_stmtContext ------------------------------------------------------------------

DapParser::Data_stmtContext::Data_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Data_stmtContext::DATA() {
  return getToken(DapParser::DATA, 0);
}

tree::TerminalNode* DapParser::Data_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

tree::TerminalNode* DapParser::Data_stmtContext::Tk_NULL() {
  return getToken(DapParser::Tk_NULL, 0);
}

DapParser::Datastmt_cmdContext* DapParser::Data_stmtContext::datastmt_cmd() {
  return getRuleContext<DapParser::Datastmt_cmdContext>(0);
}

tree::TerminalNode* DapParser::Data_stmtContext::NOLIST() {
  return getToken(DapParser::NOLIST, 0);
}

std::vector<DapParser::Dataset_name_optContext *> DapParser::Data_stmtContext::dataset_name_opt() {
  return getRuleContexts<DapParser::Dataset_name_optContext>();
}

DapParser::Dataset_name_optContext* DapParser::Data_stmtContext::dataset_name_opt(size_t i) {
  return getRuleContext<DapParser::Dataset_name_optContext>(i);
}

tree::TerminalNode* DapParser::Data_stmtContext::DIV() {
  return getToken(DapParser::DIV, 0);
}

tree::TerminalNode* DapParser::Data_stmtContext::VIEW() {
  return getToken(DapParser::VIEW, 0);
}

tree::TerminalNode* DapParser::Data_stmtContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

DapParser::View_nameContext* DapParser::Data_stmtContext::view_name() {
  return getRuleContext<DapParser::View_nameContext>(0);
}

std::vector<DapParser::View_dsname_optContext *> DapParser::Data_stmtContext::view_dsname_opt() {
  return getRuleContexts<DapParser::View_dsname_optContext>();
}

DapParser::View_dsname_optContext* DapParser::Data_stmtContext::view_dsname_opt(size_t i) {
  return getRuleContext<DapParser::View_dsname_optContext>(i);
}

DapParser::Passwd_optContext* DapParser::Data_stmtContext::passwd_opt() {
  return getRuleContext<DapParser::Passwd_optContext>(0);
}

DapParser::Source_optContext* DapParser::Data_stmtContext::source_opt() {
  return getRuleContext<DapParser::Source_optContext>(0);
}

tree::TerminalNode* DapParser::Data_stmtContext::NESTING() {
  return getToken(DapParser::NESTING, 0);
}

DapParser::Dataset_nameContext* DapParser::Data_stmtContext::dataset_name() {
  return getRuleContext<DapParser::Dataset_nameContext>(0);
}

tree::TerminalNode* DapParser::Data_stmtContext::PGM() {
  return getToken(DapParser::PGM, 0);
}

DapParser::Program_nameContext* DapParser::Data_stmtContext::program_name() {
  return getRuleContext<DapParser::Program_nameContext>(0);
}


size_t DapParser::Data_stmtContext::getRuleIndex() const {
  return DapParser::RuleData_stmt;
}

void DapParser::Data_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterData_stmt(this);
}

void DapParser::Data_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitData_stmt(this);
}


std::any DapParser::Data_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitData_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Data_stmtContext* DapParser::data_stmt() {
  Data_stmtContext *_localctx = _tracker.createInstance<Data_stmtContext>(_ctx, getState());
  enterRule(_localctx, 72, DapParser::RuleData_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(704);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(611);
      match(DapParser::DATA);
      setState(612);
      match(DapParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(613);
      match(DapParser::DATA);
      setState(614);
      match(DapParser::Tk_NULL);
      setState(616);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::DIV) {
        setState(615);
        datastmt_cmd();
      }
      setState(619);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NOLIST) {
        setState(618);
        match(DapParser::NOLIST);
      }
      setState(621);
      match(DapParser::SEMICOLON);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(622);
      match(DapParser::DATA);
      setState(624); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(623);
        dataset_name_opt();
        setState(626); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (((((_la - 132) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 132)) & 553648129) != 0) || _la == DapParser::Identifier);
      setState(629);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::DIV) {
        setState(628);
        datastmt_cmd();
      }
      setState(632);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NOLIST) {
        setState(631);
        match(DapParser::NOLIST);
      }
      setState(634);
      match(DapParser::SEMICOLON);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(636);
      match(DapParser::DATA);
      setState(638); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(637);
        view_dsname_opt();
        setState(640); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (((((_la - 132) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 132)) & 553648129) != 0) || _la == DapParser::Identifier);
      setState(642);
      match(DapParser::DIV);
      setState(643);
      match(DapParser::VIEW);
      setState(644);
      match(DapParser::EQUAL);
      setState(645);
      view_name();
      setState(647);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
      case 1: {
        setState(646);
        passwd_opt();
        break;
      }

      default:
        break;
      }
      setState(650);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::LParentheses) {
        setState(649);
        source_opt();
      }
      setState(653);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NESTING) {
        setState(652);
        match(DapParser::NESTING);
      }
      setState(656);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NOLIST) {
        setState(655);
        match(DapParser::NOLIST);
      }
      setState(658);
      match(DapParser::SEMICOLON);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(660);
      match(DapParser::DATA);
      setState(661);
      dataset_name();
      setState(662);
      match(DapParser::DIV);
      setState(663);
      match(DapParser::PGM);
      setState(664);
      match(DapParser::EQUAL);
      setState(665);
      program_name();
      setState(667);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
      case 1: {
        setState(666);
        passwd_opt();
        break;
      }

      default:
        break;
      }
      setState(670);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::LParentheses) {
        setState(669);
        source_opt();
      }
      setState(673);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NESTING) {
        setState(672);
        match(DapParser::NESTING);
      }
      setState(676);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NOLIST) {
        setState(675);
        match(DapParser::NOLIST);
      }
      setState(678);
      match(DapParser::SEMICOLON);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(680);
      match(DapParser::DATA);
      setState(681);
      match(DapParser::VIEW);
      setState(682);
      match(DapParser::EQUAL);
      setState(683);
      view_name();
      setState(685);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::LParentheses) {
        setState(684);
        passwd_opt();
      }
      setState(688);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NOLIST) {
        setState(687);
        match(DapParser::NOLIST);
      }
      setState(690);
      match(DapParser::SEMICOLON);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(692);
      match(DapParser::DATA);
      setState(693);
      match(DapParser::PGM);
      setState(694);
      match(DapParser::EQUAL);
      setState(695);
      program_name();
      setState(697);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::LParentheses) {
        setState(696);
        passwd_opt();
      }
      setState(700);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::NOLIST) {
        setState(699);
        match(DapParser::NOLIST);
      }
      setState(702);
      match(DapParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dataset_name_optContext ------------------------------------------------------------------

DapParser::Dataset_name_optContext::Dataset_name_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::Dataset_nameContext* DapParser::Dataset_name_optContext::dataset_name() {
  return getRuleContext<DapParser::Dataset_nameContext>(0);
}

std::vector<tree::TerminalNode *> DapParser::Dataset_name_optContext::LParentheses() {
  return getTokens(DapParser::LParentheses);
}

tree::TerminalNode* DapParser::Dataset_name_optContext::LParentheses(size_t i) {
  return getToken(DapParser::LParentheses, i);
}

DapParser::VariablesContext* DapParser::Dataset_name_optContext::variables() {
  return getRuleContext<DapParser::VariablesContext>(0);
}

tree::TerminalNode* DapParser::Dataset_name_optContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

std::vector<tree::TerminalNode *> DapParser::Dataset_name_optContext::RParentheses() {
  return getTokens(DapParser::RParentheses);
}

tree::TerminalNode* DapParser::Dataset_name_optContext::RParentheses(size_t i) {
  return getToken(DapParser::RParentheses, i);
}


size_t DapParser::Dataset_name_optContext::getRuleIndex() const {
  return DapParser::RuleDataset_name_opt;
}

void DapParser::Dataset_name_optContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataset_name_opt(this);
}

void DapParser::Dataset_name_optContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataset_name_opt(this);
}


std::any DapParser::Dataset_name_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDataset_name_opt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Dataset_name_optContext* DapParser::dataset_name_opt() {
  Dataset_name_optContext *_localctx = _tracker.createInstance<Dataset_name_optContext>(_ctx, getState());
  enterRule(_localctx, 74, DapParser::RuleDataset_name_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(706);
    dataset_name();
    setState(718);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::LParentheses) {
      setState(707);
      match(DapParser::LParentheses);
      setState(708);
      variables(0);
      setState(709);
      match(DapParser::EQUAL);
      setState(713);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
      while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1 + 1) {
          setState(710);
          _la = _input->LA(1);
          if (_la == 0 || _la == Token::EOF || (_la == DapParser::LParentheses

          || _la == DapParser::RParentheses)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          } 
        }
        setState(715);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
      }
      setState(716);
      match(DapParser::RParentheses);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Datastmt_cmdContext ------------------------------------------------------------------

DapParser::Datastmt_cmdContext::Datastmt_cmdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Datastmt_cmdContext::DIV() {
  return getToken(DapParser::DIV, 0);
}

tree::TerminalNode* DapParser::Datastmt_cmdContext::DEBUG() {
  return getToken(DapParser::DEBUG, 0);
}

tree::TerminalNode* DapParser::Datastmt_cmdContext::NESTING() {
  return getToken(DapParser::NESTING, 0);
}

tree::TerminalNode* DapParser::Datastmt_cmdContext::STACK() {
  return getToken(DapParser::STACK, 0);
}

tree::TerminalNode* DapParser::Datastmt_cmdContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

tree::TerminalNode* DapParser::Datastmt_cmdContext::INT() {
  return getToken(DapParser::INT, 0);
}


size_t DapParser::Datastmt_cmdContext::getRuleIndex() const {
  return DapParser::RuleDatastmt_cmd;
}

void DapParser::Datastmt_cmdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatastmt_cmd(this);
}

void DapParser::Datastmt_cmdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatastmt_cmd(this);
}


std::any DapParser::Datastmt_cmdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDatastmt_cmd(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Datastmt_cmdContext* DapParser::datastmt_cmd() {
  Datastmt_cmdContext *_localctx = _tracker.createInstance<Datastmt_cmdContext>(_ctx, getState());
  enterRule(_localctx, 76, DapParser::RuleDatastmt_cmd);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(720);
    match(DapParser::DIV);
    setState(722);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::DEBUG) {
      setState(721);
      match(DapParser::DEBUG);
    }
    setState(725);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::NESTING) {
      setState(724);
      match(DapParser::NESTING);
    }
    setState(730);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::STACK) {
      setState(727);
      match(DapParser::STACK);
      setState(728);
      match(DapParser::EQUAL);
      setState(729);
      match(DapParser::INT);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- View_dsname_optContext ------------------------------------------------------------------

DapParser::View_dsname_optContext::View_dsname_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<DapParser::VariablesContext *> DapParser::View_dsname_optContext::variables() {
  return getRuleContexts<DapParser::VariablesContext>();
}

DapParser::VariablesContext* DapParser::View_dsname_optContext::variables(size_t i) {
  return getRuleContext<DapParser::VariablesContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::View_dsname_optContext::LParentheses() {
  return getTokens(DapParser::LParentheses);
}

tree::TerminalNode* DapParser::View_dsname_optContext::LParentheses(size_t i) {
  return getToken(DapParser::LParentheses, i);
}

tree::TerminalNode* DapParser::View_dsname_optContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

std::vector<tree::TerminalNode *> DapParser::View_dsname_optContext::RParentheses() {
  return getTokens(DapParser::RParentheses);
}

tree::TerminalNode* DapParser::View_dsname_optContext::RParentheses(size_t i) {
  return getToken(DapParser::RParentheses, i);
}


size_t DapParser::View_dsname_optContext::getRuleIndex() const {
  return DapParser::RuleView_dsname_opt;
}

void DapParser::View_dsname_optContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterView_dsname_opt(this);
}

void DapParser::View_dsname_optContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitView_dsname_opt(this);
}


std::any DapParser::View_dsname_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitView_dsname_opt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::View_dsname_optContext* DapParser::view_dsname_opt() {
  View_dsname_optContext *_localctx = _tracker.createInstance<View_dsname_optContext>(_ctx, getState());
  enterRule(_localctx, 78, DapParser::RuleView_dsname_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(732);
    variables(0);
    setState(734);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      setState(733);
      variables(0);
      break;
    }

    default:
      break;
    }
    setState(747);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::LParentheses) {
      setState(736);
      match(DapParser::LParentheses);
      setState(737);
      variables(0);
      setState(738);
      match(DapParser::EQUAL);
      setState(742);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx);
      while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1 + 1) {
          setState(739);
          _la = _input->LA(1);
          if (_la == 0 || _la == Token::EOF || (_la == DapParser::LParentheses

          || _la == DapParser::RParentheses)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          } 
        }
        setState(744);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx);
      }
      setState(745);
      match(DapParser::RParentheses);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- View_nameContext ------------------------------------------------------------------

DapParser::View_nameContext::View_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::VariablesContext* DapParser::View_nameContext::variables() {
  return getRuleContext<DapParser::VariablesContext>(0);
}


size_t DapParser::View_nameContext::getRuleIndex() const {
  return DapParser::RuleView_name;
}

void DapParser::View_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterView_name(this);
}

void DapParser::View_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitView_name(this);
}


std::any DapParser::View_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitView_name(this);
  else
    return visitor->visitChildren(this);
}

DapParser::View_nameContext* DapParser::view_name() {
  View_nameContext *_localctx = _tracker.createInstance<View_nameContext>(_ctx, getState());
  enterRule(_localctx, 80, DapParser::RuleView_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(749);
    variables(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dataset_nameContext ------------------------------------------------------------------

DapParser::Dataset_nameContext::Dataset_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::VariablesContext* DapParser::Dataset_nameContext::variables() {
  return getRuleContext<DapParser::VariablesContext>(0);
}


size_t DapParser::Dataset_nameContext::getRuleIndex() const {
  return DapParser::RuleDataset_name;
}

void DapParser::Dataset_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataset_name(this);
}

void DapParser::Dataset_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataset_name(this);
}


std::any DapParser::Dataset_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDataset_name(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Dataset_nameContext* DapParser::dataset_name() {
  Dataset_nameContext *_localctx = _tracker.createInstance<Dataset_nameContext>(_ctx, getState());
  enterRule(_localctx, 82, DapParser::RuleDataset_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(751);
    variables(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Program_nameContext ------------------------------------------------------------------

DapParser::Program_nameContext::Program_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::VariablesContext* DapParser::Program_nameContext::variables() {
  return getRuleContext<DapParser::VariablesContext>(0);
}


size_t DapParser::Program_nameContext::getRuleIndex() const {
  return DapParser::RuleProgram_name;
}

void DapParser::Program_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProgram_name(this);
}

void DapParser::Program_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProgram_name(this);
}


std::any DapParser::Program_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitProgram_name(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Program_nameContext* DapParser::program_name() {
  Program_nameContext *_localctx = _tracker.createInstance<Program_nameContext>(_ctx, getState());
  enterRule(_localctx, 84, DapParser::RuleProgram_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(753);
    variables(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Passwd_optContext ------------------------------------------------------------------

DapParser::Passwd_optContext::Passwd_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::Passwd_optContext::LParentheses() {
  return getTokens(DapParser::LParentheses);
}

tree::TerminalNode* DapParser::Passwd_optContext::LParentheses(size_t i) {
  return getToken(DapParser::LParentheses, i);
}

tree::TerminalNode* DapParser::Passwd_optContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

std::vector<tree::TerminalNode *> DapParser::Passwd_optContext::RParentheses() {
  return getTokens(DapParser::RParentheses);
}

tree::TerminalNode* DapParser::Passwd_optContext::RParentheses(size_t i) {
  return getToken(DapParser::RParentheses, i);
}

tree::TerminalNode* DapParser::Passwd_optContext::ALTER() {
  return getToken(DapParser::ALTER, 0);
}

tree::TerminalNode* DapParser::Passwd_optContext::READ() {
  return getToken(DapParser::READ, 0);
}

tree::TerminalNode* DapParser::Passwd_optContext::PW() {
  return getToken(DapParser::PW, 0);
}


size_t DapParser::Passwd_optContext::getRuleIndex() const {
  return DapParser::RulePasswd_opt;
}

void DapParser::Passwd_optContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPasswd_opt(this);
}

void DapParser::Passwd_optContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPasswd_opt(this);
}


std::any DapParser::Passwd_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitPasswd_opt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Passwd_optContext* DapParser::passwd_opt() {
  Passwd_optContext *_localctx = _tracker.createInstance<Passwd_optContext>(_ctx, getState());
  enterRule(_localctx, 86, DapParser::RulePasswd_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(755);
    match(DapParser::LParentheses);
    setState(756);
    _la = _input->LA(1);
    if (!(((((_la - 118) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 118)) & 16387) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(757);
    match(DapParser::EQUAL);
    setState(761);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(758);
        _la = _input->LA(1);
        if (_la == 0 || _la == Token::EOF || (_la == DapParser::LParentheses

        || _la == DapParser::RParentheses)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(763);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx);
    }
    setState(764);
    match(DapParser::RParentheses);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Source_optContext ------------------------------------------------------------------

DapParser::Source_optContext::Source_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Source_optContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

tree::TerminalNode* DapParser::Source_optContext::SOURCE() {
  return getToken(DapParser::SOURCE, 0);
}

tree::TerminalNode* DapParser::Source_optContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

tree::TerminalNode* DapParser::Source_optContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

tree::TerminalNode* DapParser::Source_optContext::SAVE() {
  return getToken(DapParser::SAVE, 0);
}

tree::TerminalNode* DapParser::Source_optContext::ENCRYPT() {
  return getToken(DapParser::ENCRYPT, 0);
}

tree::TerminalNode* DapParser::Source_optContext::NOSAVE() {
  return getToken(DapParser::NOSAVE, 0);
}


size_t DapParser::Source_optContext::getRuleIndex() const {
  return DapParser::RuleSource_opt;
}

void DapParser::Source_optContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSource_opt(this);
}

void DapParser::Source_optContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSource_opt(this);
}


std::any DapParser::Source_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitSource_opt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Source_optContext* DapParser::source_opt() {
  Source_optContext *_localctx = _tracker.createInstance<Source_optContext>(_ctx, getState());
  enterRule(_localctx, 88, DapParser::RuleSource_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(766);
    match(DapParser::LParentheses);
    setState(767);
    match(DapParser::SOURCE);
    setState(768);
    match(DapParser::EQUAL);
    setState(769);
    _la = _input->LA(1);
    if (!(_la == DapParser::SAVE || _la == DapParser::ENCRYPT

    || _la == DapParser::NOSAVE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(770);
    match(DapParser::RParentheses);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Datalines_mainContext ------------------------------------------------------------------

DapParser::Datalines_mainContext::Datalines_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Datalines_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Datalines_stmtContext *> DapParser::Datalines_mainContext::datalines_stmt() {
  return getRuleContexts<DapParser::Datalines_stmtContext>();
}

DapParser::Datalines_stmtContext* DapParser::Datalines_mainContext::datalines_stmt(size_t i) {
  return getRuleContext<DapParser::Datalines_stmtContext>(i);
}

std::vector<DapParser::Datalines4_stmtContext *> DapParser::Datalines_mainContext::datalines4_stmt() {
  return getRuleContexts<DapParser::Datalines4_stmtContext>();
}

DapParser::Datalines4_stmtContext* DapParser::Datalines_mainContext::datalines4_stmt(size_t i) {
  return getRuleContext<DapParser::Datalines4_stmtContext>(i);
}


size_t DapParser::Datalines_mainContext::getRuleIndex() const {
  return DapParser::RuleDatalines_main;
}

void DapParser::Datalines_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatalines_main(this);
}

void DapParser::Datalines_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatalines_main(this);
}


std::any DapParser::Datalines_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDatalines_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Datalines_mainContext* DapParser::datalines_main() {
  Datalines_mainContext *_localctx = _tracker.createInstance<Datalines_mainContext>(_ctx, getState());
  enterRule(_localctx, 90, DapParser::RuleDatalines_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(776);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 125) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 125)) & 27) != 0)) {
      setState(774);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case DapParser::DATALINES:
        case DapParser::CARDS: {
          setState(772);
          datalines_stmt();
          break;
        }

        case DapParser::DATALINES4:
        case DapParser::CARDS4: {
          setState(773);
          datalines4_stmt();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(778);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(779);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Datalines_stmtContext ------------------------------------------------------------------

DapParser::Datalines_stmtContext::Datalines_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::Datalines_stmtContext::SEMICOLON() {
  return getTokens(DapParser::SEMICOLON);
}

tree::TerminalNode* DapParser::Datalines_stmtContext::SEMICOLON(size_t i) {
  return getToken(DapParser::SEMICOLON, i);
}

tree::TerminalNode* DapParser::Datalines_stmtContext::DATALINES() {
  return getToken(DapParser::DATALINES, 0);
}

tree::TerminalNode* DapParser::Datalines_stmtContext::CARDS() {
  return getToken(DapParser::CARDS, 0);
}


size_t DapParser::Datalines_stmtContext::getRuleIndex() const {
  return DapParser::RuleDatalines_stmt;
}

void DapParser::Datalines_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatalines_stmt(this);
}

void DapParser::Datalines_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatalines_stmt(this);
}


std::any DapParser::Datalines_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDatalines_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Datalines_stmtContext* DapParser::datalines_stmt() {
  Datalines_stmtContext *_localctx = _tracker.createInstance<Datalines_stmtContext>(_ctx, getState());
  enterRule(_localctx, 92, DapParser::RuleDatalines_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(781);
    _la = _input->LA(1);
    if (!(_la == DapParser::DATALINES

    || _la == DapParser::CARDS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(782);
    match(DapParser::SEMICOLON);
    setState(786);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(783);
        _la = _input->LA(1);
        if (_la == 0 || _la == Token::EOF || (_la == DapParser::SEMICOLON)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(788);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
    }
    setState(789);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Datalines4_stmtContext ------------------------------------------------------------------

DapParser::Datalines4_stmtContext::Datalines4_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Datalines4_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

tree::TerminalNode* DapParser::Datalines4_stmtContext::END_DATALINES4() {
  return getToken(DapParser::END_DATALINES4, 0);
}

tree::TerminalNode* DapParser::Datalines4_stmtContext::DATALINES4() {
  return getToken(DapParser::DATALINES4, 0);
}

tree::TerminalNode* DapParser::Datalines4_stmtContext::CARDS4() {
  return getToken(DapParser::CARDS4, 0);
}


size_t DapParser::Datalines4_stmtContext::getRuleIndex() const {
  return DapParser::RuleDatalines4_stmt;
}

void DapParser::Datalines4_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDatalines4_stmt(this);
}

void DapParser::Datalines4_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDatalines4_stmt(this);
}


std::any DapParser::Datalines4_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDatalines4_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Datalines4_stmtContext* DapParser::datalines4_stmt() {
  Datalines4_stmtContext *_localctx = _tracker.createInstance<Datalines4_stmtContext>(_ctx, getState());
  enterRule(_localctx, 94, DapParser::RuleDatalines4_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(791);
    _la = _input->LA(1);
    if (!(_la == DapParser::DATALINES4

    || _la == DapParser::CARDS4)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(792);
    match(DapParser::SEMICOLON);
    setState(796);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(793);
        matchWildcard(); 
      }
      setState(798);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx);
    }
    setState(799);
    match(DapParser::END_DATALINES4);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_mainContext ------------------------------------------------------------------

DapParser::Drop_mainContext::Drop_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Drop_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Drop_stmtContext *> DapParser::Drop_mainContext::drop_stmt() {
  return getRuleContexts<DapParser::Drop_stmtContext>();
}

DapParser::Drop_stmtContext* DapParser::Drop_mainContext::drop_stmt(size_t i) {
  return getRuleContext<DapParser::Drop_stmtContext>(i);
}


size_t DapParser::Drop_mainContext::getRuleIndex() const {
  return DapParser::RuleDrop_main;
}

void DapParser::Drop_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_main(this);
}

void DapParser::Drop_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_main(this);
}


std::any DapParser::Drop_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDrop_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Drop_mainContext* DapParser::drop_main() {
  Drop_mainContext *_localctx = _tracker.createInstance<Drop_mainContext>(_ctx, getState());
  enterRule(_localctx, 96, DapParser::RuleDrop_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(804);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::DROP) {
      setState(801);
      drop_stmt();
      setState(806);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(807);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_stmtContext ------------------------------------------------------------------

DapParser::Drop_stmtContext::Drop_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Drop_stmtContext::DROP() {
  return getToken(DapParser::DROP, 0);
}

tree::TerminalNode* DapParser::Drop_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

std::vector<DapParser::VariablesContext *> DapParser::Drop_stmtContext::variables() {
  return getRuleContexts<DapParser::VariablesContext>();
}

DapParser::VariablesContext* DapParser::Drop_stmtContext::variables(size_t i) {
  return getRuleContext<DapParser::VariablesContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::Drop_stmtContext::SUB() {
  return getTokens(DapParser::SUB);
}

tree::TerminalNode* DapParser::Drop_stmtContext::SUB(size_t i) {
  return getToken(DapParser::SUB, i);
}


size_t DapParser::Drop_stmtContext::getRuleIndex() const {
  return DapParser::RuleDrop_stmt;
}

void DapParser::Drop_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_stmt(this);
}

void DapParser::Drop_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_stmt(this);
}


std::any DapParser::Drop_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDrop_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Drop_stmtContext* DapParser::drop_stmt() {
  Drop_stmtContext *_localctx = _tracker.createInstance<Drop_stmtContext>(_ctx, getState());
  enterRule(_localctx, 98, DapParser::RuleDrop_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(809);
    match(DapParser::DROP);
    setState(815); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(815);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx)) {
      case 1: {
        setState(810);
        variables(0);
        break;
      }

      case 2: {
        setState(811);
        variables(0);
        setState(812);
        match(DapParser::SUB);
        setState(813);
        variables(0);
        break;
      }

      default:
        break;
      }
      setState(817); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 132) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 132)) & 553648129) != 0) || _la == DapParser::Identifier);
    setState(819);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Infile_mainContext ------------------------------------------------------------------

DapParser::Infile_mainContext::Infile_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Infile_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Infile_stmtContext *> DapParser::Infile_mainContext::infile_stmt() {
  return getRuleContexts<DapParser::Infile_stmtContext>();
}

DapParser::Infile_stmtContext* DapParser::Infile_mainContext::infile_stmt(size_t i) {
  return getRuleContext<DapParser::Infile_stmtContext>(i);
}


size_t DapParser::Infile_mainContext::getRuleIndex() const {
  return DapParser::RuleInfile_main;
}

void DapParser::Infile_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInfile_main(this);
}

void DapParser::Infile_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInfile_main(this);
}


std::any DapParser::Infile_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInfile_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Infile_mainContext* DapParser::infile_main() {
  Infile_mainContext *_localctx = _tracker.createInstance<Infile_mainContext>(_ctx, getState());
  enterRule(_localctx, 100, DapParser::RuleInfile_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(824);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::INFILE) {
      setState(821);
      infile_stmt();
      setState(826);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(827);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Infile_stmtContext ------------------------------------------------------------------

DapParser::Infile_stmtContext::Infile_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Infile_stmtContext::INFILE() {
  return getToken(DapParser::INFILE, 0);
}

DapParser::File_specificationContext* DapParser::Infile_stmtContext::file_specification() {
  return getRuleContext<DapParser::File_specificationContext>(0);
}

tree::TerminalNode* DapParser::Infile_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

DapParser::Device_typeContext* DapParser::Infile_stmtContext::device_type() {
  return getRuleContext<DapParser::Device_typeContext>(0);
}

std::vector<DapParser::Infile_optionsContext *> DapParser::Infile_stmtContext::infile_options() {
  return getRuleContexts<DapParser::Infile_optionsContext>();
}

DapParser::Infile_optionsContext* DapParser::Infile_stmtContext::infile_options(size_t i) {
  return getRuleContext<DapParser::Infile_optionsContext>(i);
}


size_t DapParser::Infile_stmtContext::getRuleIndex() const {
  return DapParser::RuleInfile_stmt;
}

void DapParser::Infile_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInfile_stmt(this);
}

void DapParser::Infile_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInfile_stmt(this);
}


std::any DapParser::Infile_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInfile_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Infile_stmtContext* DapParser::infile_stmt() {
  Infile_stmtContext *_localctx = _tracker.createInstance<Infile_stmtContext>(_ctx, getState());
  enterRule(_localctx, 102, DapParser::RuleInfile_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(829);
    match(DapParser::INFILE);
    setState(830);
    file_specification();
    setState(832);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 133) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 133)) & 1023) != 0)) {
      setState(831);
      device_type();
    }
    setState(837);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 143) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 143)) & 144115188075859967) != 0)) {
      setState(834);
      infile_options();
      setState(839);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(840);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_specificationContext ------------------------------------------------------------------

DapParser::File_specificationContext::File_specificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::File_specificationContext::STRINGLITERAL() {
  return getToken(DapParser::STRINGLITERAL, 0);
}

tree::TerminalNode* DapParser::File_specificationContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}

tree::TerminalNode* DapParser::File_specificationContext::CARDS() {
  return getToken(DapParser::CARDS, 0);
}

tree::TerminalNode* DapParser::File_specificationContext::CARDS4() {
  return getToken(DapParser::CARDS4, 0);
}

tree::TerminalNode* DapParser::File_specificationContext::DATALINES() {
  return getToken(DapParser::DATALINES, 0);
}

tree::TerminalNode* DapParser::File_specificationContext::DATALINES4() {
  return getToken(DapParser::DATALINES4, 0);
}


size_t DapParser::File_specificationContext::getRuleIndex() const {
  return DapParser::RuleFile_specification;
}

void DapParser::File_specificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_specification(this);
}

void DapParser::File_specificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_specification(this);
}


std::any DapParser::File_specificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitFile_specification(this);
  else
    return visitor->visitChildren(this);
}

DapParser::File_specificationContext* DapParser::file_specification() {
  File_specificationContext *_localctx = _tracker.createInstance<File_specificationContext>(_ctx, getState());
  enterRule(_localctx, 104, DapParser::RuleFile_specification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(842);
    _la = _input->LA(1);
    if (!(((((_la - 125) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 125)) & 27) != 0) || _la == DapParser::STRINGLITERAL

    || _la == DapParser::Identifier)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Device_typeContext ------------------------------------------------------------------

DapParser::Device_typeContext::Device_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Device_typeContext::DISK() {
  return getToken(DapParser::DISK, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::DUMMY() {
  return getToken(DapParser::DUMMY, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::GTERM() {
  return getToken(DapParser::GTERM, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::PIPE() {
  return getToken(DapParser::PIPE, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::PLOTTER() {
  return getToken(DapParser::PLOTTER, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::PRINTER() {
  return getToken(DapParser::PRINTER, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::TAPE() {
  return getToken(DapParser::TAPE, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::TEMP() {
  return getToken(DapParser::TEMP, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::TERMINAL() {
  return getToken(DapParser::TERMINAL, 0);
}

tree::TerminalNode* DapParser::Device_typeContext::UPRINTER() {
  return getToken(DapParser::UPRINTER, 0);
}


size_t DapParser::Device_typeContext::getRuleIndex() const {
  return DapParser::RuleDevice_type;
}

void DapParser::Device_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDevice_type(this);
}

void DapParser::Device_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDevice_type(this);
}


std::any DapParser::Device_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitDevice_type(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Device_typeContext* DapParser::device_type() {
  Device_typeContext *_localctx = _tracker.createInstance<Device_typeContext>(_ctx, getState());
  enterRule(_localctx, 106, DapParser::RuleDevice_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(844);
    _la = _input->LA(1);
    if (!(((((_la - 133) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 133)) & 1023) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Infile_optionsContext ------------------------------------------------------------------

DapParser::Infile_optionsContext::Infile_optionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Infile_optionsContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

DapParser::ExpressionContext* DapParser::Infile_optionsContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::DSD() {
  return getToken(DapParser::DSD, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::EXPANDTABS() {
  return getToken(DapParser::EXPANDTABS, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::NOEXPANDTABS() {
  return getToken(DapParser::NOEXPANDTABS, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::FLOWOVER() {
  return getToken(DapParser::FLOWOVER, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::MISSOVER() {
  return getToken(DapParser::MISSOVER, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::PAD() {
  return getToken(DapParser::PAD, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::NOPAD() {
  return getToken(DapParser::NOPAD, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::SCANOVER() {
  return getToken(DapParser::SCANOVER, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::SHAREBUFFERS() {
  return getToken(DapParser::SHAREBUFFERS, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::STOPOVER() {
  return getToken(DapParser::STOPOVER, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::TRUNCOVER() {
  return getToken(DapParser::TRUNCOVER, 0);
}

tree::TerminalNode* DapParser::Infile_optionsContext::V_INFILE_() {
  return getToken(DapParser::V_INFILE_, 0);
}


size_t DapParser::Infile_optionsContext::getRuleIndex() const {
  return DapParser::RuleInfile_options;
}

void DapParser::Infile_optionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInfile_options(this);
}

void DapParser::Infile_optionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInfile_options(this);
}


std::any DapParser::Infile_optionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInfile_options(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Infile_optionsContext* DapParser::infile_options() {
  Infile_optionsContext *_localctx = _tracker.createInstance<Infile_optionsContext>(_ctx, getState());
  enterRule(_localctx, 108, DapParser::RuleInfile_options);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(861);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(846);
        match(DapParser::Identifier);
        setState(847);
        match(DapParser::EQUAL);
        setState(848);
        expression(0);
        break;
      }

      case DapParser::DSD: {
        enterOuterAlt(_localctx, 2);
        setState(849);
        match(DapParser::DSD);
        break;
      }

      case DapParser::EXPANDTABS: {
        enterOuterAlt(_localctx, 3);
        setState(850);
        match(DapParser::EXPANDTABS);
        break;
      }

      case DapParser::NOEXPANDTABS: {
        enterOuterAlt(_localctx, 4);
        setState(851);
        match(DapParser::NOEXPANDTABS);
        break;
      }

      case DapParser::FLOWOVER: {
        enterOuterAlt(_localctx, 5);
        setState(852);
        match(DapParser::FLOWOVER);
        break;
      }

      case DapParser::MISSOVER: {
        enterOuterAlt(_localctx, 6);
        setState(853);
        match(DapParser::MISSOVER);
        break;
      }

      case DapParser::PAD: {
        enterOuterAlt(_localctx, 7);
        setState(854);
        match(DapParser::PAD);
        break;
      }

      case DapParser::NOPAD: {
        enterOuterAlt(_localctx, 8);
        setState(855);
        match(DapParser::NOPAD);
        break;
      }

      case DapParser::SCANOVER: {
        enterOuterAlt(_localctx, 9);
        setState(856);
        match(DapParser::SCANOVER);
        break;
      }

      case DapParser::SHAREBUFFERS: {
        enterOuterAlt(_localctx, 10);
        setState(857);
        match(DapParser::SHAREBUFFERS);
        break;
      }

      case DapParser::STOPOVER: {
        enterOuterAlt(_localctx, 11);
        setState(858);
        match(DapParser::STOPOVER);
        break;
      }

      case DapParser::TRUNCOVER: {
        enterOuterAlt(_localctx, 12);
        setState(859);
        match(DapParser::TRUNCOVER);
        break;
      }

      case DapParser::V_INFILE_: {
        enterOuterAlt(_localctx, 13);
        setState(860);
        match(DapParser::V_INFILE_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_mainContext ------------------------------------------------------------------

DapParser::Input_mainContext::Input_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Input_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Input_stmtContext *> DapParser::Input_mainContext::input_stmt() {
  return getRuleContexts<DapParser::Input_stmtContext>();
}

DapParser::Input_stmtContext* DapParser::Input_mainContext::input_stmt(size_t i) {
  return getRuleContext<DapParser::Input_stmtContext>(i);
}

std::vector<DapParser::Put_stmtContext *> DapParser::Input_mainContext::put_stmt() {
  return getRuleContexts<DapParser::Put_stmtContext>();
}

DapParser::Put_stmtContext* DapParser::Input_mainContext::put_stmt(size_t i) {
  return getRuleContext<DapParser::Put_stmtContext>(i);
}


size_t DapParser::Input_mainContext::getRuleIndex() const {
  return DapParser::RuleInput_main;
}

void DapParser::Input_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInput_main(this);
}

void DapParser::Input_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInput_main(this);
}


std::any DapParser::Input_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInput_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Input_mainContext* DapParser::input_main() {
  Input_mainContext *_localctx = _tracker.createInstance<Input_mainContext>(_ctx, getState());
  enterRule(_localctx, 110, DapParser::RuleInput_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(867);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::INPUT

    || _la == DapParser::PUT) {
      setState(865);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case DapParser::INPUT: {
          setState(863);
          input_stmt();
          break;
        }

        case DapParser::PUT: {
          setState(864);
          put_stmt();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(869);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(870);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_stmtContext ------------------------------------------------------------------

DapParser::Input_stmtContext::Input_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Input_stmtContext::INPUT() {
  return getToken(DapParser::INPUT, 0);
}

tree::TerminalNode* DapParser::Input_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

std::vector<DapParser::Input_specificationContext *> DapParser::Input_stmtContext::input_specification() {
  return getRuleContexts<DapParser::Input_specificationContext>();
}

DapParser::Input_specificationContext* DapParser::Input_stmtContext::input_specification(size_t i) {
  return getRuleContext<DapParser::Input_specificationContext>(i);
}

tree::TerminalNode* DapParser::Input_stmtContext::INPUT_ODS() {
  return getToken(DapParser::INPUT_ODS, 0);
}

std::vector<tree::TerminalNode *> DapParser::Input_stmtContext::AT() {
  return getTokens(DapParser::AT);
}

tree::TerminalNode* DapParser::Input_stmtContext::AT(size_t i) {
  return getToken(DapParser::AT, i);
}


size_t DapParser::Input_stmtContext::getRuleIndex() const {
  return DapParser::RuleInput_stmt;
}

void DapParser::Input_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInput_stmt(this);
}

void DapParser::Input_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInput_stmt(this);
}


std::any DapParser::Input_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInput_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Input_stmtContext* DapParser::input_stmt() {
  Input_stmtContext *_localctx = _tracker.createInstance<Input_stmtContext>(_ctx, getState());
  enterRule(_localctx, 112, DapParser::RuleInput_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(872);
    match(DapParser::INPUT);
    setState(876);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(873);
        input_specification(); 
      }
      setState(878);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx);
    }
    setState(880);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::INPUT_ODS) {
      setState(879);
      match(DapParser::INPUT_ODS);
    }
    setState(885);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      setState(882);
      match(DapParser::AT);
      break;
    }

    case 2: {
      setState(883);
      match(DapParser::AT);
      setState(884);
      match(DapParser::AT);
      break;
    }

    default:
      break;
    }
    setState(887);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Put_stmtContext ------------------------------------------------------------------

DapParser::Put_stmtContext::Put_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Put_stmtContext::PUT() {
  return getToken(DapParser::PUT, 0);
}

tree::TerminalNode* DapParser::Put_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

std::vector<DapParser::Put_specificationContext *> DapParser::Put_stmtContext::put_specification() {
  return getRuleContexts<DapParser::Put_specificationContext>();
}

DapParser::Put_specificationContext* DapParser::Put_stmtContext::put_specification(size_t i) {
  return getRuleContext<DapParser::Put_specificationContext>(i);
}

tree::TerminalNode* DapParser::Put_stmtContext::INPUT_ODS() {
  return getToken(DapParser::INPUT_ODS, 0);
}

std::vector<tree::TerminalNode *> DapParser::Put_stmtContext::AT() {
  return getTokens(DapParser::AT);
}

tree::TerminalNode* DapParser::Put_stmtContext::AT(size_t i) {
  return getToken(DapParser::AT, i);
}


size_t DapParser::Put_stmtContext::getRuleIndex() const {
  return DapParser::RulePut_stmt;
}

void DapParser::Put_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPut_stmt(this);
}

void DapParser::Put_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPut_stmt(this);
}


std::any DapParser::Put_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitPut_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Put_stmtContext* DapParser::put_stmt() {
  Put_stmtContext *_localctx = _tracker.createInstance<Put_stmtContext>(_ctx, getState());
  enterRule(_localctx, 114, DapParser::RulePut_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(889);
    match(DapParser::PUT);
    setState(893);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(890);
        put_specification(); 
      }
      setState(895);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx);
    }
    setState(897);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::INPUT_ODS) {
      setState(896);
      match(DapParser::INPUT_ODS);
    }
    setState(902);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
    case 1: {
      setState(899);
      match(DapParser::AT);
      break;
    }

    case 2: {
      setState(900);
      match(DapParser::AT);
      setState(901);
      match(DapParser::AT);
      break;
    }

    default:
      break;
    }
    setState(904);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_specificationContext ------------------------------------------------------------------

DapParser::Input_specificationContext::Input_specificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::Pointer_controlContext* DapParser::Input_specificationContext::pointer_control() {
  return getRuleContext<DapParser::Pointer_controlContext>(0);
}

DapParser::Input_variable_formatContext* DapParser::Input_specificationContext::input_variable_format() {
  return getRuleContext<DapParser::Input_variable_formatContext>(0);
}

DapParser::Column_specificationsContext* DapParser::Input_specificationContext::column_specifications() {
  return getRuleContext<DapParser::Column_specificationsContext>(0);
}

std::vector<tree::TerminalNode *> DapParser::Input_specificationContext::LParentheses() {
  return getTokens(DapParser::LParentheses);
}

tree::TerminalNode* DapParser::Input_specificationContext::LParentheses(size_t i) {
  return getToken(DapParser::LParentheses, i);
}

DapParser::Identifiers_listContext* DapParser::Input_specificationContext::identifiers_list() {
  return getRuleContext<DapParser::Identifiers_listContext>(0);
}

std::vector<tree::TerminalNode *> DapParser::Input_specificationContext::RParentheses() {
  return getTokens(DapParser::RParentheses);
}

tree::TerminalNode* DapParser::Input_specificationContext::RParentheses(size_t i) {
  return getToken(DapParser::RParentheses, i);
}

DapParser::Informat_listContext* DapParser::Input_specificationContext::informat_list() {
  return getRuleContext<DapParser::Informat_listContext>(0);
}


size_t DapParser::Input_specificationContext::getRuleIndex() const {
  return DapParser::RuleInput_specification;
}

void DapParser::Input_specificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInput_specification(this);
}

void DapParser::Input_specificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInput_specification(this);
}


std::any DapParser::Input_specificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInput_specification(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Input_specificationContext* DapParser::input_specification() {
  Input_specificationContext *_localctx = _tracker.createInstance<Input_specificationContext>(_ctx, getState());
  enterRule(_localctx, 116, DapParser::RuleInput_specification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(916);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::T__4:
      case DapParser::AT:
      case DapParser::ADD:
      case DapParser::DIV: {
        enterOuterAlt(_localctx, 1);
        setState(906);
        pointer_control();
        break;
      }

      case DapParser::ALTER:
      case DapParser::DATE:
      case DapParser::DROP:
      case DapParser::Identifier: {
        enterOuterAlt(_localctx, 2);
        setState(907);
        input_variable_format();
        break;
      }

      case DapParser::INT: {
        enterOuterAlt(_localctx, 3);
        setState(908);
        column_specifications();
        break;
      }

      case DapParser::LParentheses: {
        enterOuterAlt(_localctx, 4);
        setState(909);
        match(DapParser::LParentheses);
        setState(910);
        identifiers_list();
        setState(911);
        match(DapParser::RParentheses);
        setState(912);
        match(DapParser::LParentheses);
        setState(913);
        informat_list();
        setState(914);
        match(DapParser::RParentheses);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Put_specificationContext ------------------------------------------------------------------

DapParser::Put_specificationContext::Put_specificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::Pointer_controlContext* DapParser::Put_specificationContext::pointer_control() {
  return getRuleContext<DapParser::Pointer_controlContext>(0);
}

DapParser::Put_variable_formatContext* DapParser::Put_specificationContext::put_variable_format() {
  return getRuleContext<DapParser::Put_variable_formatContext>(0);
}

DapParser::Column_specificationsContext* DapParser::Put_specificationContext::column_specifications() {
  return getRuleContext<DapParser::Column_specificationsContext>(0);
}

std::vector<tree::TerminalNode *> DapParser::Put_specificationContext::LParentheses() {
  return getTokens(DapParser::LParentheses);
}

tree::TerminalNode* DapParser::Put_specificationContext::LParentheses(size_t i) {
  return getToken(DapParser::LParentheses, i);
}

DapParser::Identifiers_listContext* DapParser::Put_specificationContext::identifiers_list() {
  return getRuleContext<DapParser::Identifiers_listContext>(0);
}

std::vector<tree::TerminalNode *> DapParser::Put_specificationContext::RParentheses() {
  return getTokens(DapParser::RParentheses);
}

tree::TerminalNode* DapParser::Put_specificationContext::RParentheses(size_t i) {
  return getToken(DapParser::RParentheses, i);
}

DapParser::Informat_listContext* DapParser::Put_specificationContext::informat_list() {
  return getRuleContext<DapParser::Informat_listContext>(0);
}


size_t DapParser::Put_specificationContext::getRuleIndex() const {
  return DapParser::RulePut_specification;
}

void DapParser::Put_specificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPut_specification(this);
}

void DapParser::Put_specificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPut_specification(this);
}


std::any DapParser::Put_specificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitPut_specification(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Put_specificationContext* DapParser::put_specification() {
  Put_specificationContext *_localctx = _tracker.createInstance<Put_specificationContext>(_ctx, getState());
  enterRule(_localctx, 118, DapParser::RulePut_specification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(928);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(918);
      pointer_control();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(919);
      put_variable_format();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(920);
      column_specifications();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(921);
      match(DapParser::LParentheses);
      setState(922);
      identifiers_list();
      setState(923);
      match(DapParser::RParentheses);
      setState(924);
      match(DapParser::LParentheses);
      setState(925);
      informat_list();
      setState(926);
      match(DapParser::RParentheses);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pointer_controlContext ------------------------------------------------------------------

DapParser::Pointer_controlContext::Pointer_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::Line_point_controlContext* DapParser::Pointer_controlContext::line_point_control() {
  return getRuleContext<DapParser::Line_point_controlContext>(0);
}

DapParser::Column_point_controlContext* DapParser::Pointer_controlContext::column_point_control() {
  return getRuleContext<DapParser::Column_point_controlContext>(0);
}


size_t DapParser::Pointer_controlContext::getRuleIndex() const {
  return DapParser::RulePointer_control;
}

void DapParser::Pointer_controlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPointer_control(this);
}

void DapParser::Pointer_controlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPointer_control(this);
}


std::any DapParser::Pointer_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitPointer_control(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Pointer_controlContext* DapParser::pointer_control() {
  Pointer_controlContext *_localctx = _tracker.createInstance<Pointer_controlContext>(_ctx, getState());
  enterRule(_localctx, 120, DapParser::RulePointer_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(932);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case DapParser::T__4:
      case DapParser::DIV: {
        enterOuterAlt(_localctx, 1);
        setState(930);
        line_point_control();
        break;
      }

      case DapParser::AT:
      case DapParser::ADD: {
        enterOuterAlt(_localctx, 2);
        setState(931);
        column_point_control();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Informat_listContext ------------------------------------------------------------------

DapParser::Informat_listContext::Informat_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::Informat_listContext::Informat() {
  return getTokens(DapParser::Informat);
}

tree::TerminalNode* DapParser::Informat_listContext::Informat(size_t i) {
  return getToken(DapParser::Informat, i);
}

std::vector<tree::TerminalNode *> DapParser::Informat_listContext::COMMA() {
  return getTokens(DapParser::COMMA);
}

tree::TerminalNode* DapParser::Informat_listContext::COMMA(size_t i) {
  return getToken(DapParser::COMMA, i);
}

std::vector<DapParser::Pointer_controlContext *> DapParser::Informat_listContext::pointer_control() {
  return getRuleContexts<DapParser::Pointer_controlContext>();
}

DapParser::Pointer_controlContext* DapParser::Informat_listContext::pointer_control(size_t i) {
  return getRuleContext<DapParser::Pointer_controlContext>(i);
}


size_t DapParser::Informat_listContext::getRuleIndex() const {
  return DapParser::RuleInformat_list;
}

void DapParser::Informat_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInformat_list(this);
}

void DapParser::Informat_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInformat_list(this);
}


std::any DapParser::Informat_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInformat_list(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Informat_listContext* DapParser::informat_list() {
  Informat_listContext *_localctx = _tracker.createInstance<Informat_listContext>(_ctx, getState());
  enterRule(_localctx, 122, DapParser::RuleInformat_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(941); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(934);
      match(DapParser::Informat);
      setState(936);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::COMMA) {
        setState(935);
        match(DapParser::COMMA);
      }
      setState(939);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::T__4 || ((((_la - 202) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 202)) & 73729) != 0)) {
        setState(938);
        pointer_control();
      }
      setState(943); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == DapParser::Informat);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_variable_formatContext ------------------------------------------------------------------

DapParser::Input_variable_formatContext::Input_variable_formatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::Input_variableContext* DapParser::Input_variable_formatContext::input_variable() {
  return getRuleContext<DapParser::Input_variableContext>(0);
}

tree::TerminalNode* DapParser::Input_variable_formatContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

DapParser::Format_modifierContext* DapParser::Input_variable_formatContext::format_modifier() {
  return getRuleContext<DapParser::Format_modifierContext>(0);
}

tree::TerminalNode* DapParser::Input_variable_formatContext::Informat() {
  return getToken(DapParser::Informat, 0);
}

tree::TerminalNode* DapParser::Input_variable_formatContext::DOLLAR() {
  return getToken(DapParser::DOLLAR, 0);
}


size_t DapParser::Input_variable_formatContext::getRuleIndex() const {
  return DapParser::RuleInput_variable_format;
}

void DapParser::Input_variable_formatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInput_variable_format(this);
}

void DapParser::Input_variable_formatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInput_variable_format(this);
}


std::any DapParser::Input_variable_formatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInput_variable_format(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Input_variable_formatContext* DapParser::input_variable_format() {
  Input_variable_formatContext *_localctx = _tracker.createInstance<Input_variable_formatContext>(_ctx, getState());
  enterRule(_localctx, 124, DapParser::RuleInput_variable_format);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(965);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(945);
      input_variable();
      setState(947);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::EQUAL) {
        setState(946);
        match(DapParser::EQUAL);
      }
      setState(950);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 960) != 0) || _la == DapParser::COLON) {
        setState(949);
        format_modifier();
      }
      setState(953);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::Informat) {
        setState(952);
        match(DapParser::Informat);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(955);
      input_variable();
      setState(957);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::EQUAL) {
        setState(956);
        match(DapParser::EQUAL);
      }
      setState(960);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 960) != 0) || _la == DapParser::COLON) {
        setState(959);
        format_modifier();
      }
      setState(963);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::DOLLAR) {
        setState(962);
        match(DapParser::DOLLAR);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_variableContext ------------------------------------------------------------------

DapParser::Input_variableContext::Input_variableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<DapParser::VariablesContext *> DapParser::Input_variableContext::variables() {
  return getRuleContexts<DapParser::VariablesContext>();
}

DapParser::VariablesContext* DapParser::Input_variableContext::variables(size_t i) {
  return getRuleContext<DapParser::VariablesContext>(i);
}

tree::TerminalNode* DapParser::Input_variableContext::SUB() {
  return getToken(DapParser::SUB, 0);
}

tree::TerminalNode* DapParser::Input_variableContext::LBraces() {
  return getToken(DapParser::LBraces, 0);
}

tree::TerminalNode* DapParser::Input_variableContext::MUL() {
  return getToken(DapParser::MUL, 0);
}

tree::TerminalNode* DapParser::Input_variableContext::RBraces() {
  return getToken(DapParser::RBraces, 0);
}


size_t DapParser::Input_variableContext::getRuleIndex() const {
  return DapParser::RuleInput_variable;
}

void DapParser::Input_variableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInput_variable(this);
}

void DapParser::Input_variableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInput_variable(this);
}


std::any DapParser::Input_variableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitInput_variable(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Input_variableContext* DapParser::input_variable() {
  Input_variableContext *_localctx = _tracker.createInstance<Input_variableContext>(_ctx, getState());
  enterRule(_localctx, 126, DapParser::RuleInput_variable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(977);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(967);
      variables(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(968);
      variables(0);
      setState(969);
      match(DapParser::SUB);
      setState(970);
      variables(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(972);
      variables(0);
      setState(973);
      match(DapParser::LBraces);
      setState(974);
      match(DapParser::MUL);
      setState(975);
      match(DapParser::RBraces);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Put_variable_formatContext ------------------------------------------------------------------

DapParser::Put_variable_formatContext::Put_variable_formatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

DapParser::Put_variableContext* DapParser::Put_variable_formatContext::put_variable() {
  return getRuleContext<DapParser::Put_variableContext>(0);
}

tree::TerminalNode* DapParser::Put_variable_formatContext::EQUAL() {
  return getToken(DapParser::EQUAL, 0);
}

DapParser::Format_modifierContext* DapParser::Put_variable_formatContext::format_modifier() {
  return getRuleContext<DapParser::Format_modifierContext>(0);
}

tree::TerminalNode* DapParser::Put_variable_formatContext::Informat() {
  return getToken(DapParser::Informat, 0);
}

tree::TerminalNode* DapParser::Put_variable_formatContext::DOLLAR() {
  return getToken(DapParser::DOLLAR, 0);
}


size_t DapParser::Put_variable_formatContext::getRuleIndex() const {
  return DapParser::RulePut_variable_format;
}

void DapParser::Put_variable_formatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPut_variable_format(this);
}

void DapParser::Put_variable_formatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPut_variable_format(this);
}


std::any DapParser::Put_variable_formatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitPut_variable_format(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Put_variable_formatContext* DapParser::put_variable_format() {
  Put_variable_formatContext *_localctx = _tracker.createInstance<Put_variable_formatContext>(_ctx, getState());
  enterRule(_localctx, 128, DapParser::RulePut_variable_format);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(999);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 125, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(979);
      put_variable();
      setState(981);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::EQUAL) {
        setState(980);
        match(DapParser::EQUAL);
      }
      setState(984);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 960) != 0) || _la == DapParser::COLON) {
        setState(983);
        format_modifier();
      }
      setState(987);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::Informat) {
        setState(986);
        match(DapParser::Informat);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(989);
      put_variable();
      setState(991);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::EQUAL) {
        setState(990);
        match(DapParser::EQUAL);
      }
      setState(994);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 960) != 0) || _la == DapParser::COLON) {
        setState(993);
        format_modifier();
      }
      setState(997);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::DOLLAR) {
        setState(996);
        match(DapParser::DOLLAR);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Put_variableContext ------------------------------------------------------------------

DapParser::Put_variableContext::Put_variableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Put_variableContext::V_INFILE_() {
  return getToken(DapParser::V_INFILE_, 0);
}

tree::TerminalNode* DapParser::Put_variableContext::ARRAY_ALL_ELEMENTS() {
  return getToken(DapParser::ARRAY_ALL_ELEMENTS, 0);
}

DapParser::Input_variableContext* DapParser::Put_variableContext::input_variable() {
  return getRuleContext<DapParser::Input_variableContext>(0);
}

tree::TerminalNode* DapParser::Put_variableContext::STRINGLITERAL() {
  return getToken(DapParser::STRINGLITERAL, 0);
}

tree::TerminalNode* DapParser::Put_variableContext::INT() {
  return getToken(DapParser::INT, 0);
}

tree::TerminalNode* DapParser::Put_variableContext::MUL() {
  return getToken(DapParser::MUL, 0);
}

DapParser::LiteralContext* DapParser::Put_variableContext::literal() {
  return getRuleContext<DapParser::LiteralContext>(0);
}


size_t DapParser::Put_variableContext::getRuleIndex() const {
  return DapParser::RulePut_variable;
}

void DapParser::Put_variableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPut_variable(this);
}

void DapParser::Put_variableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPut_variable(this);
}


std::any DapParser::Put_variableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitPut_variable(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Put_variableContext* DapParser::put_variable() {
  Put_variableContext *_localctx = _tracker.createInstance<Put_variableContext>(_ctx, getState());
  enterRule(_localctx, 130, DapParser::RulePut_variable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1010);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1001);
      match(DapParser::V_INFILE_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1002);
      match(DapParser::ARRAY_ALL_ELEMENTS);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1003);
      input_variable();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1006);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == DapParser::INT) {
        setState(1004);
        match(DapParser::INT);
        setState(1005);
        match(DapParser::MUL);
      }
      setState(1008);
      match(DapParser::STRINGLITERAL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1009);
      literal();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_point_controlContext ------------------------------------------------------------------

DapParser::Column_point_controlContext::Column_point_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Column_point_controlContext::AT() {
  return getToken(DapParser::AT, 0);
}

tree::TerminalNode* DapParser::Column_point_controlContext::INT() {
  return getToken(DapParser::INT, 0);
}

tree::TerminalNode* DapParser::Column_point_controlContext::FloatingPointLiteral() {
  return getToken(DapParser::FloatingPointLiteral, 0);
}

tree::TerminalNode* DapParser::Column_point_controlContext::Identifier() {
  return getToken(DapParser::Identifier, 0);
}

tree::TerminalNode* DapParser::Column_point_controlContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

DapParser::ExpressionContext* DapParser::Column_point_controlContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::Column_point_controlContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

tree::TerminalNode* DapParser::Column_point_controlContext::ADD() {
  return getToken(DapParser::ADD, 0);
}


size_t DapParser::Column_point_controlContext::getRuleIndex() const {
  return DapParser::RuleColumn_point_control;
}

void DapParser::Column_point_controlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_point_control(this);
}

void DapParser::Column_point_controlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_point_control(this);
}


std::any DapParser::Column_point_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitColumn_point_control(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Column_point_controlContext* DapParser::column_point_control() {
  Column_point_controlContext *_localctx = _tracker.createInstance<Column_point_controlContext>(_ctx, getState());
  enterRule(_localctx, 132, DapParser::RuleColumn_point_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1034);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1012);
      match(DapParser::AT);
      setState(1013);
      match(DapParser::INT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1014);
      match(DapParser::AT);
      setState(1015);
      match(DapParser::FloatingPointLiteral);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1016);
      match(DapParser::AT);
      setState(1017);
      match(DapParser::Identifier);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1018);
      match(DapParser::AT);
      setState(1019);
      match(DapParser::LParentheses);
      setState(1020);
      expression(0);
      setState(1021);
      match(DapParser::RParentheses);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1023);
      match(DapParser::ADD);
      setState(1024);
      match(DapParser::INT);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1025);
      match(DapParser::ADD);
      setState(1026);
      match(DapParser::Identifier);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1027);
      match(DapParser::ADD);
      setState(1028);
      match(DapParser::FloatingPointLiteral);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1029);
      match(DapParser::ADD);
      setState(1030);
      match(DapParser::LParentheses);
      setState(1031);
      expression(0);
      setState(1032);
      match(DapParser::RParentheses);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Line_point_controlContext ------------------------------------------------------------------

DapParser::Line_point_controlContext::Line_point_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Line_point_controlContext::INT() {
  return getToken(DapParser::INT, 0);
}

tree::TerminalNode* DapParser::Line_point_controlContext::FloatingPointLiteral() {
  return getToken(DapParser::FloatingPointLiteral, 0);
}

tree::TerminalNode* DapParser::Line_point_controlContext::LParentheses() {
  return getToken(DapParser::LParentheses, 0);
}

DapParser::ExpressionContext* DapParser::Line_point_controlContext::expression() {
  return getRuleContext<DapParser::ExpressionContext>(0);
}

tree::TerminalNode* DapParser::Line_point_controlContext::RParentheses() {
  return getToken(DapParser::RParentheses, 0);
}

tree::TerminalNode* DapParser::Line_point_controlContext::DIV() {
  return getToken(DapParser::DIV, 0);
}


size_t DapParser::Line_point_controlContext::getRuleIndex() const {
  return DapParser::RuleLine_point_control;
}

void DapParser::Line_point_controlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLine_point_control(this);
}

void DapParser::Line_point_controlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLine_point_control(this);
}


std::any DapParser::Line_point_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitLine_point_control(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Line_point_controlContext* DapParser::line_point_control() {
  Line_point_controlContext *_localctx = _tracker.createInstance<Line_point_controlContext>(_ctx, getState());
  enterRule(_localctx, 134, DapParser::RuleLine_point_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1046);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1036);
      match(DapParser::T__4);
      setState(1037);
      match(DapParser::INT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1038);
      match(DapParser::T__4);
      setState(1039);
      match(DapParser::FloatingPointLiteral);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1040);
      match(DapParser::T__4);
      setState(1041);
      match(DapParser::LParentheses);
      setState(1042);
      expression(0);
      setState(1043);
      match(DapParser::RParentheses);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1045);
      match(DapParser::DIV);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Format_modifierContext ------------------------------------------------------------------

DapParser::Format_modifierContext::Format_modifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Format_modifierContext::COLON() {
  return getToken(DapParser::COLON, 0);
}


size_t DapParser::Format_modifierContext::getRuleIndex() const {
  return DapParser::RuleFormat_modifier;
}

void DapParser::Format_modifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormat_modifier(this);
}

void DapParser::Format_modifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormat_modifier(this);
}


std::any DapParser::Format_modifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitFormat_modifier(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Format_modifierContext* DapParser::format_modifier() {
  Format_modifierContext *_localctx = _tracker.createInstance<Format_modifierContext>(_ctx, getState());
  enterRule(_localctx, 136, DapParser::RuleFormat_modifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1048);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 960) != 0) || _la == DapParser::COLON)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_specificationsContext ------------------------------------------------------------------

DapParser::Column_specificationsContext::Column_specificationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> DapParser::Column_specificationsContext::INT() {
  return getTokens(DapParser::INT);
}

tree::TerminalNode* DapParser::Column_specificationsContext::INT(size_t i) {
  return getToken(DapParser::INT, i);
}

tree::TerminalNode* DapParser::Column_specificationsContext::SUB() {
  return getToken(DapParser::SUB, 0);
}


size_t DapParser::Column_specificationsContext::getRuleIndex() const {
  return DapParser::RuleColumn_specifications;
}

void DapParser::Column_specificationsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_specifications(this);
}

void DapParser::Column_specificationsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_specifications(this);
}


std::any DapParser::Column_specificationsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitColumn_specifications(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Column_specificationsContext* DapParser::column_specifications() {
  Column_specificationsContext *_localctx = _tracker.createInstance<Column_specificationsContext>(_ctx, getState());
  enterRule(_localctx, 138, DapParser::RuleColumn_specifications);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1050);
    match(DapParser::INT);
    setState(1051);
    match(DapParser::SUB);
    setState(1052);
    match(DapParser::INT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Means_mainContext ------------------------------------------------------------------

DapParser::Means_mainContext::Means_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Means_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Means_procContext *> DapParser::Means_mainContext::means_proc() {
  return getRuleContexts<DapParser::Means_procContext>();
}

DapParser::Means_procContext* DapParser::Means_mainContext::means_proc(size_t i) {
  return getRuleContext<DapParser::Means_procContext>(i);
}


size_t DapParser::Means_mainContext::getRuleIndex() const {
  return DapParser::RuleMeans_main;
}

void DapParser::Means_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeans_main(this);
}

void DapParser::Means_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeans_main(this);
}


std::any DapParser::Means_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitMeans_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Means_mainContext* DapParser::means_main() {
  Means_mainContext *_localctx = _tracker.createInstance<Means_mainContext>(_ctx, getState());
  enterRule(_localctx, 140, DapParser::RuleMeans_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1057);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::DROP) {
      setState(1054);
      means_proc();
      setState(1059);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1060);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Means_procContext ------------------------------------------------------------------

DapParser::Means_procContext::Means_procContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Means_procContext::DROP() {
  return getToken(DapParser::DROP, 0);
}

tree::TerminalNode* DapParser::Means_procContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

std::vector<DapParser::VariablesContext *> DapParser::Means_procContext::variables() {
  return getRuleContexts<DapParser::VariablesContext>();
}

DapParser::VariablesContext* DapParser::Means_procContext::variables(size_t i) {
  return getRuleContext<DapParser::VariablesContext>(i);
}

std::vector<tree::TerminalNode *> DapParser::Means_procContext::SUB() {
  return getTokens(DapParser::SUB);
}

tree::TerminalNode* DapParser::Means_procContext::SUB(size_t i) {
  return getToken(DapParser::SUB, i);
}


size_t DapParser::Means_procContext::getRuleIndex() const {
  return DapParser::RuleMeans_proc;
}

void DapParser::Means_procContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeans_proc(this);
}

void DapParser::Means_procContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeans_proc(this);
}


std::any DapParser::Means_procContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitMeans_proc(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Means_procContext* DapParser::means_proc() {
  Means_procContext *_localctx = _tracker.createInstance<Means_procContext>(_ctx, getState());
  enterRule(_localctx, 142, DapParser::RuleMeans_proc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1062);
    match(DapParser::DROP);
    setState(1068); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1068);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx)) {
      case 1: {
        setState(1063);
        variables(0);
        break;
      }

      case 2: {
        setState(1064);
        variables(0);
        setState(1065);
        match(DapParser::SUB);
        setState(1066);
        variables(0);
        break;
      }

      default:
        break;
      }
      setState(1070); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 132) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 132)) & 553648129) != 0) || _la == DapParser::Identifier);
    setState(1072);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Run_mainContext ------------------------------------------------------------------

DapParser::Run_mainContext::Run_mainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Run_mainContext::EOF() {
  return getToken(DapParser::EOF, 0);
}

std::vector<DapParser::Run_stmtContext *> DapParser::Run_mainContext::run_stmt() {
  return getRuleContexts<DapParser::Run_stmtContext>();
}

DapParser::Run_stmtContext* DapParser::Run_mainContext::run_stmt(size_t i) {
  return getRuleContext<DapParser::Run_stmtContext>(i);
}


size_t DapParser::Run_mainContext::getRuleIndex() const {
  return DapParser::RuleRun_main;
}

void DapParser::Run_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRun_main(this);
}

void DapParser::Run_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRun_main(this);
}


std::any DapParser::Run_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitRun_main(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Run_mainContext* DapParser::run_main() {
  Run_mainContext *_localctx = _tracker.createInstance<Run_mainContext>(_ctx, getState());
  enterRule(_localctx, 144, DapParser::RuleRun_main);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1077);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == DapParser::RUN) {
      setState(1074);
      run_stmt();
      setState(1079);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1080);
    match(DapParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Run_stmtContext ------------------------------------------------------------------

DapParser::Run_stmtContext::Run_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* DapParser::Run_stmtContext::RUN() {
  return getToken(DapParser::RUN, 0);
}

tree::TerminalNode* DapParser::Run_stmtContext::SEMICOLON() {
  return getToken(DapParser::SEMICOLON, 0);
}

tree::TerminalNode* DapParser::Run_stmtContext::CANCEL() {
  return getToken(DapParser::CANCEL, 0);
}


size_t DapParser::Run_stmtContext::getRuleIndex() const {
  return DapParser::RuleRun_stmt;
}

void DapParser::Run_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRun_stmt(this);
}

void DapParser::Run_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<DapListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRun_stmt(this);
}


std::any DapParser::Run_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<DapVisitor*>(visitor))
    return parserVisitor->visitRun_stmt(this);
  else
    return visitor->visitChildren(this);
}

DapParser::Run_stmtContext* DapParser::run_stmt() {
  Run_stmtContext *_localctx = _tracker.createInstance<Run_stmtContext>(_ctx, getState());
  enterRule(_localctx, 146, DapParser::RuleRun_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1082);
    match(DapParser::RUN);
    setState(1084);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == DapParser::CANCEL) {
      setState(1083);
      match(DapParser::CANCEL);
    }
    setState(1086);
    match(DapParser::SEMICOLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool DapParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 5: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);
    case 6: return expressionListSempred(antlrcpp::downCast<ExpressionListContext *>(context), predicateIndex);
    case 12: return variablesSempred(antlrcpp::downCast<VariablesContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool DapParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 13);
    case 1: return precpred(_ctx, 10);
    case 2: return precpred(_ctx, 9);
    case 3: return precpred(_ctx, 8);
    case 4: return precpred(_ctx, 7);
    case 5: return precpred(_ctx, 6);
    case 6: return precpred(_ctx, 5);
    case 7: return precpred(_ctx, 4);
    case 8: return precpred(_ctx, 2);
    case 9: return precpred(_ctx, 1);
    case 10: return precpred(_ctx, 16);
    case 11: return precpred(_ctx, 15);
    case 12: return precpred(_ctx, 14);
    case 13: return precpred(_ctx, 3);

  default:
    break;
  }
  return true;
}

bool DapParser::expressionListSempred(ExpressionListContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 14: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool DapParser::variablesSempred(VariablesContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 15: return precpred(_ctx, 5);

  default:
    break;
  }
  return true;
}

void DapParser::initialize() {
  ::antlr4::internal::call_once(dapParserOnceFlag, dapParserInitialize);
}
