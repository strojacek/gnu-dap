This is dap, produced by makeinfo version 4.5 from dap.texi.

INFO-DIR-SECTION Dap statistics and graphics package
START-INFO-DIR-ENTRY
* Dap: (dap).                The Dap statistics package
END-INFO-DIR-ENTRY


File: dap,  Node: Analysis of variance examples,  Next: Linear regression examples,  Up: Examples

Analysis of variance
====================

   These examples are from:

   * AMD: Milliken, G.A. and Johnson, D.E. 1984.  Analysis of Messy
     Data.  Van Nostrand Reinhold: New York. 473pp.

   * ED: Cochran, W.G. and Cox, G.M. 1957.  Experimental Designs.  John
     Wiley & Sons: New York. 611pp.



     /* AMD pp. 128 - 134: unbalanced layout using SBS  */
     
     data;
      infile "amd128.dat" firstobs=2; /* space separated, skip 1 header line */
      length treat $ 6 block $ 6;
      input treat block y;
     
     proc glm;
      class treat block;
      model y = treat block treat*block;
      lsmeans treat block / tukey;

     /* AMD pp. 249 - 251: using SBS
      * Two factors crossed, another nested within
      * levels of one crossed factor
      */
     
     data;
      infile "amd249.dat" firstobs=2;
      length a $ 1 b $ 1 c $ 1;
      input b c a y1 y2; /* two values per cell */
      y = y1;
      output;
      y = y2;
      output;
     
     proc glm;
      class a b c;
      model y = a b a*b c*b a*c*b;
      test h=a e=a*b;
      test h=b e=a*b b*c a*b*c;
      test h=a*b e=a*b*c;
      test h=c*b e=a*c*b;


     /* AMD pp. 265 - 273 using SBS
      * Random model, unbalanced
      */
     
     data;
      infile "amd265.dat" firstobs=2;
      length plant $ 1 site $ 1 worker $ 1;
      input plant worker site efficiency;
     
     proc glm;
      class plant site worker;
      model efficiency = plant plant*worker plant*site plant*site*worker;
      test h=site*plant e=site*worker*plant;
     
     proc glm;
      class plant site worker;
      model efficiency = plant plant*worker site*worker*plant;
      test h=worker*plant e=site*worker*plant;
      test h=plant e=worker*plant site*worker*plant;


     /* AMD pp. 285 - 289 using SBS
      * Mixed model, balanced
      */
     
     data;
      infile "amd285.dat" firstobs=2;
      length machine $ 1 person $ 1;
      input machine person prod1 prod2 prod3; /* 3 observations per cell */
      productivity = prod1;
      output;
      productivity = prod2;
      output;
      productivity = prod3;
      output;
     
     proc glm;
      class machine person;
      model productivity = machine person machine*person;
      test h=person e=machine*person;
      lsmeans machine / e=machine*person lsd;


     /* AMD pp. 290 - 295 using SBS
      * Mixed model, unbalanced
      */
     
     data;
      infile "amd290.dat" firstobs=2;
      length machine $ 1 person $ 1;
      input machine person productivity;
     
     proc glm;
      class machine person;
      model productivity = machine person machine*person;
      test h=person e=machine*person;
      lsmeans machine / e=machine*person lsd;


     /* AMD pp. 297 - 308 using SBS
      * Split plot
      */
     
     data;
      infile "amd297.dat" firstobs=2;
      length fertilizer $ 1 block $ 1 variety $ 1;
      input block variety fertilizer yield;
     
     proc glm;
      title "Whole plot (block, fertilizer) analysis";
      class fertilizer block variety;
      model yield = fertilizer block;
      lsmeans fertilizer / e=fertilizer*block LSD;
     
     proc glm;
      title "Subplot (variety) analysis";
      class fertilizer block variety;
      model yield = fertilizer block variety
                    fertilizer*block fertilizer*variety;


     /* ED pp. 122 - 125 using SBS
      * Latin square
      */
     
     data;
      infile "ed122.dat" firstobs=2;
      length sampler $ 1 area $ 1 order $ 1;
      input order area sampler error;
     
     proc glm;
      class sampler area order;
      model error = sampler area order;
      lsmeans sampler / lsd;


     /* ED pp. 176 using SBS and proc dap
      * Without covariate, with contrasts
      */
     
     data muscle;
      infile "sas976.dat" dlm="\t" firstobs=3;
      length rep $ 1 time $ 1 current $ 1 number $ 1;
      input rep time current number y;
     
     proc glm;
      class rep current time number;
      model y=rep current time number current*time current*number
              time*number current*time*number;
      contrast "curr 1 vs curr 2" current 1 -1;
     
     /* To construct the constrast for testing "time in current 3",
      * we have to modify the muscle.srt.mns.con file produced by glm.
      */
     proc dap;
     { /* start with brace to enclose everything */
       inset("muscle.srt.mns.con")
        {
          char rep[2], current[2], time[2];
          double y;
          char _type_[9]; /* N, MEAN, VAR, ERROR, CONTR, LSMEAN */
          int _term_; /* specifies term to which contrast applies */
          int more; /* to control stepping through dataset */
          double c1[4], c2[4], c3[4]; /* contrast with 3 df */
          outset("muscle.con", ""); /* datast for the F-test */
          /* set up the contrast coefficients */
          c1[0] = 1; c1[1] = 0; c1[2] = 0; c1[3] = -1;
          c2[0] = 0; c2[1] = 1; c2[2] = 0; c2[3] = -1;
          c3[0] = 0; c3[1] = 0; c3[2] = 1; c3[3] = -1;
          for (more = step(); more; )
           {
             output(); /* N, MEAN, VAR */
             step();
             output();
             step();
             output();
             for (step(); strcmp(_type_, "CONTR"); step()) /* get to CONTR lines */
               output();
             _term_ = 4; /* bits: 1 is rep, 2 is current, 4 is time */
             if (!strcmp(current, "3")) /* only in current 3 */
              {
                y = c1[time[0] - '1']; /* convert time to index */
                output();
                y = c2[time[0] - '1'];
                output();
                y = c3[time[0] - '1'];
                output();
              }
             else
              {
                y = 0.0;
                output();
                output();
                output();
              }
             while (more && !strcmp(_type_, "CONTR")) /* look for the ones we want */
                more = step();
             while (more && !strcmp(_type_, "LSMEAN")) /* get to next cell or end */
              {
                output();
                more = step();
              }
           }
        }
       /* muscle.con only has time in numerator so don't need to specify it */
       ftest("muscle.con", "y rep current time number", "", "", "");
     }


     /* AMD pp. 173 - 177:
      * missing treatment combinations
      */
     
     data amd173;
      infile "amd173.dat" firstobs=2;
      length treat $ 2 block $ 2;
      input treat block y;
     
     proc sort data=amd173;
      by treat block;
     
     proc means data=amd173 N MEAN VAR noprint;
      var y;
      by treat block;
      output out=amd173.mns;
     
     /* Now we have to create "by hand" the .con files for
      * the custom F-tests for the contrasts that are meaningful
      * in the presence of empty cells.
      */
     /* The first F-test (p. 175-76) is the interaction:
      * m11 - m13 - m21 + m23 = 0 and m21 - m22 - m31 + m32 = 0
      */
     proc dap;
     { /* start with a brace to enclose everything here */
       inset("amd173.mns") /* file from model statement */
        {
          char treat[3], block[3]; /* we're in C here! */
          double y;
          char _type_[9]; /* set this to CONTR */
          int _term_;     /* bits specify the effect */
          double c1[7], c2[7]; /* coeffs of the contrasts */
          int c; /* cell number */
          outset("amd173.mns.con", "treat block y _term_");
          /* cells, in sort order, are:
          /*   11       13       21       22      23       31      32 */
          c1[0]=1;c1[1]=-1;c1[2]=-1;c1[3]= 0;c1[4]=1;c1[5]= 0;c1[6]=0;
          c2[0]=0;c2[1]= 0;c2[2]= 1;c2[3]=-1;c2[4]=0;c2[5]=-1;c2[6]=1;
          _term_ = 3; /* bit 1 for treat, bit 2 for block */
          for (c = 0; step(); c++) /* while there's another cell */
           {
             output(); /* N, MEAN, VAR */
             step();
             output();
             step();
             output();
             strcpy(_type_, "CONTR");
             y = c1[c];
             output();
             y = c2[c];
             output();
           }
        }
       ftest("amd173.mns.con", "y treat block", "treat*block", "", "");
     
     /* The second F-test (p. 176-77) is the treat effect:
      * m11 + m13 - m21 - m23 = 0 and m21 + m22 - m31 - m32 = 0
      */
       inset("amd173.mns") /* file from model statement */
        {
          char treat[3], block[3]; /* we're in C here! */
          double y;
          char _type_[9]; /* set this to CONTR */
          int _term_;     /* bits specify the effect */
          double c1[7], c2[7]; /* coeffs of the contrasts */
          int c; /* cell number */
          outset("amd173.mns.con", "treat block y _term_");
          /* cells, in sort order, are:
          /*   11      13       21      22       23       31      32 */
          c1[0]=1;c1[1]=1;c1[2]=-1;c1[3]=0;c1[4]=-1;c1[5]= 0;c1[6]= 0;
          c2[0]=0;c2[1]=0;c2[2]= 1;c2[3]=1;c2[4]= 0;c2[5]=-1;c2[6]=-1;
          _term_ = 1; /* bit 1 for treat */
          for (c = 0; step(); c++) /* while there's another cell */
           {
             output(); /* N, MEAN, VAR */
             step();
             output();
             step();
             output();
             strcpy(_type_, "CONTR");
             y = c1[c];
             output();
             y = c2[c];
             output();
           }
        }
       ftest("amd173.mns.con", "y treat block", "treat", "", "");
     }


File: dap,  Node: Linear regression examples,  Next: Categorical data analysis examples,  Prev: Analysis of variance examples,  Up: Examples

Linear regression
=================

     /* Bickel, P.J. and Doksum, K.A. 1977
      * Mathematical Statistics:
      * Basic Ideas and Selected Topics
      * Holden-Day: Oakland. 493.pp.
      * Example pp. 95 - 97.
      */
     
     data;
       infile "ms95.dat" firstobs=2;
       input soilphos plantphos;
     
     proc reg;
      model plantphos = soilphos;
      plot phantphos * soilphos;

     /* Rao, C.R. and Toutenberg, H. 1995 using SBS
      * Linear Models: Least Squares and Alternatives
      * Springer-Verlag: New York. 352 pp.
      * Example pp. 50 - 60.
      */
     
     data;
       infile "lm50.dat" firstobs=2;
       input y x1 x2 x3 x4;
     
     proc corr;
      var x1 x2 x3 x4 y;
      title "Correlations";
     
     proc reg;
      model y = x4;
      title "Model building";
     
     proc reg;
      model y = x4;
      add x1;
     
     proc reg;
      model y = x4 x1;
      add x3;
     
     proc reg;
      model y = x4 x1 x3;
      add x2;


File: dap,  Node: Categorical data analysis examples,  Next: Logistic regression examples,  Prev: Linear regression examples,  Up: Examples

Categorical data analysis
=========================

   These examples are from CDA: Agresti, A.  1990.  Categorical Data
Analysis.  John Wiley & Sons: New York.  558pp.

     /* CDA pp. 49 - 50 using SBS */
     
     data;
      infile "cda50.dat" firstobs=2;
      length income $ 5 jobsat $ 10;
      input income jobsat count;
     
     proc freq;
      tables income * jobsat / measures chisq expected
                               norow nocol nopercent;
      weight count;

     /* CDA pp. 232 - 233 using SBS */
     
     data;
      infile "cda233.dat" firstobs=2;
      length penicillin $ 5 delay $ 4 response $ 5;
      input penicillin delay response count;
     
     proc freq;
      tables penicillin * delay * response / norow nocol nopercent cmh;
      weight count;

     /* CDA pp. 135 - 138, 171 - 174, 176 - 177
      * Here we fit loglinear models in table 6.3 on p. 172
      */
     #include <dap.h>
     
     void main()
     {
       infile("cda171.dat", " ")
         {
           char defendant[6], victim[6], penalty[4];
           double n;
           input("defendant victim penalty n");
           outset("cda171", "");
           skip(2);
           while (step())
             output();
         }
     
       sort("cda171", "defendant victim penalty", "");
     
       title("(DV, P) vs (D, V, P)");
       loglin("cda171.srt", "n defendant victim penalty",
              "victim penalty defendant", "defendant*victim penalty", "");
     
       sort("cda171.srt.llm", "defendant victim _type_ penalty", "");
       table("cda171.srt.llm.srt", "defendant victim", "_type_ penalty n",
             "s6.2 30", "");
     
       title("(DV, VP) vs (DV, P)");
       loglin("cda171.srt", "n defendant victim penalty",
              "defendant*victim penalty",
              "defendant*victim victim*penalty", "");
       sort("cda171.srt.llm", "defendant victim _type_ penalty", "");
       table("cda171.srt.llm.srt", "defendant victim", "_type_ penalty n",
             "s6.2 30", "");
     
       title("(DV, DP, VP) vs (DV, VP)");
       loglin("cda171.srt", "n defendant victim penalty",
              "defendant*victim victim*penalty",
              "defendant*victim defendant*penalty victim*penalty", "");
       sort("cda171.srt.llm", "defendant victim _type_ penalty", "");
       table("cda171.srt.llm.srt", "defendant victim", "_type_ penalty n",
             "s6.2 30", "");
     }


     /* CDA pp. 261 - 269
      * Here we fit the logit model for linear-by-linear association
      * to Table 8.2 on page 268.
      */
     #include <dap.h>
     
     double expect(double param[8], double class[2]);
     
     void main()
     {
       infile("cda262.dat", " ")
         {
           char Income[6], JobSat[10];
           double income, jobsat, count;
           input("Income JobSat count");
           outset("cda262", "");
           skip(1);
           while (step())
             {
               /* we have to convert to double for categ */
               if (!strcmp(Income, "<6"))
                 income = 0.0;
               else if (!strcmp(Income, "6-15"))
                 income = 1.0;
               else if (!strcmp(Income, "15-25"))
                 income = 2.0;
               else if (!strcmp(Income, ">25"))
                 income = 3.0;
               if (!strcmp(JobSat, "VeryDis"))
                 jobsat = 0.0;
               else if (!strcmp(JobSat, "LittleDis"))
                 jobsat = 1.0;
               else if (!strcmp(JobSat, "ModSat"))
                 jobsat = 2.0;
               else if (!strcmp(JobSat, "VerySat"))
                 jobsat = 3.0;
               output();
             }
         }
     
       {
         double param[8];
         int p;
     
         param[0] = 1.0;
         for (p = 1; p < 8; p++)
           param[p] = 0.0;
         categ("cda262", "count income jobsat", &expect, param,
               "mu <6 6-15 15-25 VD LD MS ?Inc*Sat", "", "");
         sort("cda262.cat", "income _type_ jobsat", "");
         table("cda262.cat.srt", "income", "_type_ jobsat count", "6.2", "");
       }
     }
     
     /* We use an independent subset of the parameters in order to
      * incorporate the zero-sum constraints. Thus, if class[0] == 3,
      * for example, then we use the fact that lambda^{income}_{>25} is
      * minus the sum of the other lambda^{income} parameters.
      */
     double expect(double param[8], double class[2])
     {
       double lx, ly;
     
       if (class[0] < 3.0)
         lx = param[1 + (int) class[0]];
       else
         lx = -(param[1] + param[2] + param[3]);
       if (class[1] < 3.0)
         ly = param[4 + (int) class[1]];
       else
         ly = -(param[4] + param[5] + param[6]);
       return exp(param[0] + lx + ly + param[7] * class[0] * class[1]);
     }


File: dap,  Node: Logistic regression examples,  Next: Standard graphical output,  Prev: Categorical data analysis examples,  Up: Examples

Logistic regression
===================

     /* Agresti, A.  1990.  Categorical Data Analysis.
      * John Wiley & Sons: New York.  558pp.
      * Example pp. 87 - 89 using SBS with proc dap
      */
     data cda88;
       infile "cda88.dat" firstobs=2;
       input labind ncases nremiss;
     
     proc dap;
     nport(plotlogreg("cda88", "nremiss/ncases", "labind",
                      "== MAXX40 NXTICKS5 MAXY1 NYTICKS6 NYDIGITS2 NXDIGITS1",
                      5, "", 1, 0.95), 4, 4);


File: dap,  Node: Standard graphical output,  Next: Custom graphics,  Prev: Logistic regression examples,  Up: Examples

Standard graphical output
=========================

     /* Using plotmeans to plot means, both as symbols
      * and joined by lines, and 95% confidence intervals
      * of two groups of data together.
      */
     #include <dap.h>
     
     void main()
     {
     infile("standard.dat", " ")
       {
         int part;
         double x, y;
     
         input("x y part");
         outset("mtest", "");
         while (step())
           output();
       }
     
     title("Means of y. Error bars are 95% confidence for means");
       {
         pict *p;
     
         sort("mtest", "part x", "");
         p = plotmeans("mtest.srt", "y", "x", "SEM 1.96", "part", 2);
     /* p[0] and p[1] are error bars and means as points for group 1 */
         strcpy(p[1].pict_type, "TRIA");
     /* p[2] and p[3] are error bars and means as points for group 2 */
         strcpy(p[3].pict_type, "SQUA");
     
         nport(p, 4, 4);
       }
     }


File: dap,  Node: Custom graphics,  Prev: Standard graphical output,  Up: Examples

Custom graphics
===============

     /* This example illustrates the construction
      * of custom graphics.  We create two distributions
      * and display them as a split histogram: the bars
      * of one distribution extend horizontally to the
      * left and the bars of the other extend
      * horizontally to the right and are shaded.
      */
     #include <dap.h>
     
     #define NBARS 10
     
     void main()
     {
      /* these variables are not in the datasets */
     double min, max;  /* extremes of both
                        * distributions together
                        */
     double width;     /* width of the bars */
     
     infile("custom.dat", " ")
       {
         double x;
         int part;
     
         input("x part");
         outset("split", "");
         while (step())
           output();
       }
     
     means("split", "x", "MIN MAX", ""); /* find min, max */
     inset("split.mns")
       {
         double x;
         int n;
         char _type_[9];
     
         for (n = 0; n < 2; n++)
           {
             step();             /* and store them */
             if (!strcmp(_type_, "MIN"))
               min = x;
             else
               max = x;
           }
       }
     
     width = (max - min) / ((double) NBARS);
     
     inset("split")      /* compute class for each x */
       {
         double x;
         int class;
     
         outset("class", "x class part");
         while (step())
           {
             class = (int) floor((x - min) / width);
             if (class < 0)
               class = 0;
             else if (class > NBARS - 1)
               class = NBARS - 1;
             output();
           }
       }
     
     sort("class", "part class", "");
     /* compute counts in each class for each distribution */
     means("class.srt", "count", "N", "part class");
     
       {
       pict p[21];  /* one pict for each class for each part
                     * plus one for the axes
                     */
       int pn;
     
       pict_initpict(NULL, p);  /* initialize the pict structs */
       for (pn = 1; pn < 21; pn++)
         pict_initpict(p + pn - 1, p + pn);
     
       inset("class.srt.mns")
         {
           int part, class;
           double classmin, count;
     
           while (step())
             {
               classmin = min + width * ((double) class);
               /* make a rectangle */
               pict_rectangle(p + NBARS * part + class,
                   0.0, classmin, (part ? count : -count), width);
               /* shade the ones on the right */
               if (part)
                 p[NBARS * part + class].pict_fgray = 0.8;
             }
         }
       /* set up the axes */
       pict_autoaxes(p, "Count", "X", "==", &fabs, NULL,
                               "Split histogram", 1);
       /* and make it all appear */
       pict_port(1);
       pict_page();
       pict_show(p);
       pict_end();
       }
     }


File: dap,  Node: Appendix I,  Next: Appendix II,  Prev: Examples,  Up: Top

Appendix I: Settable parameters
*******************************

   The following list of settable parameters and their default values
is in `dap.h':

     /* Parameters for variables */
     DAP_MAXVAR 256  /* max number of variables in a dataset */
                     /* if changed to >= 10,000, change dimstr in dap0.c */
     DAP_NAMELEN 15  /* max length of variable names (+1 for null) */
     DAP_INTLEN 20  /* max number of char in char representation of int */
     DAP_LISTLEN (256 * (16 + 6))
      /* max length of list of variables: dap_maxvar *
       * (max var name length + room for bracketed index)
       * This may not be entirely safe! (but most likely is)
       */
     DAP_TOOLONG 10 /* max # times to print "string too long" message */
     DAP_STRLEN 63  /* max length of some string values */
     
     /* Parameters for tables */
     DAP_MAXROWS 1024  /* max rows for table() */
     DAP_MAXCOLS 64  /* max columns for table() */
     DAP_MAXCLAB 128  /* max number of column labels */
     DAP_MAXROWV 8  /* max number of row variables */
     DAP_MAXCOLV 8  /* max number of column variables */
     DAP_LABLEN 63  /* max number of non-null char in column label */
     
     /* Parameters for datasets */
     DAP_SETDIR "dap_sets"  /* where datasets are stored */
     DAP_MAXVAL 32768  /* max number of values for some stat functions*/
     DAP_MAXCELL 512  /* max number of cells in some internal tables */
     DAP_MAXTREAT 9  /* max number of factors for ANOVA */
     
     /* Parameters for grouping */
     DAP_MAXBARS 128  /* max number of bars for histograms, grouping */
     DAP_MAXLEV 96  /* max number of levels of a variable */
     
     /* Parameters for I/O */
     DAP_LINELEN 2047  /* max number of char for input line (+1 for null) */
     DAP_OUTREPORT 100000
        /* report multiples of this number of lines written */
     
     /* Parameters for graphics */
     DAP_MAXPTS 16384  /* max number of points in a pict */
     DAP_MAXCHAR 65536  /* max number of text chars in all the picts */
     DAP_MAXNTXT 128  /* max number of text chars in a pict */
     DAP_MAXTXT 127   /* max number of chars in a single string */
     DAP_MAXFONT 63   /* max number of chars in a font name */
     
     /* Parameters for numerical algorithms */
     DAP_REDTOL 1e-9 /* to tell if row is zero in reduction */
     DAP_ORTHTOL 1e-9 /* to tell if row is zero in orthog */
     DAP_ZEROTOL 1e-6 /* to tell if row is zero in matrix ops */
     DAP_TOL 1e-8    /* for pivoting, etc. in matrix ops */
     DAP_CTOL 1e-6   /* for iterative reweighted least sq (logreg) */
     DAP_KTOL 1e-6   /* for significance of Kolmogorov statistic */
     DAP_PRTOL 1e-6  /* for inverse prob functs: should disappear */
     DAP_ADDTOZERO 1e-8  /* for contingency tables */
     DAP_MAXITER 500 /* max number of iterations */
     DAP_MAXEX1 20  /* max number of values for exact test */
     DAP_MAXEX2 20  /* max number of values for exact test */
     DAP_CATTOL 0.0000005 /* tolerance for convergence in categ() */
     
     /* Parameters for memory files */
     DAP_NRFILES 128  /* number of files stored in memory */
     DAP_RFILESIZE 16384  /* max number of bytes in a memory file */
     DAP_MAXLINES 2048  /* max number of lines in memory file:
                         * keep at dap_rfilesize / 8
                         */
     DAP_MAXMEM 1048576 /* memory buffer size for sorting */
     DAP_TMPDIR "dap_tmp" /* directory for temporary files for sorting */
     
     /* Memory allocation tracing */
     DAP_MEMTRACE NULL  /* if non-NULL, print trace of malloc and free
                         * and if address = dap_memtrace, then...
                         */
     DAP_MABORT 0  /* abort on malloc */
     DAP_FABORT 0  /* abort on free */


File: dap,  Node: Appendix II,  Next: Appendix III,  Prev: Appendix I,  Up: Top

Appendix II: Essentials of C syntax
***********************************

   This appendix explains the most basic syntax of C needed for using
dap.  There are many books to which you can refer for more detailed or
more advanced descriptions of C.  Note that the GNU editor `emacs' has
special provisions for editing C programs.

* Menu:

* Variables and operations::
* Functions::
* Loops and `if's::


File: dap,  Node: Variables and operations,  Next: Functions,  Prev: Appendix II,  Up: Appendix II

Variables and operations
========================

   A "variable" is a box in which one or more numbers or characters, or
even more complicated objects called "structures", are stored.  You
_must_ use a "declaration" to indicate exactly what kind of contents
the box will hold and what name you are going to use to refer to the
box before you use the box to store anything or else the computer won't
know what kind of information is stored in the box and how to use it.
(Names must contain only letters and numbers and `_' and must not start
with a number.)  For example,

     int n;

is a declaration that indicates that the box named `n' will hold an
integer (whole number).  Non-integer numbers, such as `2.718', are
referred to as "double precision floating point" numbers, or simply as
"doubles".  For example,

     double x;

is a declaration that indicates that the box named `x' will hold a
double.  There is a special value called "NaN", which stands for
"Not-a-Number", for undefined values of a double.

   Numbers and characters and structures can each be grouped into
ordered collections known as "arrays"; arrays of characters are called
"strings".  For example, the declaration

     char employee[21];

indicates that the box named `employee' will hold a string of 21
characters, say, the employee's name.  The last character of a string
of characters is usually used to hold a special character that marks
the end of the string, so that `employee' will really be limited to 20
ordinary characters.  The character that marks the end of a string is
called the "null character" and is denoted `\0'.

   You can also declare, for example,

     double y[3];

to indicate a box that will hold 3 doubles.  Brackets `[' and `]' also
allow you to refer to the individual doubles in the array: the three
elements of `y' are `y[0]', `y[1]', and `y[2]'.  (The numbering of
array elements always starts at 0.)  Such referencing can be used for
arrays of characters, integers, or structures, too.

   The most common kind of structure in dap is the `pict' structure,
which contains graphical information that is used by graphics
functions; `pict's are most often collected into arrays.  In some cases
you may not know for certain or care how many `pict' structures are in
the array, in which case you can use a declaration like this:

     pict *p;

which indicates that the graphics function that sets up the array of
picts to be stored in the box named `p' will allow for however many
picts that graphics function needs.  In this case, `p' is usually
referred to as a "pointer" to `pict', and in that sense, `p' is
interpreted as the location in the computer's memory of the first
`pict' in the array.  Nevertheless, you can still refer to the `pict's
in the array as `p[0]', `p[1]', etc.

   The pointer concept, as a location in the computer's memory, is used
in other contexts, too.  One use is to be able to distinguish between a
string that has no interesting characters in it, that is, a string
whose first character is the null character, and a string that doesn't
exist at all.  The former is called a "null string", and is denoted
`""', and the latter is called a "null pointer", and is denoted `NULL'.
Another use of pointers involves functions, which are described in the
next section.  Functions have locations in the computer's memory and
can be referred to by pointers: if `f' is a function, then `&f' is a
pointer to that function.

   There are many operations that can be used on variables, but the
most common operations are copying and arithmetic operations.  For
example, the "statement"

     x = y + z;

computes the sum of the numbers in the boxes named `y' and `z' and
copies that sum into the box named `x'; note that the contents of `y'
and `z' are unchanged.  Note that the paradoxical-looking statement

     x = -x;

says to copy the negation of the contents of `x' back into `x'.
Copying strings is more complicated and is described in the next
section.

   Two very common arithmetic operations that can be used only on `int'
variables are `++', `--':  For example, the statement

     n++;

increments, i.e., increases by 1, the number stored in `n'.  Similarly,

     n--;

decrements, i.e., decreases by 1, the number stored in `n'.


File: dap,  Node: Functions,  Next: Loops and `if's,  Prev: Variables and operations,  Up: Appendix II

Functions
=========

   "Functions" are program parts that are usually stored in "libraries"
and can be used from a program.  For example, a dap program could
contain the statement

     means("data", "x", "SUM", "");

which "calls", i.e., uses, the function `means', which is stored in a
library that is supplied with dap, to compute the sum of the values of
the variable `x' in the dataset `data'.  The comma-separated, quoted
strings `"data"', `"x"', `"SUM"', and `""' are called "arguments" to
the function and they tell the function what to operate on and how.
This particular function will create a dataset named `data.mns' that
will contain the computed sum.

   Two functions that are not supplied with dap but that are available
nonetheless in the standard C library and that are commonly used in dap
programs are `strcpy' and `strcmp'.  The first is used for copying
strings and the second is used for comparing strings.  For example,
following the declaration

     char employee[21];

you could write the statement

     strcpy(employee, "Bassein, Susan");

which calls the `strcpy' function to copy the 14 characters between the
quotes into the string `employee' and follow it with the null
character, for a total of 15 characters.  NOTE: An explicit string of
characters must be enclosed in double quotes ("..."), not single quotes
('...').  WARNING: Serious program bugs can be caused by copying more
characters into a string than are allotted in the declaration!

   The `strcmp' function is typically used in loops and `if's and is
described in the next section.

   Functions can also "return a value", which means that the function
can provide a value that can be copied into a variable.  For example,
after the declaration

     int more;

you could write

     more = step();

   This statement calls the function `step', which attempts to read one
line from the input data file or dataset and then returns the integer 1
or 0, if there was or was not, respectively, another line to be read
from the file or dataset.  (Note that although `step' does not require
any arguments, the parentheses are still necessary, to identify it as a
call to a function.)  Thus, `more' would contain the value 1 if `step'
successfully read another line or the value 0 if the previous call to
`step' had read the last line in the input data file or dataset.

   You can also define functions in your program.  In particular, `main'
is a function that must appear in every dap program.  The "body" of the
definition of a function must always be enclosed between `{' and `}'.
The example program cda262.c (*note Categorical data analysis
examples::) illustrates the definition and use of a function required by
the categorical data analysis function `categ' to compute expected cell
frequencies from parameter values.


File: dap,  Node: Loops and `if's,  Prev: Functions,  Up: Appendix II

Loops and `if's
===============

   "Loops" allow an action to be repeated, either until some condition
arises or for a fixed number of times.  The most common loop in dap
programs looks like this (with possible enhancements):

     while (step())
       output();

This loop repeats reading a line from the input data file or dataset
and writing the data to the output dataset until there are no more
lines to be read.  More specifically, it attempts to read a line and if
there was a line to be read, it writes the data to the output dataset
and attempts to read the next line; otherwise it "breaks out of the
loop" and continues to the next line of the program.  Note that a value
of 1 (or, in fact, any non-zero value) is taken to mean "TRUE" and a
value of 0 is taken to mean "FALSE", so that these lines can be
interpreted as saying, "While (i.e., as long as) it is TRUE that step
has read another line, output the data from that line".

   A `for' loop can be used to read, say, the first 100 lines of the
input data file or dataset:

     int n;
     
     for (n = 1; n <= 100; n++)
       {
         step();
         output();
       }

The `for' statement has three parts within the parentheses, separated
by semi-colons: the "initialization", `n = 1', which starts the loop;
the "test", `n <= 100', which acts as though it is inside the
parentheses in a `while' statement; and the "increment", `n++', which
gets performed after each repetition of the body of the `for' loop.
(Note that the body of the `for' in this case must be enclosed between
`{' and `}' because, unlike the body of the `while' above, it contains
more than one statement.)

   The previous example will fail if there are fewer than 100 lines in
the input data file or dataset because `step' will stop your program if
you try to read another line of the input data file or dataset after a
previous call to `step' has returned a 0.  One better alternative would
be to use an `if':

     int n;
     
     for (n = 1; n <= 100; n++)
       {
         if (step())
           output();
         else
           break;
       }

In this example, the `break' causes the program to break out of the loop
when `step' returns a 0.

   Suppose you wanted to write into the output dataset all the lines
from the input data file for which the `employee' was named "Bassein,
Susan".  You could use the "logical negation" operator `!' with the
string comparison function `strcmp' as follows:

     char employee[21];
     
     while (step())
       {
         if (!strcmp(employee, "Bassein, Susan"))
           output();
       }

because `strcmp' returns 0 if the strings are the same and a non-zero
number otherwise and `!' turns a 0 into a 1 and a non-zero integer into
0.

   The C language provides two operators that allow you to combine
conditions to be tested in `while', `for', and `if' statements: logical
"and", `&&', and logical "or", `||'.  For example, the previous code
could be modified to select only those records for "Bassein, Susan"
that had a value greater than or equal to 10 for a variable named
`hours':

     char employee[21];
     double hours;
     
     while (step())
       {
         if (!strcmp(employee, "Bassein, Susan") && hours >= 10.0)
           output();
       }


File: dap,  Node: Appendix III,  Next: Appendix IV,  Prev: Appendix II,  Up: Top

Appendix III: Troubleshooting
*****************************

   Many things can go wrong with a program.  At the simplest level,
there can be an error in "syntax", which would cause the preprocessor
or the compiler to be unable to interpret what is meant by a statement.
For example, a syntax error commonly made by novices is to forget to
include the semi-colon that is required at the end of every declaration
or statement.  Another common error is to have a left brace `{' without
a matching right brace `}' (or vice versa); using appropriate
indentation in your program and the features of your text editor will
help you find unmatched braces.  If your program has a syntax error,
you will get a message indicating the line number of the statement
containing the error and why the preprocessor or the compiler couldn't
interpret that statement.  (Missing semi-colons often confuse the
compiler so badly that the error message can be hard to interpret.)  In
that case, you simply edit your program to correct the error and
compile and run it again.

   If your program uses too many variables, lines that are too long,
variable names or strings that are too long, etc., then you will get a
message that indicates the problem during execution.  You can solve
that problem by setting the value of the appropriate parameter as
described in *Note Reading files and datasets::.

   More serious bugs will result in the program "crashing", which means
that the program will stop before completing its task, often with no
output of any sort.  In that case, the system will produce a file named
`core', which is a snapshot of what point the program reached when it
crashed.  If that happens, exit dap and use a "debugger" to examine the
core file.  For example, to use the GNU debugger `gdb' on the core file
produced by a crash in prog.c, you would type

     gdb prog.dap core

Then, typing

     where

will tell you the number of the line reached by your program, and the
functions that it called, when the program crashed.  A debugger is a
powerful and somewhat complicated program; you should read at least
some of its documentation before you use it.

   If a program doesn't crash but still doesn't produce output, most
probably it is executing in an "infinite loop", that is, a loop whose
condition for terminating is never met.  Such a situation is
particularly dangerous if there is a call to `output' in tha loop, so
that more and more lines are being written to the output dataset, which
therefore runs the risk of completely filling up your disk.  You can
terminate a program by typing "control-C" (_twice_, if you are using the
Emacs interface) which means pressing both the `Control' (or `Ctrl')
key and the `C' key at the same time.

   Still more serious bugs will result in the program giving nonsense
results.  Often, you can track down such bugs by inserting calls to the
dap `print' function at strategic points in your program, and running
the program again, to display intermediate files to see where the
program started to have problems.  If that fails, a debugger is a good
tool for tracking down unintended values of your variables.

   The most serious bugs will result in the program giving
sensible-looking but wrong results.  To catch bugs of that sort
requires a thorough understanding of approximately what your results
should look like, some experience with the statistical functions you
are using, and a lot of patience.


File: dap,  Node: Appendix IV,  Next: FAQ,  Prev: Appendix III,  Up: Top

Appendix IV: SBS
****************

   This section contains miscellaneous notes and warnings regarding the
use of SBS.  WARNING: When processing FILE.sbs, dap writes (or
overwrites) the file FILE.c. Note that because the syntax and options
of SBS and dap graphics procedures are not very compatible, many dap
graphics options are not available in SBS (which is one reason that I
wrote dap in the first place); for complete access to dap graphics
options (or statistical options) from SBS, use a `proc dap' statement
(see below).  In addition, you can define your own functions in a
separate `.c' file that you include on the command line to run dap. (To
declare such functions in the `.sbs' file, use a `proc dap' statement
at the beginning of the file.)  Note that if the program does not use a
graphics proc, compiling will produce a number of warnings about unused
variables, all of whose names begin and end with an underscore `_'; you
may ignore them.

   One peculiarity that SBS inherits from C through dap is that
character variables that are explicitly used in a data step always need
to appear in a `length' statement, no matter whether the data step gets
its data from a `set', a `merge' or an `infile' statement.

   Important notes regarding data steps (at least through this version
of dap):

  1. Comparison, assignment, and concatenation of strings must be
     performed using the C functions `strcmp' (or its variants),
     `strcpy' (or its variants), and `strcat' (or its variants);

  2. C-style subscripting (i.e., with `[ ]') must be used for obtaining
     individual characters from a string except that in SBS, array
     indexes start at 1, not 0 as in C.

  3. Mnemonics are not accepted for relational or logical operators
     (e.g., `ne' is not accepted for `^=');

  4. The only statements accepted in the body of a data step, other
     than numerical assignment statements, are `if-then',
     `if-then-else', `do', `do while', `end', and `output';

  5. FIRST.variable is allowed by `by' groups, but not LAST.variable.

  6. Syntax errors in the body of a data step may not be caught by the
     SBS-to-dap translator, but will subsequently be caught by either
     the dap preprocessor or the C compiler. However, the line numbers
     referred to by those programs will be the line numbers of the dap
     program into which your SBS program was translated, which you can
     view by opening up file FILE.c if you ran dap on FILE.sbs.


     data [OUTPUT-FILE-NAME [({drop | keep}=VARIABLE [... VARIABLE])];
     length VARIABLE-1 $ LENGTH-1 [... VARIABLE-N $ LENGTH-N];
     infile "INFILE-NAME" [{delimiter | dlm}="DELIMETER"]
                            [firstobs=N];
     input VARIABLE-1 [START-COL-1 [-END-COL-1]]
           [... VARIABLE-N [START-COL-N [-END-COL-N]]];
     set DATASET-NAME;
     merge DATASET-NAME-1 [({drop | keep}=VARIABLE [... VARIABLE])]
          DATASET-NAME-2 [({drop | keep}=VARIABLE [... VARIABLE])];
     by VARIABLE-LIST;
     {drop | keep} VARIABLE-LIST;

     SBS note: for column input, it is not possible to skip columns,
     i.e., `start-col-1' must be 1 and each succeeding `start-col' must
     be one more than the preceeding `end-col'.

     proc dap;
     DAP-STATEMENT

     SBS note: DAP STATEMENT can either be enclosed in braces `{ }' or
     end with a semi-colon `;'. Attempting to use dap graphics and SBS
     graphics in the same program will produce unpredictable and,
     perhaps, undesirable results. Note that DAP STATEMENT is run as-is
     by dap and, in particular, indexes of array subscripts start at 0.
     The DAP STATEMENT cannot use the `0x' prefix for hexidecimal
     numbers.


File: dap,  Node: FAQ,  Next: Index,  Prev: Appendix IV,  Up: Top

Frequently Asked Questions
**************************

* Menu:

* I cannot find a function::
* I want to split a dataset::
* Logistic regression reported a singular matrix::
* How do I add a line to a plot?::


File: dap,  Node: I cannot find a function,  Next: I want to split a dataset,  Prev: FAQ,  Up: FAQ

I cannot find a function
========================

   Q: I cannot find a function to delete spurious zeros from my dataset
without deleting anything else. What do I do?

   A: You have to write some C code (*note Appendix II::) for that:
     while (step())
       {
         if (yield > 0.0)
           output();
       }


File: dap,  Node: I want to split a dataset,  Next: Logistic regression reported a singular matrix,  Prev: I cannot find a function,  Up: FAQ

I want to split a dataset
=========================

   Q: I want to split a dataset based on the value of a variable. How
do I do that?

   A: Assume that the variable to be used is a character variable named
`part' with 9 characters (including the terminating null) and that
dataset `set' is sorted by `part'.  The following code fragment creates
a dataset for each value of `part' and names it that value.

     inset("set")
       {
         char part[9];
         int partv[1];
     
         daplist("part", partv, 1);
         if (step())  /* to get started */
           {
             outset(part, "");
             output();
             while (step())  /* to continue */
               {
                 if (dap_newpart(partv, 1))
                   outset(part, "");
                 output();
               }
           }
       }


File: dap,  Node: Logistic regression reported a singular matrix,  Next: How do I add a line to a plot?,  Prev: I want to split a dataset,  Up: FAQ

Logistic regression reported a singular matrix
==============================================

   Q: Logistic regression reported a singular matrix, but my data seems
OK.

   A: You may need to lower the value of DAP_CTOL (*note Appendix I::),
which is used to zero-out matrix entries that appear to be non-zero
only as the result of round-off errors.


File: dap,  Node: How do I add a line to a plot?,  Prev: Logistic regression reported a singular matrix,  Up: FAQ

How do I add a line to a plot?
==============================

   Q: I plotted a dataset using `plot' and I want to add a line to it.
How do I do that without knowing the scaling and translating used by
`plot'?

   A: In your call to `plot', specify `MINX', `MAXX', `MINY', and
`MAXX'. Don't use `nport' or `nland'; rather use `pict_port',
`pict_land', or `pict_init' to start the graphics section of your
program (and don't forget `pict_page', `pict_show', and `pict_end').
Then declare an array of 2 `pict's and use `pict_initpict' to
initialize them as a list. Then use `pict_line' on the first of these 2
picts and call `pict_autoaxes' with the same axis specifications
(although you can set `NXTICKS' and `NYTICKS' to 0 if you wish).  You
can use the same axis labels, overwrite them, or leave them as null
strings.  Finally, call `pict_show'.

   Here's an example:


     #include <dap.h>
     
     void main()
     {
       infile (NULL, NULL)
         {
           double x, y;
           int n;
           outset("gtest", "");
           for (n = 0; n < 10; n++)
             {
               x = varnorm();
               y = varnorm();
               output();
             }
         }
       {
         pict *p, p1[2];
     
         pict_port(1);
         pict_page();
     
         p = plot("gtest", "x y", "", "== MINX-4 MAXX4 MINY-4 MAXY4",
                  NULL, NULL, 1);
         pict_show(p);
     
         pict_initpict(NULL, p1);
         pict_initpict(p1, p1 + 1);
         pict_line(p1, -3.0, 2.0, 2.0, -1.0);
         pict_autoaxes(p1, "", "",
                       "== MINX-4 MAXX4 MINY-4 MAXY4 NXTICKS0 NYTICKS0",
                       NULL, NULL, "", 1);
         pict_show(p1);
     
         pict_end();
       }
     }

