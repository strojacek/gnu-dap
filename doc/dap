This is dap, produced by makeinfo version 5.1 from dap.texi.

INFO-DIR-SECTION Dap statistics and graphics package
START-INFO-DIR-ENTRY
* Dap: (dap).                The Dap statistics package
END-INFO-DIR-ENTRY


File: dap,  Node: Top,  Next: Overview and invocation,  Up: (dir)

Dap
***

This document describes version 3.5 of the Dap statistics and graphics
package.  Dap is a GNU program.

* Menu:

* Overview and invocation::
* Program structure:: C-style dap programs only
* Datasets:: I/O and management.
* Managing and displaying data:: Processing datasets.
* Statistics functions:: Data analysis.
* Graphics functions:: Presentation.
* Utilities:: Probability and miscellaneous functions.
* Picture functions:: Low level operations on pictures.
* Examples:: Sample programs.
* Appendix I:: Settable parameters
* Appendix II:: Essentials of C syntax
* Appendix III:: Troubleshooting
* Appendix IV:: SBS
* FAQ:: Frequently asked questions
* Index::


File: dap,  Node: Overview and invocation,  Next: Program structure,  Prev: Top,  Up: Top

1 Overview and invocation
*************************

* Menu:

* Description and example::
* Invoking Dap::


File: dap,  Node: Description and example,  Next: Invoking Dap,  Up: Overview and invocation

1.1 Description, an example, and reading this manual
====================================================

Dap is a small statistics and graphics package based on C. As of Version
3.0, dap can read SBS programs to perform basic statistical analyses,
thus freeing the user from learning and using C syntax for
straightforward tasks, while retaining access to the C-style graphics
and statistics features provided by the original implementation (*note
Appendix IV::).  Dap provides core methods of data management, analysis,
and graphics commonly used in statistical consulting practice.  Anyone
familiar with the basic syntax of C programs can learn to use the
C-style features of dap quickly and easily from this manual and the
examples it provides; advanced features of C are not necessary, although
they are available.  (*note Appendix II:: provides a brief description
of the C syntax needed to use those features of dap dependent on it.)
Because dap processes files one line at a time, rather than reading
entire files into memory, it can be used on data sets that have very
large numbers of lines and/or large numbers of variables.

   Dap consists of: an interactive front end that controls editing,
compiling, execution, and viewing; an optional SBS-to-C-style-dap
translator that can convert an SBS program into a C-style dap program; a
preprocessor that facilitates data input and output by converting a
C-style dap program into an ordinary C program; and a library of
statistics functions and graphics functions.  Typical use of dap
involves the following steps:

  1. Obtain, or use a text editor to create, one or more data files in
     acceptable formats.
  2. Invoke (i.e., run) 'dap' to create or view an SBS or C-style dap
     program that will read and process the data file(s) to produce
     tables and/or graphics.  (See *note Invoking Dap:: to find out how
     to run dap.  If you want to use the C-style features of dap and are
     unfamiliar with C, read *note Appendix II:: before creating your
     C-style dap program.)
  3. Tell dap to compile (i.e., translate into machine usable form) your
     SBS or C-style dap program and execute (i.e., run) your program.
  4. If the previous step was successful, view your tables and/or
     graphics; otherwise, if there are errors in your program, you will
     have to edit your program further and repeat Step 3.

   The following program examples illustrate the basic structure of
simple SBS and C-style dap programs and how functions in the library are
used in dap.

     /* A SIMPLE SBS PROGRAM */
     data;                  /* Begin data step */
      infile "two" delimiter="\t" firstobs=2;
                            /* The infile statement: identifies "two" as
                             * the file to read from, specifies that
                             * the delimiter is a tab, i.e. the numbers
                             * in each line in "two" are separated by a
                             * single tab character, and directs the
                             * program to skip one header line and start
                             * data input on the second line of the file "two".
                             */
      input x y;            /* The first number on each line of "two"
                             * will be held in x and the second number
                             * will be held in y
                             */
     proc plot;             /* Run the plot procedure to display a scatter-plot... */
      plot y * x / box;     /* ...using y for the vertical axis and x for the
                             * horizontal and enclosing the plot in a box
                             */

     /* A SIMPLE C-STYLE DAP PROGRAM */
     #include <dap.h>       /* REQUIRED: includes prototypes of
                             * statistics and graphics functions
                             */

     void main()            /* REQUIRED: main runs everything */
     {
     /* This part of the program reads in data from an ordinary file
      * and writes it out to a dataset, which is the kind of file
      * on which the library functions can operate to perform
      * exploratory data analysis, graphical interpretation, and
      * statistical analyses.
      */
     infile("two", "\t")    /* The infile statement: identifies "two" as
                             * the file to read from and specifies that
                             * the delimiter is a tab, i.e. the numbers
                             * in each line in "two" are separated by a
                             * single tab character
                             */
       {                    /* Beginning of infile statement body */
       double x, y;         /* specify that x and y are variables that
                             * hold "double-precision floating point"
                             * numbers, i.e., numbers that are not
                             * necessarily whole numbers
                             */
       input("x y");        /* The first number on each line of "two"
                             * will be held in x and the second number
                             * will be held in y
                             */
       outset("xyset", ""); /* Create a dataset "xyset" and write all
                             * the variables to it
                             */
       skip(1);             /* The data file contains 1 header line;
                             * skip it
                             */
       while (step())       /* Read in the file, one line at a time */
         output();          /* and write it to the dataset "xyset" */
       }                    /* end of infile statement body */

     /* This line runs the plot function to get a scatter-plot, then
      * displays the result graphically using the nport function; the
      * various options used are described in the section for the plot
      * and nport functions.
      */
     nport(plot("xyset", "x y", "", "==", NULL, NULL, 1), 1, 1);
     }

   For each C-style dap function, this manual gives:

  1. SPECIFICATION: This is an abstract template for the function that
     indicates the types of the parameters (string, i.e., array of char,
     double, array of double, int, or array of int), and the return
     value, if any; bold face indicates literal text, ITALICS indicates
     parameters for which you choose your own names.  The corresponding
     SBS template, if available, is also provided.

  2. Description: A description of the functionality and use of the
     function.  If there is a corresponding SBS proc, notes on its usage
     follow.

  3. Code fragment(s): These are one or more examples of calling the
     function, with made-up values for the parameters; for complete
     examples of use, see the final chapter (*note Examples::) or
     consult the index.

   For the SBS templates, the following should be noted.  Elements
within square brackets '[ ]' are optional and some, although permitted,
may have no effect.  Elements within braces '{ }', separated by a
vertical bar '|' are alternatives.  Keywords may be in upper or lower
case.  Single and double quotes must be used as in C, i.e., use double
quotes for strings (whether or not they are one character long) and use
single quotes only for character values.  Not all statements listed
below the 'data' or 'proc' statements are required and multiple
statements of some types may be allowed.


File: dap,  Node: Invoking Dap,  Prev: Description and example,  Up: Overview and invocation

1.2 Invoking Dap
================

To run dap, you must type a command which looks like one of the
following (in which the bracketed items are optional and are described
below):

SPECIFICATION

     dap [-k] [-d] FILE1.c [ FILE2.c ... ] [-a ARG1 ...]
     dap [-keep] [-debug] FILE1.c [ FILE2.c ... ] [-args ARG1 ...]
     dap [-k] [-d] FILE1.sbs [ FILE2.c ... ]
     dap [-keep] [-debug] FILE1.sbs [ FILE2.c ... ]

Description

   The following description is based on using the GNU editor Emacs to
interact with dap.  If you don't use Emacs, you can still use dap, but
in the commands specified above, use 'daprun' in place of 'dap'; in that
case, you will have to open your editor and/or file viewer to edit your
program and view your text output.

   When you type the command to run dap:

  1. The editor Emacs (type the command 'info emacs' for the manual) is
     opened for the named SBS or C-style dap file(s).  Each file is
     created, but is empty, if it doesn't exist.  When you are finished
     editing your file(s), save it (them), but do not exit unless you
     are finished running dap.
  2. Emacs will have a buffer called 'Async Shell Command'; select that
     buffer and you will be asked whether to compile the named SBS or C
     file(s) and run the resulting executable file (if the compilation
     is successful).  If you answer 'y', then dap runs the preprocessor
     on the named SBS or C file(s) to produce FILE1.dap.c [ FILE2.dap.c
     ...  ].  If you answer 'q', then dap stops running (and you can
     either leave Emacs running for some other purpose or exit it).

  3. If the preprocessing is successful, then dap runs a C compiler on
     the preprocessed file(s), linking library functions as necessary,
     to produce FILE1.dap.
  4. If the compilation is successful, then dap removes the 'dap.c'
     file(s) (unless the '-d' or '--debug' option is present) and runs
     the executable FILE1.dap, passing the arguments ARG1, ..., if any,
     and produces FILE1.lst file for tables and FILE1.ps for graphics,
     as requested.  There are Emacs buffers for the 'lst' and 'log'
     files, but you must use 'Revert buffer' in the 'File' menu to see
     the most recent results.  A viewer will be opened for the 'ps'
     file, if it exists.

  5. Each time a dataset or datafile is read through to the end during
     execution, the number of lines read from the dataset or datafile is
     displayed in your 'Async Shell Command' buffer and written to the
     'log' file.  If 'dap_outreport' (*note Appendix I::) is positive
     (default: 100000), then dap reports, in your 'Async Shell Command'
     buffer, each time that an additional 'dap_outreport' lines have
     been written to a dataset; if your program is writing to a dataset
     inside an infinite loop, this helps you abort the program to avoid
     filling up your disk (by holding down the 'Ctrl' key and pressing
     the 'C' key _twice_).

  6. If there were errors or warnings, they will be written to the 'err'
     and you will see them displayed in your 'Async Shell Command'
     buffer.

  7. At this point, you can edit (and save!)  your SBS or C-style dap
     files again or quit.

   If the '-a' or '--args' option is present (C-style dap programs
only), then all the arguments that follow it on the command are passed
to the 'main' in your program as 'argv'.  In all cases, the 'lst' and
'ps' files are removed before the first execution, but if the '-k' or
'--keep' option is present, then the 'lst' file is kept and appended to
from one cycle to the next.  (Keeping the 'lst' file from one cycle to
the next can be useful for exploratory data analysis, such as model
building for linear regression or loglinear models, in which it is
useful to have a record of a succession of analyses without running the
cumulative set of analyses repeatedly.)

   NOTE: If your system uses 'locale's, then you must set your
environment variable 'LC_COLLATE' to 'C' in order to obtain correct
sorting.

   The editor invoked is /usr/bin/emacs unless the environment variable
'DAPEDITOR' specifies a different location for Emacs.  Emacs is invoked
with no options unless the environment variable 'DAPEDOPTS' is set to a
single string of all the options desired.  The compiler used is
/usr/bin/gcc unless the environment variable 'DAPCOMPILER' is set to a
different compiler.  The compiler is invoked with no options unless the
environment variable 'DAPCOMPOPTS' is set to a single string of all the
options desired.  The 'lst' file is displayed in its entirety in its
buffer unless the environment variable 'DAPPAGER' is set to a pager
(such as 'more').  That pager is invoked with no options unless the
environment variable 'DAPPAGEOPTS' is set to a single string of all the
options desired.  The 'ps' file is viewed with /usr/bin/X11/gv unless
the environment variable 'DAPVIEWER' is set to a different graphics
viewer.  The viewer is invoked with no options unless the environment
variable 'DAPVIEWOPTS' is set to a single string of all the options
desired.

   The executable FILE1.dap can be run, or debugged, on its own.  If the
'-a' or '--args' option was used when the source files were processed,
then arguments (without the '-a' or '--args') are used on the command
line.  If you want to use 'gdb' to debug FILE1.dap, include '-g' as one
of your compiler options and use the '-d' or '--debug' option when you
run dap so that the '.dap.c' files will not be removed.

Code fragment(s)

   _Run 'dap' on the file 'tweedle.c':_
     dap tweedle.c

   _Run 'dap' on the file 'tweedle.sbs':_
     dap tweedle.sbs

   _Run 'dap' on the files 'tweedle.c' and 'dee.c':_
     dap tweedle.c dee.c

   _Run 'dap' on the files 'tweedle.sbs' and 'dee.c':_
     dap tweedle.sbs dee.c

   _Run 'dap' on 'tweedle.c'; append to 'tweedle.lst' in each cycle:_
     dap -k tweedle.c
     dap --keep tweedle.c

   _Run 'dap' on 'tweedle.c'; pass arguments '17' and 'dum' to 'main' in
'tweedle.c':_
     dap tweedle.c -a 17 dum
     dap tweedle.c --args 17 dum

   _Run 'dap' on 'tweedle.c'; do not remove 'tweedle.dap.c' for
debugging:_
     dap -d tweedle.c
     dap --debug tweedle.c


File: dap,  Node: Program structure,  Next: Datasets,  Prev: Overview and invocation,  Up: Top

2 Program structure
*******************

This chapter concerns C-style dap programs only.

* Menu:

* Reading files and datasets:: inset and infile and roc import.
* Variables::
* Output files:: 'err', 'log', 'lst', and 'ps'
* The preprocessor:: dappp


File: dap,  Node: Reading files and datasets,  Next: Variables,  Up: Program structure

2.1 Reading files and datasets
==============================

This section and the next apply only to C-style dap programs.  C-style
dap programs are C programs with two additional statement types and
additional library functions to perform statistical and graphical tasks.
All C-style dap programs must contain a line

     #include <dap.h>
to include the dap header file before the function 'main' and any
variable declarations, except that if the program resides in more than
one 'C' file, only one of those files must include 'dap.h' while the
others must include 'dap1.h' instead.  (This is to avoid multiple
definitions of dap parameters.)

   The two additional statement types are 'infile' and 'inset'
statements, which are used to set up input from files and datasets and
which have the following syntaxes:

SPECIFICATION

     infile(DATAFILE, DELIMITER) { ... }
     DATAFILE, DELIMITER: string

     inset(DATASET) { ... }
     DATASET: string

Description

   The body of 'infile' and 'inset' statements may contain local
variable declarations, an 'outset' statement, and statements to process
the input file or dataset.  In addition, the body an 'infile' statement
may contain an 'input' statement.

   The local variable declarations in the body of 'infile' and 'inset'
statements are restricted to the following types:

     double name;
     double name[number];
     double name[string];
     int name;
     int name[number];
     int name[string];
     char name[number];
     char name[string];

   When the dimension of the array is given as a string, that string
must appear in a '#define' somewhere in the file before the declaration.

   A program can generate data without reading from a file.  In that
case, an 'infile' statement is still required, but both arguments can be
given as 'NULL'.

   The delimiter argument to an 'infile' statement can be in one of two
forms, one for delimited fields and the other for fixed-width fields.
If the file to be read is simply delimited text, the the delimiter
argument is a string (not a character) consisting of the single
delimiter character.  If the file has fixed-width fields, then the
delimiter argument is an alternating sequence of any non-numerical
character and numbers that specify the field widths, in order and
without spaces (unless the non-numerical character is a space).  For
example:

     infile("data", "x6x5x8")
     or for sbs
     PROC IMPORT  out = data datafile =  "Pres2007Clustered.csv"  dbms  = csv //support tab and dlm
     delimiter = ',' replace ;  //support getnames=yes/no;
     run ;
specifies three data fields of widths 6, 5, and 8, respectively.

   It is inappropriate to call a dap statistics or graphics function
from within the body of an 'infile' or 'inset' statement; results from
such a call are unpredictable.

   The header file 'dap.h' defines parameters that control the execution
of dap.  For example, 'dap_maxvar' is the maximum number of variables
allowed in any dataset.  To change any of these parameters, use a
preprocessor '#define' line in your program before the line that
includes 'dap.h'.  For example,

     #define DAP_MAXVAR 512
     #include <dap.h>
will set the maximum number of variables to 512 instead of the default
256.  Note that such a '#define' line does _not_ end with a semi-colon.

   It is not necessary to use a '#define' such as the one above if you
do not wish to change the values of the parameters from their defaults.
However, some dap functions have limitations on how many values they can
process at one time and if you have a dataset that is particularly
large, then you may receive a memory allocation error message.  That
message will usually contain a suggestion of which parameter may need
changing.  The parameters available for modification are listed in
Appendix I (*note Appendix I::).

Code fragment(s)

   _Read space-delimited data file 'tweedledee' with values for 'name',
'wages', and 'tips' on each line and write those values to dataset
'tweedledee':_
     infile("tweedledee", " ")
       {
         char name[21];
         double wages, tips;
         input("name wages tips");
         outset("tweedledee", "");
         while (step())
           output();
       }

   _Read from dataset 'tweedledee', compute 'income' as the sum of
'wages' and 'tips', and write to dataset 'tweedledum':_
     inset("tweedledee")
       {
         double wages, tips, income;
         outset("tweedledum", "");
         while (step())
           {
             income = wages + tips;
             output();
           }
       }


File: dap,  Node: Variables,  Next: Output files,  Prev: Reading files and datasets,  Up: Program structure

2.2 Variables
=============

This section applies only to C-style dap programs.  The variables
declared in the body of an 'infile' or 'inset' statement are available
for reading from the specified file or dataset and for writing to the
specified dataset.  It is not necessary to declare all the variables in
an input or output dataset; only those variables that are used
explicitly in a statement in the body of the 'infile' or 'inset'
statement (i.e., not in a quoted string as an argument to a function
such as 'input', 'outset', or 'dap_list'), must be declared.  Avoid
using variable (or function) names that begin with 'dap_' or 'pict_' or
end with 'dap_'.  WARNING: Within an 'inset' statement, if you declare
and set the value of a variable that is already in the dataset
referenced by the 'inset' statement, values that your program gives to
that variable will be overwritten on each call to 'step'.

   Data management, statistics, graphics, and other C-style dap
functions take lists of variables as arguments.  Such lists must always
be given as strings of variable names (sometimes with other
specifications included), separated by spaces (not commas).  Generally,
the null string ("", not 'NULL') is a shorthand for a list of all the
variables in the dataset and 'NULL' is a shorthand for none of the
variables in the dataset.

   Arrays of int or double may be referenced, by the array name with no
brackets or indices, in calls to 'input' and 'outset'.  Individual array
elements, with their bracketed indices, may also be referenced in calls
to those same functions, but not in calls to 'dataset' or 'merge', for
which arrays of int or double must be referenced by the array name, with
no brackets or indices.  For all other C-style dap functions, each
element of an array of int or double that is to be used must appear with
its bracketed index.


File: dap,  Node: Output files,  Next: The preprocessor,  Prev: Variables,  Up: Program structure

2.3 Output: the 'err', 'log', 'lst', and 'ps' files
===================================================

The user's program can write directly to the 'lst' and 'log' files using
stream functions ('putc', 'fputs', 'fprintf', etc.)  on 'dap_lst' and
'dap_log', respectively.  The following function may be called to
display a section header in the 'lst' file:

SPECIFICATION

     dap_head(PARTV, NPARTV)
     PARTV: array of int
     NPARTV: int

Description

   If PARTV is not 'NULL', the header includes the values of the
variables defining a part of the file or dataset (*note Partitioning a
dataset::).  NOTE: 'dap_head' makes a system call to 'time' and calls
the GNU library function 'ctime'; consequently, user-defined functions
with those names will interfere with the date displayed by 'dap_head'.

Code fragment(s)

   _Write header, with current title, if any, to 'lst' file:_
     while (step())
       {
         ...
         dap_head(NULL, 0);
         ...
       }

   _With input dataset sorted by the variables 'state', 'county', and
'city', write header, with current title, if any, and with current
values of 'state', 'county', and 'city', to 'lst' file:_
     int fooparts[3];
     ...
     dap_list("state county city", fooparts, 3);
     while (step())
       {
         ...
         dap_head(fooparts, 3);
         ...
       }

   A title may be specified as part of the section head or as caption in
graphical output by calling:

SPECIFICATION
     title(THE-TITLE)
     THETITLE: string

     title "THE-TITLE";

Description

   The string THE-TITLE may contain newline ('\n') characters for
multi-line titles.  For graphical output captions, subscripts are
specified by enclosing them in vertical bars ('|') and superscripts are
specified by enclosing them in carets ('^').  If a title has been
specified by 'title', then a graphics function that produces a separate
page for each part of a partitioned dataset will include in the caption
the value(s) of the variable(s) defining the partition.

Code fragment(s)

   _Set title for 'dap_head':_
     title("Analysis of variance\nfor crop yields");
     title("CFU per cm^2^ of surface area");


File: dap,  Node: The preprocessor,  Prev: Output files,  Up: Program structure

2.4 The preprocessor: dappp
===========================

The preprocessor, which is named dappp, reads FILE.c, performs the
following four actions to create FILE.dap.c:

  1. Process simple '#defines' of the form:

          #define STRING N

     in which STRING starts with a letter or with '_' and N is a
     positive integer.

  2. Replace 'main' with 'dap_main' so that the 'main' internal to dap
     can set up variables and the output files before calling
     'dap_main'.

  3. Append a semicolon to each 'infile' or 'inset' statement header to
     prepare it for the C compiler.

  4. Append calls to 'dap_vd', 'dap_dl', 'dap_il', and 'dap_sl' after
     declarations in the body of 'infile' and 'inset' statements.

   The 'dap_vd' function tells the internal dap routines the names and
types of variables so that datasets can be processed appropriately.  The
'dap_dl', 'dap_il', and 'dap_sl' functions create links between the
variables in the user's program and the internal dap storage to allow
input and output.  These functions are appended to the last line of the
user's declarations so that line numbers in C compiler messages for
FILE.dap.c correspond exactly to line numbers in FILE.c.


File: dap,  Node: Datasets,  Next: Managing and displaying data,  Prev: Program structure,  Up: Top

3 Datasets
**********

Datasets are data files with an additional first line that specifies the
names and types of the variables whose values follow.  The only other
differences between datasets and data files are that (1) integers and
double precision floating point numbers are encoded as text in a way
that loses no precision and which allows sorting to be performed in the
usual alphanumeric order and (2) the delimiter between fields on a line
is always '|'.  (A consequence of this is that string values cannot
contain '|'.)

   Most C-style dap data management, statistics, and graphics functions
have an argument, called PARTVARS in the specifications, that allows
parts of a dataset to be processed separately.  (SBS programs use a 'by'
statement.)  To do that, first sort the dataset by the values of an
ordered list of variables: each part is defined as a set of lines for
which the values of all of those variables are constant.  Then the same
variables in the same order must be named in the PARTVARS argument of
the function that is subsequently used to process the sorted dataset.
If no partitioning is desired, then PARTVARS should be the null string
("").

   Dap allows datasets that are not too large to be stored in memory
instead of on disk in order to speed processing.  To specify that a
dataset is to be stored in memory, precede the name of the dataset with
a '<' in the call to 'outset' that creates it and in calls to functions
that read it.  Note that a dataset that is stored in memory will not be
retained after the current dap session.

   Only the last section in this chapter, 'Manage datasets', has
information relevant to SBS programs.  For input for SBS programs, see
*Note Appendix IV::.

* Menu:

* Input and output:: input, step, skip, outset, output.
* Positioning within a dataset:: dap_mark, dap_rewind.
* Partitioning a dataset:: dap_list, dap_newpart, dap_swap.
* Modifying output:: dap_save, dap_rest.
* Manage datasets:: dataset.


File: dap,  Node: Input and output,  Next: Positioning within a dataset,  Up: Datasets

3.1 Input and output
====================

SPECIFICATION
     input(VARIABLE-LIST)
     VARIABLE-LIST: string

Description

   The string VARIABLE-LIST is a space-separated list of the names of
the variables, in order, on each line of the data file to be read;
VARIABLE-LIST may contain the names of arrays or individual array
elements.  Do not call 'input' for a dataset.

Code fragment(s)

   _Specify that (the beginning of) each line of the input data file
contains two fields whose values are to be read into the variables
'fert' and 'yield', in order:_
     input("fert yield");

SPECIFICATION
     step()
     RETURNS: int

Description

   Attempts to read one line of the file or dataset specified by
'infile' or 'inset', respectively.  Returns 1 if a line was read, 0 if
EOF was reached before any characters were read; in this latter case,
all input variables retain their values from the previous line.  The
program exits with an error message if 'step' is called after an EOF was
reached.  Missing integer data is read in as 0.  Data of type double
that is missing or is '.' is set to NaN(1).

Code fragment(s)

   _Read all the lines of the current input dataset or data file and
write them to the current output dataset:_
     while (step())
       output();

SPECIFICATION
     skip(NLINES)
     NLINES: int

Description

   Skips NLINES lines of the input data file.  This is useful for
skipping header lines in a data file.

Code fragment(s)

   _Skip 3 lines of the input data file:_
     skip(3);

SPECIFICATION
     outset(DATASET, VARIABLE-LIST)
     DATASET, VARIABLE-LIST: string

Description

   The string DATASET is the name of the data set to be written.  The
string VARIABLE-LIST is either a space-separated list of the names of
the variables to be included in the output data set, a '!' followed by a
space-separated list of the names of the variables to be excluded from
the output data set, or a null string (not 'NULL'), which specifies that
all variables are to be included in the output data set.  The output
data set always includes a variable named '_type_', which is a string of
length 9 (includes terminating null) and which indicates the type of the
observation.  The string VARIABLE-LIST may contain the names of arrays,
without bracketed indices, or individual array elements, but in either
case the entire array is included in or excluded from the output
dataset.

   If the dataset is small and need not be retained after the current
dap session, then DATASET may begin with a '<' to specify that the
dataset is to be stored in memory rather than on disk; this will speed
processing.  The string DATASET must then begin with a '<' in calls to
functions that read it.  If DATASET does not begin with a '<', then
'outset' creates the data set in the subdirectory 'dap_sets' of the
current directory.  If 'dap_sets' does not exist, 'outset' creates it.
A call to 'outset' must be preceded by an 'infile' or 'inset' statement;
if no input file or dataset is desired, you may use 'NULL' as the file
specified by 'infile' and 'NULL' as the delimiter string.

Code fragment(s)

   _Name the output dataset 'tweedledee' and specify that it will
contain the values of the variables 'alice' and 'caterpillar' only:_
     outset("tweedledee", "alice caterpillar");

   _Name the output dataset 'tweedledum' and specify that it will
contain the values of all the variables that are either in the input
dataset or are declared in the current 'infile' or 'inset' statement:_
     outset("tweedledum", "");

   _Name the output dataset 'tweedledum' and specify that it will be
stored in memory, not on disk, and that it will contain the values of
all the variables that are either in the input dataset or are declared
in the current 'infile' or 'inset' statement:_
     outset("<tweedledum", "");

SPECIFICATION
     output()

Description

   Writes one line of data to the output dataset specified by 'outset'.

   ---------- Footnotes ----------

   (1) "Not a Number": see the function 'finite' in the GNU/Linux
Programmer's Manual.


File: dap,  Node: Positioning within a dataset,  Next: Partitioning a dataset,  Prev: Input and output,  Up: Datasets

3.2 Positioning within a dataset
================================

SPECIFICATION
     dap_mark()

Description

   Marks a position in a dataset: a call to 'dap_rewind' rewinds the
dataset to that position.

SPECIFICATION
     dap_rewind()

Description

   Rewinds the input dataset to the location saved by the most recent
call to 'dap_mark'.


File: dap,  Node: Partitioning a dataset,  Next: Modifying output,  Prev: Positioning within a dataset,  Up: Datasets

3.3 Partitioning a dataset
==========================

SPECIFICATION
     dap_list(VARIABLE-LIST, PARTV, NPARTV)
     VARIABLE-LIST: string
     PARTV: array of int
     NPARTV: int
     RETURNS: int

Description

   Fills the array PARTV with the indices of the at most NPARTV
variables whose names are in the space-separated list VARIABLE-LIST.
Returns the number of variables actually listed.

Code fragment(s)

   _With the input dataset sorted by the values of the variables 'first'
and 'last', prepare 'namev' for use in 'dap_head' or 'dap_newpart':_
     int namev[2];
     dap_list("first last", namev, 2);

   _In the function 'foo', prepare 'varv' for use in 'dap_head' or
'dap_newpart':_
     foo(char *varlist)
       {
         int varv[3];
         int numvars;

         numvars = dap_list(varlist, varv, 3);
         ...
       }

SPECIFICATION
     dap_swap()

Description

   Swaps the two most recently read input file or dataset lines so that
the program can complete processing of a part of that file or dataset
after it detects the beginning of a new part.

SPECIFICATION
     dap_newpart(PARTV, NPARTV);
     PARTV: array of int
     NPARTV: int
     RETURNS: int

Description

   Returns 1 if the beginning of a new part, or the end of the file or
the dataset, has been reached, 0 otherwise.

   A collection of variables can be used to define parts of a dataset
for which all the variables in that collection are constant.  For
example, if a dataset 'names' has a variable 'first' that gives a
person's first name and a variable 'last' that gives a person's last
name, then sorting the dataset by 'last' and 'first' will define parts,
each of which contains all the records for one person (assuming no two
people in the dataset have the same first and last name).  The following
example program fragment counts how many records belong to each person;
it is assumed that the dataset has previously been sorted by 'last' and
'first'.  (This example is for illustrative purposes only: the same task
can be done in one line with the 'means' function.)

Code fragment(s)

     inset("names")
       {
         int nrecords;   /* count of records */
         int partv[2];   /* array of numerical ids for variables */
         int more;       /* flag: is there more input? */

         dap_list("last first", partv, 2);  /* sets up numerical ids */
         for (nrecords = 0, more = 1; more; nrecords++)
           {
             more = step();             /* read 1 line or end of dataset */
             if (dap_newpart(partv, 2)) /* test if beginning of part
                                         * defined by last and first
                                         */
               {
                 dap_swap();      /* back to last line in previous part */
                 dap_head(partv, 2);  /* display header for that part */
                 fprintf(dap_lst, "%d records\n", nrecords);
                                      /* display the number of records */
                 dap_swap();          /* back to beginning of new part
                                       * or end of dataset
                                       */
                 nrecords = 0;        /* re-initialize n for new part */
               }
           }
       }


File: dap,  Node: Modifying output,  Next: Manage datasets,  Prev: Partitioning a dataset,  Up: Datasets

3.4 Modifying output
====================

SPECIFICATION
     dap_save()

Description

   Saves the most recently read input file or dataset line so that the
values of the variables can be modified for an additional output.

SPECIFICATION
     dap_rest()

Description

   Restores the most recently read input file or dataset line that was
saved by 'dap_save'.


File: dap,  Node: Manage datasets,  Prev: Modifying output,  Up: Datasets

3.5 Manage datasets
===================

SPECIFICATION
     dataset(OLDNAME, NEWNAME, ACTION)
     OLDNAME, NEWNAME, ACTION: string

     proc datasets;
     append {base | out}=NEWNAME [{data | new}=OLDNAME];
     change OLDNAME-1=NEWNAME-1 [... OLDNAME-N=NEWNAME-N];
     delete FILENAME-1 ... FILENAME-N;

Description

   Performs the specified action on the datasets OLDNAME and, if the
action is not 'REMOVE', NEWNAME.  The string ACTION must contain one of
the words 'APPEND', 'RENAME', 'COPY', 'FILL', or 'REMOVE'.

   'APPEND' appends the dataset OLDNAME at the end of NEWNAME.  For
'APPEND', only those variables existing in NEWNAME are retained from
OLDNAME and if a variable in NEWNAME does not appear in OLDNAME, the
value of that variable is set to the null string if of type string or 0
if of type int or double.

   'RENAME' changes the name of the dataset from OLDNAME to NEWNAME.

   'COPY' may be followed by a space-separated list of variable
specifications, each of which has the form VARIABLE-NAME or
VARIABLE-NAME > NEW-VARIABLE-NAME.  In either case, only the variables
listed will be retained in the copy of the dataset and in the second
case, those variables will be renamed as indicated.  If VARIABLE-NAME
refers to an array, then no index may be specified and the entire array
is retained and, if indicated, renamed.

   'FILL' makes a copy, named NEWNAME, of the dataset OLDNAME with the
values in missing cells filled by 0.0 for variables of type double, 0
for variables of type int, and the null-string '""' for variables of
type string.  'FILL' must be followed by two space-separated lists which
are separated by a ':'.  The first list names the variables whose values
are to be filled and the second list names the variables that classify
the cells in the dataset.  The dataset must be sorted by the
classification variables in that order.

   'REMOVE' deletes the dataset OLDNAME.

Code fragment(s)

   _Append the contents of the dataset 'tweedledee' to the dataset
'tweedledum':_
     dataset("tweedledee", "tweedledum", "APPEND");

   _Change the name of the dataset 'tweedledee' to 'tweedledum':_
     dataset("tweedledee", "tweedledum", "RENAME");

   _Make a copy of the dataset 'tweedledee' and name the new dataset
'tweedledum':_
     dataset("tweedledee", "tweedledum", "COPY");

   _Make a copy of the dataset 'tweedledee' but retain the values of
'alice' and 'mushroom' only, and name the new dataset 'tweedledum':_
     dataset("tweedledee", "tweedledum", "COPY alice mushroom");

   _Make a copy of the dataset 'tweedledee', retain the values of
'alice' and 'mushroom' only, name the new dataset 'tweedledum', and
change the name of 'alice' to 'tall' in the new dataset:_
     dataset("tweedledee", "tweedledum", "COPY alice>tall mushroom");

   _Make a copy, named 'tweedledum', of the dataset 'tweedledee', which
is sorted by 'SES', 'race', and 'gender', with the missing cells filled
with 0.0 for the variable 'count':_
     dataset("tweedledee", "tweedledum", "FILL count : SES race gender");

   _Remove the dataset 'tweedledee':_
     dataset("tweedledee", "", "REMOVE");


File: dap,  Node: Managing and displaying data,  Next: Statistics functions,  Prev: Datasets,  Up: Top

4 Managing and displaying data
******************************

These functions manipulate or display the data within a dataset (not a
data file).

* Menu:

* Sorting a dataset:: sort
* Merging datasets:: merge
* Displaying a dataset:: print and table
* Splitting and joining lines:: split and join
* Grouping lines in a dataset:: group
* Trimming extreme values:: trim


File: dap,  Node: Sorting a dataset,  Next: Merging datasets,  Up: Managing and displaying data

4.1 Sorting a dataset
=====================

SPECIFICATION
     sort(DATASET, VARIABLE-LIST, MODIFIERS)
     DATASET, VARIABLE-LIST, MODIFIERS: string

     proc sort [data=DATASET-NAME] [out=DATASET-NAME] [nodupkey];
     by [descending] VARIABLE-1 [... [descending] VARIABLE-N]

Description

   Writes to DATASET.srt the result of sorting DATASET in the order
specified by the space-separated, ordered list of variables
VARIABLE-LIST, according to MODIFIERS.  The original dataset is left
unchanged.  If MODIFIERS is the null string, then all variables are
sorted in increasing order and all sorted lines are kept.  Otherwise,
MODIFIERS is a space separated list of 'u' and/or an ordered string of
'i' and 'd' (no spaces) whose length equals the number of variables in
VARIABLE-LIST: 'u' means retain only one record in a group of lines for
which all the values of all the variables in VARIABLE-LIST are
identical; 'i' indicates that the corresponding variable will be sorted
in increasing order and 'd' indicates decreasing order.  NOTE: sort
allocates enough memory for sorting small to moderately large disk files
efficiently; for very large files, consider setting DAP_MAXMEM (*note
Appendix I::).

Code fragment(s)

   _Create a copy of the dataset 'people' sorted by 'height' in
ascending order and by 'weight' in ascending order within groups with
equal 'height' and name the new dataset 'people.srt':_
     sort("people", "height weight", "");

   _Create a copy of the dataset 'people' sorted by 'height' in
descending order and by 'weight' in ascending order within each group of
lines with constant 'height' and name the new dataset 'people.srt':_
     sort("people", "height weight", "di");

   _Create a copy of the dataset 'people' sorted by 'last' in ascending
order and by 'weight' in ascending order within each group of lines with
constant 'height', but retain only one line from each group of lines
with the constant 'last' and 'first', and name the new dataset
'people.srt':_
     sort("people", "last first", "u");

   _Create a copy of the dataset 'people' sorted by 'last' in descending
order and by 'weight' in descending order within each group of lines
with constant 'height', but retain only one line from each group of
lines with the constant 'last' and 'first', and name the new dataset
'people.srt':_
     sort("people", "last first", "u dd");


File: dap,  Node: Merging datasets,  Next: Displaying a dataset,  Prev: Sorting a dataset,  Up: Managing and displaying data

4.2 Merging datasets
====================

SPECIFICATION
     merge(DATASET1, VARIABLE-LIST1, DATASET2, VARIABLE-LIST2, PARTVARS, OUTPUTSET)
     DATASET1, VARIABLE-LIST1, DATASET2, VARIABLE-LIST2, PARTVARS, OUTPUTSET: string

Description

   Performs a many-to-one or one-to-one merge of DATASET1 and DATASET2
and writes the result to OUTPUTSET.  (For usage in an SBS 'data' step,
see *Note Appendix IV::.)  A variable is renamed in the output dataset
if the variable name is followed by '> NEWNAME'.  Only the variables in
VARIABLE-LIST1, renamed if requested, are included from DATASET1 and
only the variables in VARIABLE-LIST2, renamed if requested, are included
from DATASET2; these two variable lists must be disjoint.  Individual
array elements may not be referenced in the variable lists; array names
must appear without bracketed indices.  If either variable list is a
'NULL' pointer, then no variables are included from that dataset; this
can be used to select observations from a dataset.  If either variable
list is the null string ("", not 'NULL'), then all variables from that
dataset are included.  If either variable list contains the character
'!' before the first variable name, then the named variables are
excluded from, not included in, the output dataset.  If PARTVARS is not
the null string or 'NULL', then matching is based on the variables in
PARTVARS: for each part of the datasets DATASET1 and DATASET2 specified
by the variables in PARTVARS, the first observation in DATASET2 is
matched with all observations from DATASET1; both datasets must be
sorted by PARTVARS before merging.  Otherwise, observations in the two
datasets are matched one-to-one until one or both datasets are
exhausted.

Code fragment(s)

   _Merge datasets 'pretreat' and 'posttreat' into a new dataset
'changes' by matching lines with corresponding values of 'name'; retain
the values of 'name' and 'preweight' from 'pretreat' and the values of
'postweight' from 'posttreat':_
     merge("pretreat", "name preweight",
           "posttreat", "postweight", "name", "changes");

   _Merge datasets 'pretreat' and 'posttreat' into a new dataset
'changes' by matching lines with corresponding values of 'name'; retain
the values of 'name' and 'weight' from 'pretreat' and the values of
'weight' from 'posttreat', but change the name of 'weight' from
'pretreat' to 'preweight' and the name of 'weight' from 'posttreat' to
'postweight' in the dataset 'changes':_
     merge("pretreat", "name weight>preweight",
           "posttreat", "weight>postweight", "name", "changes");


File: dap,  Node: Displaying a dataset,  Next: Splitting and joining lines,  Prev: Merging datasets,  Up: Managing and displaying data

4.3 Displaying a dataset
========================

SPECIFICATION
     print(DATASET, VARIABLE-LIST)
     DATASET, VARIABLE-LIST: string

     proc print [data=DATASET-NAME];
     var VARIABLE-LIST;

Description

   Displays the values of variables in DATASET.  If VARIABLE-LIST is
NULL or the null string or a string containing only tabs or only commas,
the values of all variables are printed, otherwise just those of the
named variables are printed.  If the variables in VARIABLE-LIST are
separated by spaces, then output contains value of the '_type_' variable
and the observation number.  Otherwise, the variables must be separated
by tabs or commas and the value of the '_type_' variable and the
observation number are omitted.  No special handling is performed for
strings containing tabs or commas.  Code fragment(s)

   _Display the values of all the variables of the dataset 'names':_
     print("names", "");

   _Display the values, separated by tabs, of all the variables of the
dataset 'names':_
     print("names", "\t");

   _Display the values of 'first' and 'last' of the dataset 'names':_
     print("names", "first last");

   _Display the values, separated by commas, of 'first', 'middle', and
'last' of the dataset 'names':_
     print("names", "first, middle,last");

SPECIFICATION
     table(DATASET, ROW-VARS, COL-VARS, FORMAT, PARTVARS)
     DATASET, ROW-VARS, COL-VARS, FORMAT, PARTVARS: string

     proc tabulate [data=DATASET-NAME] [format=WIDTH.PLACES];
     [class CLASS-VARIABLE-LIST;]
     [var ANALYSIS-VARIABLE;]
     table ROW-VARIABLE-1 [... ROW-VARIABLE-N],
           COLUMN-VARIABLE-1 [... COLUMN-VARIABLE-N] * ANALYSIS-VARIABLE
           [/ {rtspace | rts}=NUMBER];
     by VARIABLE-LIST;

Description

   Displays values from DATASET in tabular form.  The values of the
variables in ROW-VARS label the rows hierarchically and the values of
the variables in COL-VARS label the columns hierarchically except that
the last variable in COL-VARS is the variable of type double whose
values are displayed in the cells of the table.  The string FORMAT is of
either of the two forms, WIDTH.PRECISION or WIDTH.  The first specifies
that WIDTH characters should be allotted for each cell and PRECISION
digits should be displayed to the right of the decimal point.  The
second only specifies the number of characters to be allotted for each
cell and lets the program choose the "best" allocation of decimals.  The
'table' function does not sort the data except that it sorts the columns
if an 's' appears before the WIDTH.PRECISION specification; thus, the
data must be sorted by the PARTVARS (if any), ROW-VARS, and COL-VARS
before calling 'table'.  The WIDTH.PRECISION can also be followed by a
number indicating how many columns to allocate for the combined row
labels, including column dividers.  'Table' does not process the data
and expects at most one value of the numerical variable for each
distinct combination of the row and column variables; see function
'split' (*note Splitting and joining lines::) for datasets with multiple
numerical values to display.

   SBS note: In 'proc tabulate', the 'class' and 'var' statements have
no effect and may be omitted.

Code fragment(s)

   _Display a table, with cells 6 characters long and values displayed
to 1 decimal place, of the values of 'height' with the rows labeled by
'last' and 'first' and the columns labeled by 'county':_
     table("names", "last first", "county height", "6.1", "");

   _Display tables, one for each 'state', with cells 6 characters long
and values displayed to 1 decimal place, of the values of 'height' with
the rows labeled by 'last' and 'first' and the columns labeled by
'county':_
     table("names", "last first", "county height", "6.1", "state");

   _Display a table, with cells 6 characters long and values displayed
to 1 decimal place, of the values of 'height' with the rows labeled by
'last' and 'first' and the columns labeled by 'county', with 'county'
sorted in ascending order:_
     table("names", "last first", "county height", "s6.1", "");


File: dap,  Node: Splitting and joining lines,  Next: Grouping lines in a dataset,  Prev: Displaying a dataset,  Up: Managing and displaying data

4.4 Splitting and joining lines
===============================

SPECIFICATION
     split(DATASET, VARIABLE-LIST, CLASS-VALUE-VARS)
     DATASET, VARIABLE-LIST, CLASS-VALUE-VARS: string

Description

   For each line of DATASET, writes to DATASET.spl one line for each
variable in VARIABLE-LIST, with the value of the first variable in
CLASS-VALUE-VARS set to the name of that variable and the value of the
second set to the value.  All the variables in VARIABLE-LIST must have
the same type, which will be the type of the second variable in
CLASS-VALUE-VARS.  All variables in DATASET except those VARIABLE-LIST
appear in DATASET.spl, in addition to the two new variables named in
CLASS-VALUE-VARS.  This function is useful for preparing a dataset for
function 'table'.

Code fragment(s)

   _Create a new dataset 'people.spl' that is a copy of 'people' except
that each person's height and weight are on consecutive lines so that
'table' can be called to display both values on the same line:_
     split("people", "height weight", "statname statistic");
     table("people.spl", "name", "statname statistic", "6.0", "");

SPECIFICATION
     join(DATASET, PARTVARS, VALUE-VAR)
     DATASET, PARTVARS, VALUE-VAR: string

Description

   For consecutive lines in DATASET distinguished by values of the last
variable named in PARTVARS, which must be a string variable, writes one
line to DATASET.joi.  In each part of DATASET specified by all but the
last variable named in PARTVARS, for each distinct value of the last
variable named in PARTVARS, the new dataset DATASET.joi contains one new
variable whose name is that value and whose value is set to the value of
VALUE-VAR in the corresponding line of DATASET.  DATASET must be sorted
by PARTVARS and the same set of values of the last variable named in
PARTVARS must occur in every part defined by all the variables but the
last in PARTVARS.  Neither the last variable name in PARTVARS nor the
variable VALUE-VAR appears in DATASET.joi.  This function is useful, for
example, for preparing a dataset for function 'plot'.

Code fragment(s)

   _Create a new dataset 'people.joi' that is a copy of 'people' except
that each person's height and weight, which were given as values of the
variable 'statistic' of type double, on separate lines identified by the
values 'height' and 'weight' of the string variable 'statname', now
appear as variables named 'height' and 'weight' on a single line:_
     join("people", "city name statname", "statistic");
     nport(plot("people.joi", "height weight", "city",
                 "", NULL, NULL, 3), 3, 1);


File: dap,  Node: Grouping lines in a dataset,  Next: Trimming extreme values,  Prev: Splitting and joining lines,  Up: Managing and displaying data

4.5 Grouping lines in a dataset
===============================

SPECIFICATION
     group(DATASET, VARIABLE-SPECIFICATION, PARTVARS)
     DATASET, VARIABLE-SPECIFICATION, PARTVARS: string

     proc rank [data=DATASET-NAME] [out=DATASET-NAME]
               [{fraction | f | percent | p | groups=NUMBER}];
     by VARIABLE-LIST;
     [ranks NEW-VARIABLE-LIST;]
     var VARIABLE-LIST;

Description

   Writes to DATASET.grp the observations of DATASET, grouped according
to the VARIABLE-SPECIFICATION.  Groups are numbered consecutively and
are formed as specified by VARIABLE-SPECIFICATION.  DATASET only needs
to be sorted by PARTVARS, if there are any.

   If VARIABLE-SPECIFICATION begins with either '#', '/', or '%' then
for each observation, GROUP computes either the number of the
observation or the fraction of the total number of observations or the
percent of the total number of observations, respectively.  '#', '/', or
'%' may be followed by a space and one of '+', '-', '+1', '+0', '-1', or
'-0' to indicate ascending order, starting from 0, descending order,
ending at 0, ascending order, starting from 1, ascending order, starting
from 0, descending order, ending at 1, or descending order, ending at 0,
respectively; the default is ascending order, starting from 1.  This may
in turn may be followed by a space-separated list of variables: only
those observations of the dataset for which all of these variables have
a finite (i.e., non-NaN) value are given group numbers and the remaining
observations are given a group number of NaN.

   If VARIABLE-SPECIFICATION does not begin with '#', '/', or '%', then
it must be a space-separated list of VARIABLE-NAME NGROUPS-METHOD, in
which NGROUPS-METHOD is either an integer followed by '^' (no space in
between) for that number of groups of equal width from the smallest
observation to the largest or an integer followed by '#' (no space in
between), for that number of groups of (approximately) equal counts from
the smallest observation to the largest.  Only those observations for
which all the grouping variables have finite (i.e., non-NaN) values are
given group numbers and the remaining observations are given a group
number of NaN. The numbering of the groups starts at 1.

   In addition to all variables in DATASET, the output dataset contains
for each grouping variable, which must be of type double, a new variable
whose name is formed by preceding the original variable name with an
underscore ('_'); this new variable, which is also of type double,
contains the group number of the value of the original variable.  If
only '#', '/', or '%', was requested, then the new variable is named
'_N_'.

   SBS note: In 'proc rank', the 'ranks' statement is ignored: the
output data set always contains new variables for the ranks, as in the
dap function 'group'.

Code fragment(s)

   _Create a new dataset 'people.grp' that is a copy of 'people' except
that it has an additional variable named '_N_' that contains the line
number, starting at 1:_
     group("people", "#", "");

   _Create a new dataset 'people.grp' that is a copy of 'people' except
that it has an additional variable named '_N_' that contains the line
number, starting at 0:_
     group("people", "# +0", "");

   _Create a new dataset 'people.grp' that is a copy of 'people' except
that it has an additional variable named '_height' that contains a
number from 1 to 5 that indicates the quintile of the value of
'height':_
     group("people", "height 5#", "");

   _Create a new dataset 'people.grp' that is a copy of 'people' except
that it has an additional variable named '_height' that contains a
number from 1 to 5 that indicates which of 5 equal length intervals,
starting at the smallest value of 'height' and ending at the largest,
contains the value of 'height':_
     group("people", "height 5^", "county");


File: dap,  Node: Trimming extreme values,  Prev: Grouping lines in a dataset,  Up: Managing and displaying data

4.6 Trimming extreme values
===========================

SPECIFICATION
     trim(DATASET, TRIM-SPECIFICATION, PARTVARS)
     DATASET, TRIM-SPECIFICATION, PARTVARS: string

Description

   Writes to DATASET.trm the observations from DATASET for which the
values of all of the variables in TRIM-SPECIFICATIONS do not lie in the
upper or lower percent indicated in TRIM-SPECIFICATIONS.  The string
TRIM-SPECIFICATIONS consists of space-separated pairs of VARIABLE-NAME
PERCENT.  The variables listed in TRIM-SPECIFICATIONS must be of type
double.

Code fragment(s)

   _Create a new dataset named 'wheat.trm' that contains only those
values of 'yield' that do not lie in the upper or lower 5% of all the
values of 'yield':_
     trim("wheat", "yield 5", "");

   _Create a new dataset named 'wheat.trm' that contains only those
lines of 'wheat' whose value of 'yield' does not lie in the upper or
lower 5% of all the values of 'yield' and, simultaneously, whose value
of 'nitrogen' does not lie in the upper or lower 10% of all the values
of 'nitrogen':_
     trim("wheat", "yield 5 nitrogen 10", "");


File: dap,  Node: Statistics functions,  Next: Graphics functions,  Prev: Managing and displaying data,  Up: Top

5 Statistics functions
**********************

* Menu:

* One variable statistics:: means and pctiles
* Survey selection:: survey select
* Correlations:: corr
* Analysis of variance:: effects, ftest, and lsmeans
* Categorical data analysis:: freq, categ, and loglin
* Linear regression:: linreg
* Logistic regression:: logreg
* Nonparametric analyses:: nonparam
* Statistics utilities:: estimate


File: dap,  Node: Survey selection,  Next: One variable statistics,  Prev: One variable statistics,  Up: Statistics functions

5.1 Survey selection
====================

SPECIFICATION
     surveyselect(DATASET, VARIABLE-SPECIFICATION, STAT-LIST, PARTVARS)
     DATASET, VARIABLE-SPECIFICATION, STAT-LIST, PARTVARS: string

     proc surveyselect [data=DATASET-NAME] [out=OUT-NAME]  [method=METHOD-NAME]  [n=N-NAME];

Description

   survey selection on a dataset.  method SRS and SYS are implemented.
Method SRS take [n] values in the dataset by randomization.  Method SYS
take [n] values in the dataset with a systematic algorithm starting with
a simple random.

     proc surveyselect data =tPres2007 method=SRS  n = 220 out=sasPres2007 ;
     run ;


File: dap,  Node: One variable statistics,  Next: Correlations,  Up: Statistics functions

5.2 One variable statistics
===========================

SPECIFICATION
     means(DATASET, VARIABLE-SPECIFICATION, STAT-LIST, PARTVARS)
     DATASET, VARIABLE-SPECIFICATION, STAT-LIST, PARTVARS: string

     proc means [data=DATASET-NAME] [noprint] [STATISTICS-LIST]
                [vardf={df | wdf}];
     var VARIABLE-LIST;
     weight VARIABLE;
     by VARIABLE-LIST;
     output [out=DATASET-NAME];

Description

   Writes to DATASET.mns the statistics requested in STAT-LIST for the
variables in VARIABLE-SPECIFICATION, which must be of type double.  The
'means' function does not display its results in the 'lst' file; use
'print' or 'table' (*note Displaying a dataset::) after calling 'means'
to display the results from DATASET.mns.  The statistics are given as
values of the variables named in VARIABLE-SPECIFICATION in DATASET.mns.
The string STAT-LIST is a space separated list of one or more of the
following statistics:

   MAX
     the maximum of the variable values

   MEAN
     the mean of the variable values

   MIN
     the minimum of the variable values

   N
     the number of finite observations

   RANGE
     the maximum minus the minimum of the variable values

   SD or STD
     the sample standard deviation of the variable values (df = number
     of observations - 1)

   SDFREQ
     the weighted sample standard deviation of the weighted variable
     values (df = sum of weights - 1)

   SEM or STDERR
     the sample standard error of the mean of the variable values (df =
     number of observations - 1)

   SEMFREQ
     the weighted sample standard error of the mean of the variable
     values (df = sum of weights - 1)

   STEPxxxx
     a sequence of XXXX + 1 equally spaced numbers from the minimum to
     the maximum of the variable values, with xxxx an integer of at most
     4 digits

   SUM
     the sum of the variable values

   SUMWT
     the sum of the weight variable values

   T
     the value of the t-statistic for the variable values

   TPROB or PRT
     the (two-tailed) probability that the absolute value of the
     t-statistic would equal or exceed the observed value

   VAR
     the sample variance of the variable values (df = number of
     observations - 1)

   VARFREQ
     the weighted sample variance of the variable values (df = sum of
     weights - 1)

   VARM
     the sample variance of the mean of the variable values (df = number
     of observations - 1)

   VARMFREQ
     the weighted sample variance of the variable values (df = sum of
     weights - 1)

   For each observation in the output data set, the '_type_' variable
names the statistic whose value is given for the requested variable.  If
the only statistic requested is 'N', then VARIABLE-LIST may consist of a
single variable which need not be present in the input data set.  The
string VARIABLE-SPECIFICATION is a space-separated list of variables
except that each weight variable is preceded by an '*'.  For example,

     w x * u y z * v

indicates that each value of W and X is weighted by the value of U and
that each value of Y and Z is weighted by the value of V.

   For each variable separately, means discards values for which either
the value itself or its weight value, if any, is a NaN. The number of
discarded values for each variable is reported in the 'log' file.

Code fragment(s)

   _For each distinct value of the variable 'plot', compute and display
the number of observations in dataset 'wheat' and the mean and variance
of the values of 'yield' and 'height':_
     means("wheat", "yield height", "N MEAN VAR", "plot");
     table("wheat.mns", "plot", "_type_ yield", "s6.1", "");
     table("wheat.mns", "plot", "_type_ height", "s6.1", "");

   _For each distinct value of the variable 'county', compute and
display the number of observations in dataset 'wheat' and the mean and
variance of the value of 'meanyield', weighted by 'acres':_
     means("wheat", "meanyield * acres", "N MEAN VAR", "county");
     table("wheat.mns", "county", "_type_ meanyield", "s6.1", "");

   _For each distinct value of the pair of variables 'last' and 'first',
compute the number of observations in dataset 'names':_
     means("names", "nrecords", "N", "last first");

SPECIFICATION
     pctiles(DATASET, VARIABLE-SPECIFICATION, STAT-LIST, PARTVARS)
     DATASET, VARIABLE-SPECIFICATION, STAT-LIST, PARTVARS: string

     proc univariate [data=DATASET-NAME] [noprint] [normal] [plot];
     var VARIABLE-LIST;
     by VARIABLE-LIST;
     weight VARIABLE;
     output [out=DATASET-NAME] [STATISTICS-LIST];

Description

   Writes to DATASET.pct the statistics requested in STAT-LIST for the
variables VARIABLE-SPECIFICATION, which must be of type double.  The
'pctiles' function does not display its results in the 'lst' file; use
'print' or 'table' (*note Displaying a dataset::) after calling
'pctiles' to display the results from DATASET.pct.  The statistics are
given as values of the variables named in VARIABLE-SPECIFICATION in
DATASET.pct.  The string STAT-LIST is a space separated list of one or
more of the following statistics:

   MAX
     the maximum

   MED or MEDIAN
     the median

   MIN
     the minimum

   N
     the number of observations

   P1
     the 1% point

   P5
     the 5% point

   P10
     the 10% point

   P90
     the 90% point

   P95
     the 95% point

   P99
     the 99% point

   Q1
     the first quartile

   Q3
     the third quartile

   QRANGE
     the interquartile range

   RANGE
     the range

   Up to 9 additional percentile points can be specified in the form
'PXXXXX' in which 'xxxxx' is a number, which may contain up to 5
characters, including a decimal point.

   The string VARIABLE-SPECIFICATION is a space-separated list of
variables except that each weight variable is preceded by an '*'.  For
example,

     w x * u y z * v

indicates that each value of W and X is weighted by the value of U and
that each value of Y and Z is weighted by the value of V.

Code fragment(s)

   _Compute and display the 10th, 25th, 50th (median), 75th, and 90th
percentiles of 'income' for each 'county' in the dataset 'people':_
     pctiles("people", "income", "P10 P25 MED P75 P90", "county");
     table("people.pct", "county", "_type_ income", "s7.2", "");

   _Compute and display the 37.5th, 50th (median), and 62.5th
percentiles of 'income' for each 'county' in the dataset 'people':_
     pctiles("people", "income", "P37.5 MED P62.5", "county");
     table("people.pct", "county", "_type_ income", "s7.2", "");


File: dap,  Node: Correlations,  Next: Analysis of variance,  Prev: One variable statistics,  Up: Statistics functions

5.3 Correlations
================

SPECIFICATION
     corr(DATASET, VARIABLE-LIST, PARTVARS)
     DATASET, VARIABLE-LIST, PARTVARS: string

     proc corr [data=DATASET-NAME] [outp=DATASET-NAME] [noprint];
     var VARIABLE-LIST;
     by VARIABLE-LIST;

Description

   Writes to DATASET.cor the correlation statistics and their
significances for all pairs of the variables, each of which must be of
type double, in VARIABLE-LIST.  The 'corr' function does not display its
results in the 'lst' file; use 'print' or 'table' (*note Displaying a
dataset::) after calling 'corr' to display the results from DATASET.cor.
The output dataset contains the variables '_var1_', '_var2_', and
'_corr_' in addition to all the variables in PARTVARS.  There is one
pair of correlation and significance values for each pair of numeric
variables.  For each line of the output data set, '_var1_', and
'_var2_', contain the names of the variables being reported on and
'_corr_' contains the number of observations, the correlation
coefficient, or its significance, as indicated by the values 'N',
'CORR', and 'PCORR' of the '_type_' variable, respectively.

Code fragment(s)

   _Compute and display the correlations and their signficances for each
pair of the variables 'height', 'weight', and 'income':_
     corr("people", "height weight income", "");
     sort("people.cor", "_type_ _var1_ _var2_", "");
     table("people.cor.srt", "_var1_", "_var2_ _corr_", "6.2", "_type_");


File: dap,  Node: Analysis of variance,  Next: Categorical data analysis,  Prev: Correlations,  Up: Statistics functions

5.4 Analysis of variance
========================

SPECIFICATION
     effects(DATASET, VARIABLE-LIST, MODEL, PARTVARS)
     DATASET, VARIABLE-LIST, MODEL, PARTVARS: string

     proc glm [data=DATASET-NAME];
     class VARIABLE-LIST;
     model RESPONSE-VARIABLE = EFFECTS-LIST;
     by VARIABLE-LIST;
     contrast "LABEL" EFFECT COEFFICIENT-LIST [/ e=EFFECT];
     lsmeans EFFECT-LIST / [e=EFFECT] [alpha=N] {DUNNETT | TUKEY | LSD};
     test h=EFFECT-LIST e=EFFECT;

Description

   For DATASET, created by MEANS with 'N', 'MEAN', and 'VAR', but no
other statistics requested, EFFECTS constructs a dataset named
DATASET.con appropriate for 'ftest' and then calls 'ftest' on the set of
contrasts specified by all the terms together in MODEL.  'Ftest' can be
used on DATASET.con to perform F-tests on the contrasts that correspond
to individual terms in the model.  The first variable in VARIABLE-LIST
is the response variable, which must be of type double, and the
remainder are the treatment variables, all of which must be of type
string.  The string MODEL is a space-separated list of terms in the
model; all possible terms not in the model are considered to be in the
error, in addition to the cell variances (if any).  Each term is either
a treatment or a cross of two or more treatments, which is indicated by
an '*' separated list of treatments.  Nesting can be specified by
including an effect in a cross term without that effect appearing as a
main effect.  NOTE: In the current version, 3.5, nested designs must be
balanced and the levels of the nested factors must be the same for each
set of levels of the factors within which they are nested; presumably,
this will be corrected in later versions.

   The output dataset DATASET.con contains a variable named '_term_', of
type int, which indicates which terms the error and contrast lines refer
to: each bit in '_term_', with the lowest order bit corresponding to the
first treatment variable, indicates whether the correspondingly numbered
treatment in the model is included in the term.  The error, contrast,
and least-squares means terms in DATASET.con are adjusted for missing
cells, but only the error terms are orthogonalized.

   SBS note: All the variables used in the EFFECTS-LIST of the 'model'
statement must be named in the 'class' statement, as dap only allows
categorical, string-valued, variables for the terms in the model.
Specify crossed and nested effects using '*' only.  A 'test' statement
automatically computes an appropriate combination of mean squares from
the terms in 'e=' error term list, if possible, to test the numerator
and applies the Satterthwaite approximation.  An 'lsmeans' statement
that has an 'e=' option or that appears after a 'contrast', a 'test', or
another LSMEANS statement automatically runs an F-test with the same
denominator.  In each 'contrast' statement, the effect to be tested must
be a main effect, the coefficients must appear in the sorting order of
the levels of that effect, they must be integers, and they must sum to
zero.  For more complicated contrasts, see *Note Analysis of variance
examples::.

Code fragment(s)

   _Perform an analysis of variance on the completely randomized one-way
layout with response variable 'yield' and treatment 'fert':_
     effects("wheat.srt.mns", "yield fert", "fert", "");

   _Perform an analysis of variance (F-test on the model only) on the
one-way layout in a completely randomized block design with response
variable 'yield' and treatment 'fert', blocked by 'block', with main
effects only:_
     effects("wheat.srt.mns", "yield fert block",
                      "fert block", "");

   _Perform an analysis of variance (F-test on the model only) on the
two-way layout in a completely randomized block design with response
variable 'yield' and treatments 'fert' and 'variety', blocked by
'block', with main effects and treatment interaction:_
     effects("wheat.srt.mns", "yield fert variety block",
                      "fert variety fert*variety block", "");

SPECIFICATION
     ftest(DATASET, VARIABLE-LIST, NUMERATOR, DENOMINATOR, PARTVARS)
     DATASET, VARIABLE-LIST, NUMERATOR, DENOMINATOR, PARTVARS: string

Description

   Performs an F-test on the hypothesis that all the contrasts specified
by NUMERATOR are zero, using the terms specified by DENOMINATOR, and the
variances of the cell means, as appropriate, as the error.  The string
VARIABLE-LIST must list the response variable followed by all the
variables in the model and error terms.

   The input dataset must have the following format: for each cell,
there must be a line for the mean, the number of observations for that
cell, and the variance (these three may be in any order) followed by the
denominator terms and then the numerator terms.  These lines are
identified respectively by the following values of the '_type_'
variable: 'MEAN', 'N', 'VAR', 'ERROR', and 'CONTR'.  Additional lines,
such as 'LSMEAN', lines, may follow.  The numerator and denominator
terms used for the test, which need to be adjusted for missing data (as
is done by effects) but which do not need to be orthogonal, are
identified by the value of the '_term_' variable in dataset (see
'effects').  If NUMERATOR is null, then all the terms identified as
'CONTR' are used in the test.  If DENOMINATOR is null, then the cell
variances and all the terms identified as 'ERROR' are used in the test.
If DENOMINATOR is non-null, then the cell variances are not included in
the test and 'ftest' constructs an appropriate combination of mean
squares from the terms in that denominator to test the numerator and
applies the Satterthwaite approximation.  Note, however, that
DENOMINATOR must contain all possible terms that might be needed to
construct that combination of mean squares.

   The function FTEST writes out a dataset, with the suffix of DATASET
replaced by .tst, which contains only those error, contrast, and
least-squares means terms appearing in dataset that appear in the test.
This file is suitable for input to LSMEANS.  At the end of that file are
two lines, the first with the mean-squared error appearing as the value
of the response variable and the second with the error degrees of
freedom appearing as the value of the response variable.  These lines
are identified by the _type_ variable as 'MSERROR' and 'ERRORDF',
respectively.

Code fragment(s)

   _Perform an F-test on the interaction term in the in the two-way
layout in a completely randomized block design with response variable
'yield' and treatments 'fert' and 'variety', blocked by 'block' as a
fixed effect, with main effects and treatment interaction:_
     ftest("wheat.srt.mns.con", "yield fert variety block",
                                         "fert*variety", "", "");

   _Perform an F-test on the interaction term in the in the two-way
layout in a completely randomized block design with response variable
'yield' and treatments 'fert' and 'variety', blocked by 'block' as a
random effect, with main effects and treatment interaction:_
     ftest("wheat.srt.mns.con", "yield fert variety block", "fert",
                                         "block fert*block", "");

SPECIFICATION
     lsmeans(DATASET, METHOD, ALPHA, VARIABLE-LIST, TREAT, PARTVARS, FORMAT)
     DATASET, METHOD, VARIABLE-LIST, TREAT, PARTVARS, FORMAT: string
     ALPHA: double

Description

   For DATASET produced by 'ftest' whose NUMERATOR is the same as the
TREAT of 'lsmeans', computes the least-squares means of the levels of
TREAT and reports the minimum difference significant at level ALPHA and
places the comparison of them according to METHOD in a dataset named
DATASET-NAME.lsm, and displays a table of results, the cells of which
are formated according to FORMAT as for TABLE.  The available methods
are 'LSD', 'TUKEY', and 'DUNNETT'.  For 'DUNNETT', the first level of
TREAT is taken to be the control.

Code fragment(s)

   _Compute and test, using the LSD method with significance level 0.05,
least squares means for the one-way layout in a completely randomized
block design with response variable 'yield' and treatment 'fert',
blocked by 'block', with main effects only; the table of results is
displayed with cells 6 characters long and values to 1 decimal place:_
     lsmeans("data.srt.mns.tst", "LSD", 0.05,
                         "yield treat block", "block", "", "8.4");


File: dap,  Node: Categorical data analysis,  Next: Linear regression,  Prev: Analysis of variance,  Up: Statistics functions

5.5 Categorical data analysis
=============================

SPECIFICATION
     freq(DATASET, VARIABLE-LIST, STAT-LIST, PARTVARS)
     DATASET, VARIABLE-LIST, STAT-LIST, PARTVARS: string

     proc freq [data=DATASET-NAME];
     by VARIABLE-LIST;
     tables VARIABLE-1 [* VARIABLE-2 [... * VARIABLE-N]] /
                  [out=DATASET-NAME] [noprint] [nofreq] [noprecent]
                  [norow] [nocol] [STATISTICS-LIST];
     weight VARIABLE;

Description

   Writes dataset DATASET.frq with the variable '_cell_', of type
double, set equal to the count, fraction, percent, or expected value
under independence, as requested by STAT-LIST for the cells with
distinct values of the variables in VARIABLE-LIST.  The dataset DATASET
must be sorted by VARIABLE-LIST.  The 'freq' function does not display
its results in the 'lst' file; use 'print' or 'table' (*note Displaying
a dataset::) after calling 'freq' to display the results from
DATASET.frq.  If VARIABLE-LIST contains a count-variable, which must
appear last in the list and must be preceded by an '*' and which must be
of type double, then the count, fraction, or percent is weighted by the
values of that count-variable for that cell.  The string STAT-LIST is a
space separated list of one or more of the following statistics:

   CHISQ
     for 2-dimensional tables, compute Pearson's chi-squared statistic
     and test

   CMH
     for tables of dimension 3 or higher, compute the
     Cochran-Mantel-Haenszel statistic and test, with strata defined by
     the levels of all but the last two variables in VARIABLE-LIST

   COLPERC
     the percent of the number of observations in the column

   COUNT
     the number of observations

   EXPECTED
     for 2-dimensional tables, the expected table entry under
     independence, conditioned on the marginal totals

   FISHER
     for 2x2 tables, computes Fisher's exact test

   FRACTION
     the fraction of the total number of observations

   NOMINAL
     for 2-dimensional tables, compute the following measures of
     association of nominal variables and their asymptotic standard
     errors: uncertainty coefficients

   ODDSRAT
     for 2x2 tables, computes the odds ratio

   ORDINAL
     for 2-dimensional tables, compute the following measures of
     association of ordinal variables and their asymptotic standard
     errors: gamma, Kendall's Tau-b, and Somers' D (column on row and
     row on column)

   PAIR
     for 2-dimensional tables, compute measures of association for
     matched pairs and their asymptotic standard errors

   PERCENT
     the percent of the total number of observations

   ROWPERC
     the percent of the number of observations in the row

   For 'CHISQ', 'FISHER', 'ODDSRAT', and 'ORDINAL', the requested
statistic and, if applicable, test is displayed in the 'lst' file.  For
'COUNT', 'EXPECTED', 'FRACTION', and 'PERCENT', the requested '_cell_'
values are indicated in DATASET.frq by the corresponding value of the
'_type_' variable.  The input dataset must be sorted by the variables
named in PARTVARS and VARIABLE-LIST.

Code fragment(s)

   _For each 'state' and 'county' in the dataset 'people', compute and
display the cell percentages for a two-way table whose rows are labeled
by 'education' and whose columns are labeled by 'education':_
     freq("people", "education income", "PERCENT", "state county");
     table("people.frq", "education", "income _cell_",
                                                  "3.0", "state county");

   _For each 'county' in the dataset 'people', compute and display the
cell counts for a two-way table whose rows are labeled by 'education'
and whose columns are labeled by 'education'; also compute and display
the cell counts expected under independence and the Chi-squared
statistic and its significance:_
     freq("people", "education income", "COUNT EXPECTED CHISQ", "county");
     sort("people.frq", "county _type_ education income", "");
     table("people.frq.srt", "education", "income _cell_",
                                                  "6.0", "county _type_");

   _For each 'state' and 'county' in the dataset 'people', compute and
display the cell percentages within row for a two-way table whose rows
are labeled by 'education' and whose columns are labeled by
'education':_
     freq("people", "education income", "ROWPERC", "state county");
     table("people.frq", "education", "income _cell_",
                                                  "3.0", "state county");

   _For the dataset 'rabbits.srt', compute the Cochran-Mantel-Haenszel
statistic and its significance for a three-way table that is stratified
by 'penicillin' and, within each stratum, whose rows are labeled by
'delay' and whose columns are labeled by 'response' and whose cell
counts are given by 'count'; :_
     freq("rabbits.srt", "penicillin delay response*count", "CMH", "");

SPECIFICATION
     categ(DATASET, VARIABLE-LIST, AUX-VARIABLE-LIST, EXPECT, PARAM, SELECT, PARTVARS, TRACE)
     DATASET, VARIABLE-LIST, AUX-VARIABLE-LIST, SELECT, PARTVARS, TRACE: string
     EXPECT: pointer to function returning double
     PARAM: array of double

Description

   'Categ' fits the model specified by the function EXPECT and the
parameter selection string SELECT to the data by the method of maximum
likelihood, reports goodness of fit statistics from the comparison of
the specified model with either a reduced model or the saturated model,
writes the observed and fitted cell counts to DATASET.cat, with the
'_type_' variable set to 'OBS' and 'FIT', respectively, and the
estimates and the covariance matrix to DATASET.cov, with the '_type_'
variable set to 'ESTIMATE' and 'COVAR', respectively, the '_param1_' and
'_param2_' variables indicating which of the parameters named in SELECT
identify the row and column, and the '_cov_' variable containing the
numerical value.  The first variable named in VARIABLE-LIST is the cell
count for the cells.  Cells are classified by the remaining variables in
VARIABLE-LIST.  Additional auxiliary variables, such as the total number
of observations or marginal totals, that are required for computing
expected cell counts (see 'expect' below) can be listed in
AUX-VARIABLE-LIST.  All variables in VARIABLE-LIST and in
AUX-VARIABLE-LIST must be coded as double; this allows 'categ' to work
with continuous and categorical variables together.  The input dataset
must be sorted according to the classification variables in
VARIABLE-LIST in the order that they appear there.  If non-null, the
trace option TRACE is passed to 'dap_maximize' for tracing the maximum
likelihood iteration.

   The string SELECT is a space-separated sequence of parameter names,
each one optionally preceded by either a '!' to indicate that it is to
omitted from the model or '?' to indicate that it should be omitted from
the reduced model only.  The number of parameters must equal the
dimension of the PARAM array and the order corresponds to the order of
entries in that array.  Note that the parameter names need not
correspond to variables in the dataset, they are used only to identify
their estimates in the output.  If there are no '?'s, then the goodness
of fit statistics computed are relative to the saturated model.  If
there are '?'s, then the goodness of fit statistics are computed
relative to the reduced model obtained by setting all the '?'s to '!'s.

   'Categ' assumes that the parameters in PARAM are independent and
computes the degrees of freedom as the number of cells minus the number
of parameters.  See 'estimate' (*note Statistics utilities::) to see how
to obtain statistics on the remaining parameters or contrasts.  The
initial values of the parameters for the maximum likelihood estimation
must be supplied in the call to 'categ'; they are not modified by
'categ'.  The function pointed to by EXPECT must take two parameters, an
array of parameter values, with dimension equal to the number of
parameters specified by the string SELECT, followed by an array of
classification, and possibly auxiliary, values, with dimension equal to
the number of classification and auxiliary variables in VARIABLE-LIST
and AUX-VARIABLE-LIST, and return the expected number of observations
for the indicated cell, based on the parameter, classification, and
auxiliary (if any) values supplied.

   Note: 'categ' creates or overwrites the dataset DATASET.fil to create
a dataset with no missing cells for the analysis.

Code fragment(s)

   _Use the user-defined function 'expect' to fit and test a loglinear
model and print a table of the observed and fitted cell counts; in the
dataset 'deathpen', the variable 'n' gives the cell counts for the
three-way table classified by 'def', 'vic', and 'pen' and 'param' is an
array of 7 independent parameters:_
     double expect(double param[8], double class[2]);
     categ("cda262", "count income jobsat", &expect, param,
           "mu <6 6-15 15-25 VD LD MS ?Inc*Sat", "", "");
     sort("cda262.cat", "income _type_ jobsat", "");
     table("cda262.cat.srt", "income", "_type_ jobsat count", "6.2", "");

SPECIFICATION
     loglin(DATASET, VARIABLE-LIST, MODEL0, MODEL1, PARTVARS)
     DATASET, VARIABLE-LIST, MODEL0, MODEL1, PARTVARS: string

Description

   The function 'loglin' fits the hierarchical loglinear models
specified by MODEL0 and MODEL1 and compares them.  The first variable
named in VARIABLE-LIST gives the cell counts and must be of type double,
the remainder give the classification and must be strings.  The strings
MODEL0 and MODEL1 consist of one or more space-separated terms, each
term of which is a '*'-separated list of classification variables.  The
model specified by MODEL1 must incorporate at least as many effects as
the one specified by MODEL0.  If MODEL0 is the null string (not NULL),
then MODEL1 is compared to the saturated model.  The dataset DATASET
must be sorted according to the partitioning variables and the
classification variables in the order listed in VARIABLE-LIST.  Further,
if the input dataset is partitioned, the input data for each part must
have the same table layout and size.  The function 'loglin' creates the
dataset DATASET.llm and calls function 'categ', which creates the
dataset DATASET.llm.cat, which contains the observed and fitted cell
counts and is copied back to DATASET.llm.

   The output in the 'lst' file reports the estimate and asymptotic
standard error for each of the independent parameters of the model,
using zero-sum constraints to eliminate dependent parameters.

Code fragment(s)

   _Compare the models 'vic*pen def*vic' and 'def*pen vic*pen def*vic'
using counts in 'n', which gives the cell counts for the three-way table
classified by 'def', 'vic', and 'pen':_
     loglin("deathpen", "n def vic pen",
            "vic*pen def*vic", "def*pen vic*pen def*vic", "");
     sort("deathpen.llm", "def vic _type_ pen", "");
     table("deathpen.llm.srt", "def vic", "_type_ pen n", "s6.2 30", "");


File: dap,  Node: Linear regression,  Next: Logistic regression,  Prev: Categorical data analysis,  Up: Statistics functions

5.6 Linear regression
=====================

SPECIFICATION
     linreg(DATASET, Y-VARIABLE-LIST, X0-VARIABLE-LIST, X1-VARIABLE-LIST, PARTVARS, X-DATASET, LEVEL)
     DATASET, Y-VARIABLE-LIST, X0-VARIABLE-LIST, X1-VARIABLE-LIST, PARTVARS, X-DATASET: string
     LEVEL: double

     proc reg [data=DATASET-NAME] [outest=DATASET-NAME];
     model RESPONSE-VARIABLES = EXPLANATORY-VARIABLES;
     [var VARIABLE-LIST;]
     [add VARIABLE-LIST;]
     by VARIABLE-LIST;
     [plot Y-VARIABLE * X-VARIABLE;]

Description

   Performs ordinary least squares linear regression for each variable
in Y-VARIABLE-LIST as a function of all the variables in
X0-VARIABLE-LIST and X1-VARIABLE-LIST, computes t-tests on each
parameter, and and tests the full model against the model with just the
variables in X0-VARIABLE-LIST.  The model always includes an intercept
term, which is named _intercept_ and is always included implicitly in
X0-VARIABLE-LIST.

   Results are displayed in the 'lst' file.  In addition, for each of
the specified values of the variables in X0-VARIABLE-LIST and
X1-VARIABLE-LIST, observed and predicted values and lower and upper
confidence limits for the mean at LEVEL for each of the variables in
Y-VARIABLES are written to DATASET.reg in lines identified by the
respective values 'OBS', 'PRED', 'LOWER', and 'UPPER' of the '_type_'
variable.  These values are given as the values of the Y-VARIABLES in
DATASET.reg.  If X-DATASET is non-null, specified values for the
x-variables are read from that dataset; otherwise, the values of the
x-variables in DATASET are used.  Finally, the estimates and covariance
matrix are written to the file DATASET.cov, with the '_type_' variable
set to 'ESTIMATE' and 'COVAR', respectively, the '_response_' variable
indicating the response variable and the '_param1_' and '_param2_'
variables indicating which parameters identify the row and column, and
the '_cov_' variable containing the numerical value.

   SBS note: If you include a 'plot' statement, then the model must
contain only one response and one explanatory variable.  If there is an
'add' statement, the model will be fit as originally specified and with
the additional variables and the change in R-squared will be reported.
The 'var' statement is ignored in any case.

Code fragment(s)

   _Perform linear regression of the response variable 'strength' on the
independent variables 'length' and 'thickness', based on the values in
the dataset 'wires', and compare the full model with the reduced model
that contains the intercept term only:_
     linreg("wires", "strength", "", "length thickness", "", NULL, 0.0);

   _Perform linear regression of the response variable 'strength' on the
independent variables 'length' and 'thickness', based on the values in
the dataset 'wires', and compare the full model with the reduced model
that contains the intercept term and 'length' only; also compute
predicted values and the endpoints of 95% confidence intervals for the
mean of the response for the values of 'length' and 'thickness' in the
dataset 'steps':_
     linreg("wires", "strength", "length", "thickness", "", "steps", 0.95);


File: dap,  Node: Logistic regression,  Next: Nonparametric analyses,  Prev: Linear regression,  Up: Statistics functions

5.7 Logistic regression
=======================

SPECIFICATION
     logreg(DATASET, Y-SPEC, X0-VAR-LIST, X1-VAR-LIST, PARTVARS, X-DATASET-NAME, LEVEL)
     DATASET, Y-SPEC, X0-VAR-LIST, X1-VAR-LIST, PARTVARS, X-DATASET-NAME: string
     LEVEL: double

     proc logistic [data=DATASET-NAME] [outest=DATASET-NAME];
     model {VARIABLE | EVENTS/TRIALS} = EXPLANATORY-VARIABLES;
     by VARIABLE-LIST;

Description

   Performs logistic regression for the response variable in Y-SPEC as a
function of all the variables in X0-VAR-LIST and X1-VAR-LIST, and tests
the full model against the model with just the variables in X0-VAR-LIST.
The model always includes an intercept term, which is named
'_intercept_' and is always included implicitly in X0-VAR-LIST.
Variables in Y-SPEC, X0-VAR-LIST, and X1-VAR-LIST must be of type
double.  Two forms for the response in Y-SPEC are available:
EVENTS-VARIABLE / TRIALS-NUMBER, in which TRIALS-NUMBER is an explicit
number (e.g., 1 for binary data), and EVENTS-VARIABLE / TRIALS-VARIABLE,
in which EVENTS-VARIABLE is a count of successes in the number of trials
specified by TRIALS-VARIABLE.

   Results are displayed in the 'lst' file.  In addition, for each of
the specified values of the variables in X0-VAR-LIST and X1-VAR-LIST,
observed and predicted probabilities and lower and upper confidence
limits at LEVEL for the probability that the EVENTS-VARIABLE is 1 are
written to DATASET.lgr in lines identified by the respective values
'PRED', 'LOWER', and 'UPPER' of the '_type_' variable.  These values are
given as the values of the EVENTS-VARIABLE in DATASET.lgr.  If
X-DATASET-NAME is non-null, specified values for the x-variables are
read from that dataset; otherwise, the values of the x-variables in
DATASET are used.  Finally, the estimates and covariance matrix are
written to the file DATASET.cov, with the '_type_' variable set to
'ESTIMATE' and 'COVAR', respectively, the '_param1_' and '_param2_'
variables indicating which parameters identify the row and column, and
the '_cov_' variable containing the numerical value.

   SBS note: only binary response is allowed, although the EVENTS/TRIALS
form allows that to be expressed as the result of a binomial experiment.

Code fragment(s)

   _Perform logistic regression with the binomial response variable
'heartdis', with values from 0 to 'ncases' in each observation, on the
independent variable 'bloodpress', based on the values in the dataset
'heartrisk':_
     logreg("heartrisk", "heartdis / ncases",
                      "", "bloodpress", "", NULL, 0.0);

   _Perform logistic regression with the binomial response variable
'larvae', with values from 0 to 10 in each observation, on the
independent variable 'co2', based on the values in the dataset
'biocontrol'; also computed predicted values and the endpoints of 95%
confidence intervals for the mean response:_
     logreg("biocontrol", "larvae / 10",
                      "", "co2", "", "biocontrol.mns", 0.95);


File: dap,  Node: Nonparametric analyses,  Next: Statistics utilities,  Prev: Logistic regression,  Up: Statistics functions

5.8 Nonparametric analyses
==========================

SPECIFICATION
     nonparam(DATASET, VARIABLE-LIST, PARTVARS)
     DATASET, VARIABLE-LIST, PARTVARS: string

     proc npar1way [data=DATASET-NAME];
     class CLASS-VARIABLE;
     var VARIABLE-LIST;
     by VARIABLE-LIST;

Description

   If VARIABLE-LIST contains the name of only one variable, which must
be of type double, then 'nonparam' tests the Wilcoxon signed rank
statistic on the values of that variable.  If VARIABLE-LIST contains the
names of two variables, then the first must be of type double and the
second must be of type string.  If the second variable has two levels,
then 'nonparam' tests the Wilcoxon rank sum statistic and the Kolmogorov
two-sample statistic of the values of the first variable classified by
the values of the second.  If the second variable has more than two
levels, then 'nonparam' tests the Kruskal-Wallis statistic of the values
of the first variable classified by the values of the second.  The input
dataset does not need to be sorted.

   SBS note: In 'proc npar1way', the 'class' and 'var' statements are
required and the class variable must be of type string.

Code fragment(s)

   _For each distince value of 'sex', perform a Wilcoxon signed rank
test on the values of 'weightchange':_
     nonparam("diettest", "weightchange", "sex");

   _Perform a Kuskal-Wallis test on the values of 'weightchange' as
classified by 'drug':_
     nonparam("diettest", "weightchange drug", "");


File: dap,  Node: Statistics utilities,  Prev: Nonparametric analyses,  Up: Statistics functions

5.9 Statistics utilities
========================

SPECIFICATION
     estimate(DATASET, PARAMETERS, DEFINITIONS, PARTVARS)
     DATASET, PARAMETERS, DEFINITIONS, PARTVARS: string

Description

   'Estimate' prints the estimate and standard error for each of the
parameters defined in DEFINITIONS, based on the estimates and covariance
matrix provided by the dataset DATASET for the parameters named in the
space-separated list PARAMETERS.  DATASET is typically the '.cov'
dataset output by a function such as 'loglin', 'categ', 'linreg', or
'logreg' and must contain, in addition to the '_type_' variable,
variables named '_param1_', '_param2_', and '_cov_': the first two are
string variables specifying the parameters by which the estimates and
covariance matrix are indexed and the last is the entry in the estimate
vector or covariance matrix.  For the value 'ESTIMATE' of '_type_', the
variable '_param2_' specifies the parameter.  The value 'COVAR' of
'_type_' indicates that the value of '_cov_' is an entry in the
covariance matrix.

   The string 'definitions' is a space-separated list of equations of
the form PARAM = COEFFICIENT_1 PARAM_1 ...  COEFFICIENT_N PARAM_N, in
which PARAM_1 through PARAM_N are the names of parameters whose
estimates and covariances appear in DATASET or a previous definition and
each COEFFICIENT is a decimal number.  A '+' is optional for positive
coefficients.  COEFFICIENT_1 may be omitted if it would be a '+1'.

Code fragment(s)

   _Use the user-defined function 'expect' to fit and test a saturated
logit model for the 4 by 2 table with 4 rootstocks, A, I, II, and U, and
two levels of disease, 0 and 1.  'param' is an array of 8 independent
parameters based on the identifiability constraints lambda_A + lambda_I
+ lambda_II + lambda_U = 0, lambda_d0 + lambda_d1 = 0, and mu_A + mu_I +
mu_II + mu_U = 0.  Finally use 'estimate' to define the missing
parameter mu_U and test the contrast diff_I_U = mu_I - mu_U:_
     double expect(double param[8], double class[2]);
     categ("rootdisease", "_cell_ root disease", &expect, param,
           "mu lambda_A lambda_I lambda_II lambda_d0 mu_A mu_I mu_II", "", "");
     estimate("rootdisease.cov", "mu_A mu_I mu_II",
            "mu_U = - mu_A - mu_I - mu_II diff_I_U = mu_I - mu_U", "");


File: dap,  Node: Graphics functions,  Next: Utilities,  Prev: Statistics functions,  Up: Top

6 Graphics functions
********************

* Menu:

* Histogram:: histogram
* Normal probability plot:: normal
* Scatter plot or line graph:: plot
* Plotting means:: plotmeans
* Regression plots:: plotlinreg and plotlogreg
* Displaying the pictures:: port, land, nport, nland


File: dap,  Node: Histogram,  Next: Normal probability plot,  Up: Graphics functions

6.1 Histogram
=============

SPECIFICATION
     histogram(DATASET, VARIABLE-LIST, PARTVARS, NBARS, STYLE, XFUNCT, NPLOTS)
     DATASET, VARIABLE-LIST, PARTVARS, STYLE: string
     NBARS, NPLOTS: int
     XFUNCT: pointer to function returning double
     RETURNS: array of 'pict'

     proc chart [data=DATASET-NAME];
     by VARIABLE-LIST;
     vbar VARIABLE / [freq=VARIABLE] [levels=N]
                       [axis=[MIN] MAX]
                       [type=freq | percent | pct];

Description

   Constructs an array of 'pict' structures for drawing (*note
Displaying the pictures::) separate histograms of the values of the
first variable in VARIABLE-LIST, weighted by the second variable, if
present, in VARIABLE-LIST, for each distinct set of values of PARTVARS.
The first variable name may be followed by a string, enclosed in back
quotes ('`'), to be used instead of the variable name as the x-axis
label.  Each histogram has NBARS bars.  The string STYLE is either the
null string or contains axis specifications as for 'pict_autoaxes'
(*note Axes::) and can optionally specify 'EQUAL' or 'VARIABLE' width
bars, each of which represents either the 'COUNT' (only for equal width
bars) or 'PERCENT' or 'FRACTION' of the observations.  If STYLE contains
the word 'MINX', followed without a space by a number, then the
horizontal minimum point of the histogram(s) is that number.  If STYLE
contains the word 'MAXX', followed without a space by a number, then the
horizontal maximum point of the histogram(s) is that number.  If STYLE
contains the word 'MAXY', followed without a space by a number, then the
vertical maximum point of the histogram(s) is that number.  If STYLE
contains the word 'ROUND', then the right and left ends of the histogram
are expanded, if necessary, to make the width of the bars rounded to 1
digit.  The function pointed to by XFUNCT applies to the x-axis as in
the description of 'pict_autoaxes'.  The default is equal width bars of
counts.  The integer NPLOTS must be at least as large as the number of
parts created by PARTVARS.  The function 'histogram' allocates an array
of 'picts' for the histograms and axes, in which the picts for all the
plots come first, followed by an equal number of 'pict's for the
corresponding axes, and returns the starting address of that array.

Code fragment(s)

   _Display a histogram, in portrait orientation with a surrounding box,
of 10 variable-width bars that show counts of the values of 'height' in
the dataset 'people':_
     nport(histogram("people", "height", "",
                               10, "VARIABLE ==", NULL, 1), 1, 1);

   _Display a histogram for each of 58 counties, on 58 pages in portrait
orientation with axes at (0, 0), of 25 equal-width bars extending from 0
to 84 that show counts of the values of 'height' in the dataset
'people':_
     nport(histogram("people", "height", "county",
                               25, "MIN0 MAX84", NULL, 58), 58, 1);

   _Display a histogram for each of 58 counties, on 58 pages in portrait
orientation with axes at (0, 0), of 25 equal-width bars that show
percentages of the values of 'height' in the dataset 'people':_
     nport(histogram("people", "height", "county",
                               25, "PERCENT", NULL, 58), 58, 1);


File: dap,  Node: Normal probability plot,  Next: Scatter plot or line graph,  Prev: Histogram,  Up: Graphics functions

6.2 Normal probability plot
===========================

SPECIFICATION
     normal(DATASET, VARIABLE, PARTVARS, NPLOTS)
     DATASET, VARIABLE, PARTVARS: string
     NPLOTS: int
     RETURNS: array of 'pict'

Description

   If NPLOTS is greater than 0, constructs an array of 'pict' structures
for drawing (*note Displaying the pictures::) a q-q plot of the values
of VARIABLE for each part of DATASET defined by the values of PARTVARS.
If the number of values is at least 3 but no more than 2000, performs a
Shapiro-Wilk test for normality, the results of which are reported in
the lst file and, if NPLOTS is greater than 0, in the caption of the
'pict's.  Each q-q plot is prepared for display on a separate page.  The
integer NPLOTS must be at least as large as the number of parts created
by PARTVARS.  The function 'normal' allocates an array of PICTS for the
plots and axes, in which all the plots come first, and returns the
address of that array.

Code fragment(s)

   _For each distinct value of 'block', display a q-q plot of the values
of 'yield' and apply the Shapiro-Wilk test for normality:_
     nport(normal("wheat", "yield", "block", 4), 4, 1);


File: dap,  Node: Scatter plot or line graph,  Next: Plotting means,  Prev: Normal probability plot,  Up: Graphics functions

6.3 Scatter plot or line graph
==============================

SPECIFICATION
     plot(DATASET, XYVAR, PARTVARS, STYLE, XFUNCT, YFUNCT, NPLOTS)
     DATASET, XYVAR, PARTVARS, STYLE: string
     XFUNCT, YFUNCT: pointer to function returning double
     NPLOTS: int
     RETURNS: array of 'pict'

     proc plot [data=DATASET-NAME];
     by VARIABLE-LIST;
     plot Y-VARIABLE * XVARIABLE [/ [box]];
     [...
     plot Y-VARIABLE * XVARIABLE [/ [box]];]

Description

   For DATASET, constructs an array of 'pict' structures for plotting
(*note Displaying the pictures::) the points whose coordinates are in
the two variables listed in XYVAR.  Each of those variable names may be
followed by a string, enclosed in back quotes, to be used instead of the
variable name as the axis label.  Points are plotted in the order that
they appear in the dataset and therefore must be sorted for a line
graph.  The default type of graph is a scatter plot with circles marking
the points.  To get a line graph, you must set the value of the
'pict_type' field of the 'pict' to the string 'LINE'; see the
description of the 'pict' structure.  If the first character of STYLE is
'o' and is not followed by an integer, then the plots for the different
values of the PARTVARS are all prepared to be displayed on the same pair
of axes on the same page.  If the first character of STYLE is 'o' and is
followed by an integer N, then the plots are overlayed in consecutive
groups of size N.  Otherwise those plots are prepared to be displayed on
different pages.  The remaining characters of STYLE and the functions
XFUNCT and YFUNCT are axis specifications as for 'pict_autoaxes' (*note
Axes::).  The integer NPLOTS must be at least as large as the number of
groups created by PARTVARS.  The function 'plot' allocates an array of
'pict's for the plots and axes, in which all the plots come first, and
returns the address of that array.

Code fragment(s)

   _Display a scatter plot in portrait orientation with 'height' on the
horizontal axis and 'weight' on the vertical axis:_
     nport(plot("people", "height weight", "", "", NULL, NULL, 1), 1, 1);

   _Overlay 4 scatter plots, one for each distinct value of 'plot', on
one page in portrait orientation, with 'fert' on the horizontal axis and
'yield' on the vertical axis, and make the symbols be open circles,
filled-in circles, open squares, and filled-in squares, respectively:_
     pict *p;

     p = plot("wheat", "fert yield", "plot", "o", NULL, NULL, 4);
     strcpy(p[0].pict_type, "CIRC");
     strcpy(p[1].pict_type, "CIRC");
     p[1].pict_fgray = 0.0;
     strcpy(p[2].pict_type, "SQUA");
     strcpy(p[3].pict_type, "SQUA");
     p[3].pict_fgray = 0.0;
     nport(p, 4, 4);

   _Display one boxed line graph per page in portrait orientation for
each of the 2 distinct values of 'species' with 'time' on the horizontal
axis and 'logpop' on the vertical axis, with the 'exp' function applied
to the vertical coordinate labels:_
     pict *p;

     p = plot("bacteria", "time logpop", "species",
                                          "==", NULL, &exp, 2);
     strcpy(p[0].pict_type, "LINE");
     strcpy(p[1].pict_type, "LINE");
     nport(p, 2, 1);

   _Overlay 6 boxed scatter plots, one for each distinct value of
'plot', 3 per page on 2 pages in portrait orientation, with 'fert' on
the horizontal axis and 'yield' on the vertical axis, and make the
symbols be open circles, open triangles, and open squares, respectively,
on each of the 2 pages:_
     pict *p;

     p = plot("wheat", "fert yield", "plot variety",
                                          "o3 ==", NULL, NULL, 6);
     strcpy(p[0].pict_type, "CIRC");
     strcpy(p[1].pict_type, "TRIA");
     strcpy(p[2].pict_type, "SQUA");
     strcpy(p[3].pict_type, "CIRC");
     strcpy(p[4].pict_type, "TRIA");
     strcpy(p[5].pict_type, "SQUA");
     nport(p, 6, 3);


File: dap,  Node: Plotting means,  Next: Regression plots,  Prev: Scatter plot or line graph,  Up: Graphics functions

6.4 Plotting means
==================

SPECIFICATION
     plotmeans(DATASET, Y-VARIABLE, X-VARIABLE, ERRORBARS, STYLE, PARTVARS, NOVERLAY)
     DATASET, Y-VARIABLE, X-VARIABLE, ERRORBARS, STYLE, PARTVARS: string
     NOVERLAY: int
     RETURNS: array of 'pict'

Description

   Constructs an array of 'pict' structures for plotting (*note
Displaying the pictures::) the mean, with an error bar, of Y-VARIABLE
for each value of X-VARIABLE.  Both variables must be of type double and
either or both may be followed by a string, enclosed in back quotes, to
be used instead of the variable name as the axis label.  The height of
the error bar above and below the mean can be specified to be any
statistic available for the 'means' function, optionally multiplied by a
scale factor, which follows the statistic name and a space in ERRORBARS.
The string STYLE is as in PLOT, except that overlaying is controlled by
PLOTMEANS and must not be specified in STYLE.  If PARTVARS is null (""),
then the array of 'pict's has two elements, the first for the error bars
and the second for the means.  If PARTVARS is not null but NOVERLAY is
1, then the array of 'pict's has those same two elements for each part
of the dataset and each plot is on a separate page.  If PARTVARS is not
null and NOVERLAY is greater than 1, then the array of 'pict's has those
same two elements for each part of the dataset but the elements are
linked so that NOVERLAY pictures appear on the same set of axes.  NOTE:
this function creates the following datasets or overwrites them if they
exist: DATASET.mns, DATASET.err, and DATASET.err.srt.

Code fragment(s)

   _For each distinct value of 'thickness', compute the mean and
standard deviation of the values of 'strength' and display on a single
page in portrait orientation the means with error bars extending the
standard deviation above and below the mean:_
     nport(plotmeans("wires", "strength", "thickness", "SD",
                                                      "", 0), 2, 2);

   _For each distinct value of 'thickness', compute the mean and
standard error of the mean of the values of 'strength' and display on a
single page in portrait orientation the means with error bars extending
1.96 times the standard error of the mean above and below the mean:_
     nport(plotmeans("wires", "strength", "thickness", "SEM 1.96",
                                                      "", 0), 2, 2);

   _For each of 3 distinct values of 'metal' display a separate page on
which appears, for each distinct value of 'thickness', the means of
'strength' with error bars extending the standard deviation above and
below the mean:_
     nport(plotmeans("wires", "strength", "thickness", "SD",
                                                      "metal", 1), 6, 2);

   _For each of 3 distinct values of 'metal', display overlayed on a
single page the means of 'strength' for each distinct value of
'thickness', with error bars extending the standard deviation above and
below the mean:_
     nport(plotmeans("wires", "strength", "thickness", "SD",
                                                      "metal", 3), 6, 6);


File: dap,  Node: Regression plots,  Next: Displaying the pictures,  Prev: Plotting means,  Up: Graphics functions

6.5 Regression plots
====================

SPECIFICATION
     plotlinreg(DATASET, Y-VARIABLE, X-VARIABLE, STYLE, PARTVARS, NPARTS, LEVEL)
     DATASET, Y-VARIABLE, X-VARIABLE, STYLE, PARTVARS: string
     NPARTS: int
     LEVEL: double
     RETURNS: array of 'pict'

Description

   Runs LINREG on DATASET, allocates an array of 'pict's for the plots
and axes for the plots of the observed data the regression line, and the
curves enclosing a LEVEL confidence region for the predicted mean of
Y-VARIABLE, and returns the address of the array of 'pict's, to be
displayed as NPARTS page(s) of 4 overlayed pictures each (*note
Displaying the pictures::).  Both X-VARIABLE and Y-VARIABLE must be
single variables and each may be followed by an axis label enclosed in
pairs of '`'.  DATASET must be partitioned by PARTVARS into exactly
NPARTS parts.  STYLE may contain axis specifications as for
'pict_autoaxes' (*note Axes::).  NOTE: This function creates the
following datasets or overwrites them if they exist: DATASET.mns,
DATASET.reg, and DATASET.reg.srt.

Code fragment(s)

   _Display on one page a scatter plot of the data, with 'thickness' on
the horizontal axis, which will be labeled 'Thickness', and 'strength'
on the vertical axis, while will be labeled 'Strength', and the
regression line and the curves defining a 95% confidence region for the
predicted means:_
     nport(plotlinreg("wires", "stren`Strength`", "thick`Thickness`",
                      "==", "", 1, 0.95), 4, 4);

   _For each of the 4 values of the variable 'plot', display on a
separate page a scatter plot of the data, with 'salin' on the horizontal
axis and 'yield' on the vertical axis, the regression line, and the
curves defining a 95% confidence region for the predicted means:_
     nport(plotlinreg("pist", "yld", "sal", "==", "plot", 4, 0.95), 16, 4);

SPECIFICATION
     plotlogreg(DATASET, Y-SPEC, X-VARIABLE, STYLE, NGROUPS, PARTVARS, NPARTS, LEVEL)
     DATASET, Y-SPEC, X-VARIABLE, STYLE, PARTVARS: string
     NGROUPS, NPARTS: int
     LEVEL: double
     RETURNS: array of 'pict'

Description

   Runs LOGREG on DATASET, allocates an array of 'pict's for the plots
and axes for plots the logistic regression curve and the curves
enclosing a LEVEL confidence region for the predicted expectation of the
response variable in Y-SPEC, and returns the starting address of the
array of 'pict's, to be displayed as NPARTS page(s) of 4 overlayed
pictures each (*note Displaying the pictures::).  Also plots the mean of
the response variable in Y-SPEC for the NGROUPS groups of the
observations.  The list X-VARIABLE must contain only one variable;
Y-SPEC is as in LOGREG.  The response variable in Y-SPEC and the
variable in X-VARIABLE may be followed by axis labels enclosed in '`'.
DATASET must be partitioned by PARTVARS into exactly NPARTS parts.
STYLE may contain axis specifications as for 'pict_autoaxes' (*note
Axes::).  NOTE: This function creates the following datasets or
overwrites them if they exist: DATASET.trl, DATASET.trl.grp,
DATASET.trl.grp.srt, DATASET.trl.grp.srt.mns, DATASET.mns, DATASET.lgr,
and DATASET.lgr.srt.

Code fragment(s)

   _Display on one page the mean success rate for each of 5 consecutive
groups of the data, ordered by 'lab', and the logistic regression line,
and the curves defining a 95% confidence region for the predicted
fraction of success:_
     nport(plotlogreg("can", "rem`Remissions` / 1", "lab`Labeling index`",
                      "==", 5, "", 1, 0.95), 4, 4);

   _Display on one page the mean fraction of 'rem' per 'case' for each
of 5 consecutive groups of the data, ordered by 'lab', and the logistic
regression line, and the curves defining a 95% confidence region for the
predicted fraction of 'rem' per 'case':_
     nport(plotlogreg("can", "rem/case", "lab", "==", 5, "", 1, 0.95),
           4, 4);

   _For each of the 3 values of the variable 'hosp', display on a
separate page the mean fraction of 'rem' per 'case' for each of 5
consecutive groups of the data, ordered by 'lab', and the logistic
regression line, and the curves defining a 95% confidence region for the
predicted fraction of 'rem' per 'case':_
     nport(plotlogreg("can", "rem/case", "lab", "==", 5, "hosp", 3, 0.95),
           12, 4);


File: dap,  Node: Displaying the pictures,  Prev: Regression plots,  Up: Graphics functions

6.6 Displaying the pictures
===========================

SPECIFICATION
     nport(P, NPLOTS, NPERPAGE)
     nland(P, NPLOTS, NPERPAGE)
     P: array of 'pict'
     NPLOTS, NPERPAGE: int

Description

   Generates an NPLOTS / NPERPAGE page graphics output file, in portrait
or landscape orientation, from the 'pict' array pointed to by P with a
total of NPLOTS plots, NPERPAGE per page.  As shown above, the first
argument of a call to 'nport' or 'nland' is usually provided directly by
the value returned from a call to a graphics function such as
'plotlogreg'.

Code fragment(s)

   _Display the 8 'pict's of the array 'p' on 4 pages in portrait
orientation, with 2 'pict's per page:_
     pict *p;

     ...
     nport(p, 8, 2);

   _Display 'pict's from 'plotlogreg' in portrait orientation:_
     nport(plotlogreg("can", "nrem/ncase", "lab", "==", 5, "", 1, 0.95),
           4, 4);

   _Display 'pict's from 'plotlogreg' in landscape orientation:_
     nland(plotlogreg("can", "nrem/ncase", "lab", "==", 5, "", 1, 0.95),
           4, 4);


File: dap,  Node: Utilities,  Next: Picture functions,  Prev: Graphics functions,  Up: Top

7 Utilities: probability and miscellaneous functions
****************************************************

* Menu:

* Chi-squared distribution:: probchisq and chisqpoint
* F distribution:: probf and fpoint
* Normal distribution:: probz, zpoint, and varnorm
* t distribution:: probt and tpoint
* Uniform distribution:: varunif
* Miscellaneous functions::


File: dap,  Node: Chi-squared distribution,  Next: F distribution,  Up: Utilities

7.1 Chi-squared distribution
============================

SPECIFICATION
     probchisq(C, DF)
     C: double
     DF: int
     RETURNS: double

Description

   Returns the probability that a variable distributed as chi-squared
with DF degrees of freedom has a value greater than C.

Code fragment(s)

   _Assign to 'p' the probability that a Chi-squared variable with 2
degrees of freedom will have a value exceeding 3.7:_
     double p;
     p = probchisq(3.7, 2);

SPECIFICATION
     chisqpoint(P, DF)
     P: double
     DF: int
     RETURNS: double

Description

   Returns the value that a variable that is distributed as chi-squared
with DF degrees of freedom exceeds with probability P.

Code fragment(s)

   _Assign to 'c' the point that a Chi-squared variable with 3 degrees
of freedom exceeds with probability 0.05:_
     double c;
     c = chisqpoint(0.05, 3);


File: dap,  Node: F distribution,  Next: Normal distribution,  Prev: Chi-squared distribution,  Up: Utilities

7.2 F distribution
==================

SPECIFICATION
     probf(F, NUMER-DF, DENOM-DF)
     F: double
     NUMER-DF, DENOM-DF: int
     RETURNS: double

Description

   Returns the probability that a variable distributed as F with
NUMER-DF and DENOM-DF degrees of freedom has a value greater than F.

Code fragment(s)

   _Assign to 'p' the probability that an F variable with 4 and 2
degrees of freedom will have a value exceeding 5.8:_
     double p;
     p = prob(5.8, 4, 2);

SPECIFICATION
     fpoint(P, NUMER-DF, DENOM-DF)
     P: double
     NUMER-DF, DENOM-DF: int
     RETURNS: double

Description

   Returns the value that a variable that is distributed as F with
NUMER-DF and DENOM-DF degrees of freedom exceeds with probability P.

Code fragment(s)

   _Assign to 'f' the point that an F variable with 4 and 2 degrees of
freedom exceeds with probability 0.05:_
     double f;
     f = fpoint(0.05, 4, 2);


File: dap,  Node: Normal distribution,  Next: t distribution,  Prev: F distribution,  Up: Utilities

7.3 Normal distribution
=======================

SPECIFICATION
     varnorm()
     RETURNS: double

Description

   Repeated calls return values (pseudo) independently sampled from a
standard normal distribution.

Code fragment(s)

   _Assign to 'z' a value sampled from a standard normal distribution:_
     double z;
     z = varnorm();

SPECIFICATION
     probz(Z)
     Z: double
     RETURNS: double

Description

   Returns the probability that a standard normal variable has a value
no greater than Z.

Code fragment(s)

   _Assign to 'p' the probability that a standard normal variable will
have a value not exceeding 1.645:_
     double p;
     p = probz(1.645);

SPECIFICATION
     zpoint(P)
     P: double
     RETURNS: double

Description

   Returns the value that a standard normal variable exceeds with
probability P.

Code fragment(s)

   _Assign to 'z' the that a standard normal variable exceeds with
probability 0.05:_
     double z;
     z = zpoint(0.05);


File: dap,  Node: t distribution,  Next: Uniform distribution,  Prev: Normal distribution,  Up: Utilities

7.4 t distribution
==================

SPECIFICATION
     probt(T, DF)
     T: double
     DF: int
     RETURNS: double

Description

   Returns the probability that a variable distributed as Student's t
with DF degrees of freedom has a value greater than T.

Code fragment(s)

   _Assign to 'p' the probability that a t variable with 3 degrees of
freedom will have a value exceeding 2.3:_
     double p;
     p = probt(2.3, 3);

SPECIFICATION
     tpoint(P, DF)
     P: double
     DF: int
     RETURNS: double

Description

   Returns the value that a variable that is distributed as Student's t
with DF degrees of freedom exceeds with probability P.

Code fragment(s)

   _Assign to 't' the point that a t variable with 4 degrees of freedom
exceeds with probability 0.05:_
     double t;
     t = tpoint(0.05, 4);


File: dap,  Node: Uniform distribution,  Next: Miscellaneous functions,  Prev: t distribution,  Up: Utilities

7.5 Uniform distribution
========================

SPECIFICATION
     varunif()
     RETURNS: double

Description

   Repeated calls return values (pseudo) independently sampled from a
uniform [0, 1] distribution.

Code fragment(s)

   _Assign to 'u' a value sampled from a uniform [0, 1] distribution:_
     double u;
     u = varunif();


File: dap,  Node: Miscellaneous functions,  Prev: Uniform distribution,  Up: Utilities

7.6 Miscellaneous functions
===========================

SPECIFICATION
     dap_bincoeff(N, R)
     N, R: double
     RETURNS: double

Description

   Returns the binomial coefficient n C r.

SPECIFICATION
     dap_maximize(F, NX, X, STEP, TOL, TRACE)
     F: pointer to function returning double
     NX: int
     X, STEP, TOL: double
     TRACE: string
     RETURNS: double

Description

   Maximizes (or attempts to maximize) the function F of NX variables,
starting with the input point X.  The function 'dap_maximize' uses a
simple hill-climbing algorithm, with numerically approximated partial
derivatives, starting with step-size STEP and halving the step-size as
necessary until it is less than TOL.  The string TRACE is either the
null string (not 'NULL') for no tracing, or 'TRACE', for continuous
tracing, or 'PAUSE', for tracing and waiting for the user to press
<Enter> at each iteration.  Either 'TRACE' or 'PAUSE' may be followed,
with no spaces, by a number to specify how many steps should be taken
before each trace or pause.  If convergence is not obtained in
'DAP_MAXITER' steps *note Appendix I::, that failure is reported before
returning.

Code fragment(s)

   _Assign to 'max' the maximum value attained by the function of 2
variables 'fun', starting with the values stored in 'x', with a step
size of 0.01 and a tolerance in the independent variables of 0.001:_
     double fun(double x[2]);
     double max;
     double x[2];

     max = dap_maximize(&fun, 2, x, 0.01, 0.001, "");

   _Assign to 'max' the maximum value attained by the function of 2
variables 'fun', starting with the values stored in 'x', with a step
size of 0.01 and a tolerance in the independent variables of 0.001 and
display a trace of the iterations:_
     double fun(double x[2]);
     double max;
     double x[2];

     max = dap_maximize(&fun, 2, x, 0.01, 0.001, "TRACE");

SPECIFICATION
     dap_numdate(DATE)
     DATE: string
     RETURNS: int

Description

   With DATE a date on or after January 1, 1752, in the form 'MMDDYYYY'
or 'MM/DD/YYYY', in which the 'MM' and the 'DD' in the latter form can
consist of a single digit, returns the number of days since December 31,
1751, otherwise returns -1.

Code fragment(s)

   _Assign to 'd' the number 72143, i.e., the number of days that July
9, 1949 is later than December 31, 1751:_
     int d;
     d = dap_numdate("07091949");

SPECIFICATION
     dap_datenum(N, DATE)
     N: int
     DATE: string

Description

   With N the number of days since December 31, 1751, fills DATE with
the date in the form 'MMDDYYYY'.  If N is not positive or is too large,
DATE is set to "?".

Code fragment(s)

   _Assign to 'date' the string "07021761", i.e., the date 3471 days
after December 31, 1751:_
     char date[9];
     dap_datenum(3471, date);

SPECIFICATION
     dap_invert(MATRIX, ROWSCOLS)
     MATRIX: pointer to pointer to double
     ROWSCOLS: int
     RETURNS: int

Description

   Inverts the matrix, returns 1 if non-singular, 0 otherwise.  The
parameter MATRIX is an array of pointers to double, each double pointed
to being the first element of an array of double.

Code fragment(s)

     double **mat;
     int nonsing;
     nonsing = dap_invert(mat, 3);


File: dap,  Node: Picture functions,  Next: Examples,  Prev: Utilities,  Up: Top

8 Picture functions
*******************

The most common use of the information in this chapter is to modify one
or more fields in the 'pict' structure, which is described in the first
section of this chapter, returned by a dap graphics function.  In
addition, this chapter describes low-level picture functions.  Although
these picture functions are not needed in most dap programs, they are
useful for constructing custom graphics.  The functions that add
elements, shapes, or text to a picture must be followed by a call to
'pict_show' to include those objects in the graphics output file.
Complex pictures with, for example, different fonts for different pieces
of text or different sized circles, may be constructed in one of two
ways: either link the parts of the picture and call 'pict_show' once, on
the head of the list, or call 'pict_show' repeatedly, after assembling
each of the parts of the picture.

* Menu:

* Pict structure:: pict structure, pict_initpict, and pict_clearpict
* Axes:: pict_axes, pict_autoaxes, pict_maketick
* Elements:: pict_point, pict_line
* Shapes:: pict_circle, pict_rectangle, pict_hrect, pict_bhrect, pict_curve
* Text:: pict_text
* Transformations:: pict_translate, pict_rotate, pict_scale
* Graphics output file:: pict_port, pict_land, pict_init, pict_page, pict_show, pict_end
* Picture datasets:: pict_save, pict_rest


File: dap,  Node: Pict structure,  Next: Axes,  Up: Picture functions

8.1 Pict structure and pict_init
================================

Dap graphics functions return arrays of 'pict'.  The 'pict' structure
contains the following fields that may be modified directly to change a
picture.  Numerical values are in points (1/72 inch).

pict_type: string (4 letters)

   This field must be one of the following strings:

   LINE
     Draw lines connecting successive points.

   SEGM
     Draw a separate segment for each successive pair of points.

   IBEA
     Draw an I-beam for each successive pair of points.  If the
     horizontal coordinates of the pair of points are equal, draw a
     vertical I-beam; if the vertical coordinates of the pair of points
     are equal, draw a horizontal I-beam; otherwise, report the error
     and exit.

   CIRC
     Draw each point as a circle.

   SQUA
     Draw each point as a square.

   TRIA
     Draw each point as a triangle.

   UTRI
     Draw each point as a upside-down triangle.

   DIAM
     Draw each point as a diamond.

   PATT
     At the position of each point, display the pattern pointed to by
     PICT_PATT.

pict_dash: double

   The dash length for lines if PICT_DASH > 0.0; the lines are not
dashed if PICT_DASH = 0.0.  The default is 0.0.

pict_font: string (up to 63 letters)

   A string specifying the font for displayed text, if any.  The default
is 'Helvetica-Bold'.

pict_fs: double

   The font size for displayed text, if any.  The default is 12.0.

pict_lw: double

   The width for lines.  The default is 0.4.

pict_r: double

   The radius for circles and size for squares, triangles, upside-down
triangles, and diamonds.

pict_lgray: double

   The gray level for lines: 0.0 is completely black, 1.0 is completely
white.  The default is 0.0.

pict_fgray: double

   The gray level for fill: if PICT_FGRAY < 0.0, then don't fill areas;
if PICT_FGRAY \ge 0.0, then fill areas, then draw the boundary lines.
The default is -1.0.

pict_patt: pointer to 'pict'

   This field allows you to place a picture at each point: set PICT_PATT
to the address of the 'pict' to be displayed.

pict_next: pointer to 'pict'

   This field allows you to link pictures to be displayed on the same
page.

SPECIFICATION
     pict_initpict(PREV, P)
     PREV, P: pointer to 'pict'

Description

   Initialize the 'pict' pointed to by P, linking the 'pict' pointed to
by PREV to it.  If PREV is 'NULL', then no 'pict' is linked to P.

Code fragment(s)

   _Initialize the picture structures 'p[0]' and 'p[1]' and link 'p[0]'
to 'p[1]':_
     pict p[2];

     pict_initpict(NULL, p);
     pict_initpict(p, p + 1);

SPECIFICATION
     pict_clearpict(P)
     P: pointer to 'pict'

Description

   Frees up internal memory space used by P: use before calling
'pict_initpict' on P after it has been used.  Does not free P itself.

Code fragment(s)

   _Free the internal memory space used by 'p':_
     pict p;

     pict_clearpict(&p);


File: dap,  Node: Axes,  Next: Elements,  Prev: Pict structure,  Up: Picture functions

8.2 Axes
========

SPECIFICATION
     pict_axes(P, MINX, MAXX, XTICKS, NXTICKS, MINY, MAXY, YTICKS, NYTICKS, AXSPEC, BPOS, LPOS, TPOS, RPOS)
     P: pointer to 'pict'
     XTICKS, YTICKS: array of 'tick'
     NXTICKS, NYTICKS: int
     AXSPEC: string
     BPOS, LPOS, TPOS, RPOS: double

Description

   Create axes in the 'pict' pointed to by P with ticks along the x-axis
specified by the array XTICK of NXTICKS 'tick's and ticks along the
y-axis specified by the array YTICKS of NYTICKS 'tick's.  The ticks must
be in order.  The last tick is used to label the axis and the numbers of
ticks, NXTICKS and NYTICKS do not include this last tick.  The string
AXSPEC is as for PICT_AUTOAXES.  The doubles BPOS, LPOS, TPOS, and RPOS
are the positions of the bottom or only x-axis, the left or only y-axis,
the top x-axis (if any), and the right y-axis (if any).  The variables
MINX, MAXX, MINY, and MAXY give the endpoints of the axes.

Code fragment(s)

   _Creat axes in 'p' with 11 ticks on each of the x- and y-axes as a
box whose lower and upper edges are at 0.0 and 100.0, respectively, and
whose left and right edges are at -10.0 and 10.0, respectively, with
ticks and numbers on all sides:_
     pict p;
     tick xt[12], yt[12];

     pict_axes(&p, xt, 12, yt, 12, "BB", 0.0, 100.0, -10.0, 10.0);

SPECIFICATION
     pict_autoaxes(P, XLABEL, YLABEL, AXSPEC, XFUNCT, YFUNCT, CAPTION, AUTOPOS)
     P: array of 'pict'
     XLABEL, YLABEL, AXSPEC, CAPTION: string
     XFUNCT, YFUNCT: pointer to function returning double
     AUTOPOS: int

Description

   Create axes, as specified below, by AXSPEC for the linked list of
'pict's whose head is pointed to by P and whose tail is the 'pict' to
contain the axes.  Unless otherwise specified, the axes extend to the
maximum and minimum values of x and y in the entire linked list of
'pict's (except the tail 'pict'), but always include the origin.  Unless
otherwise specified, the function PICT_AUTOAXES chooses an appropriate
spacing for the ticks on both axes.  The x- and y-axes are labeled
XLABEL and YLABEL, respectively, and the entire picture is captioned by
CAPTION.  The first part of the string AXSPEC consists of 0, 1, or 2
characters according to whether the default is used for both axes, just
the y-axis, or the axes are specified as follows, respectively.  An axis
specification is one of the characters '-', '+', '0', 'n', '=', or '#',
which indicate that the axis should be placed: on the negative end of
the other axis; the positive end; at 0; not at all; or at both ends,
without or with markings on the positive end.  The default is '0'.  The
endpoints of the graph and the number of ticks in each direction may be
specified in AXSPEC after the first part of the string (and at least one
space) as follows: to set the minimum point on the x-axis to a number,
say '-3.6', use 'MINX-3.6' (no spaces).  The maximum point on the x-axis
and the minimum and maximum points on the y-axis can be specified using
'MAXX', 'MINY', and 'MAXY' in the same way.  To set the number of tick
marks on the x-axis to a number, say 14, use 'NXTICKS14' (no spaces).
The number of ticks on the y-axis can be set using 'NYTICKS' in the same
way.  The number of significant figures used for the labels on the ticks
can be specified using 'NXDIGITS' and 'NYDIGITS', as in 'NXDIGITS4'; the
default is 3 digits.

   The functions XFUNCT and YFUNCT are applied to the true tick values
to create the tick labels.  Either one or both may be 'NULL' to specify
that the tick labels equal the tick values.  If AUTOPOS is 'PORTRAIT' or
'LANDSCAPE' (integer values, not strings, defined in the header file),
then APICT_UTOAXES automatically scales and positions the plot
appropriately.  No scaling and positioning is done if AUTOPOS is 0.

Code fragment(s)

   _Create axes in the last 'pict' in the linked array given by 'p' with
the horizontal axis labeled "time", the vertical axis labeled "CFU", the
horizontal axis at the most negative point the 'pict's of 'p', the
vertical axis at 'time' = 0, the function 'exp' used to display
numerical tick values on the vertical axis, the caption "CFU per cm^2^
surface area" (with the '2' as a superscript), scaled and placed
appropriately on a page in portrait orientation:_
     pict *p;

     pict_autoaxes(p, "time", "CFU", "-0", NULL, &exp,
                                 "CFU per cm^2^ surface area", PORTRAIT);

SPECIFICATION
     pict_maketick(THETICK, POSITION, LABEL, LENGTH)
     TICK: pointer to 'tick'
     POSITION, LENGTH: double
     LABEL: string

Description

   Make the 'tick' pointed to by THETICK be at coordinate POSITION with
label LABEL and of length LENGTH.

Code fragment(s)

   _Create in 't' a tick with position 5.0, label "25.0", and length 3.0
points:_
     tick t;

     pict_maketick(&t, 5.0, "25.0", 3.0);


File: dap,  Node: Elements,  Next: Shapes,  Prev: Axes,  Up: Picture functions

8.3 Elements
============

SPECIFICATION
     pict_point(P, X, Y)
     P: pointer to 'pict'
     X, Y: double

Description

   Add a point at (X, Y) to the 'pict' pointed to by P.  Points added to
the same 'pict' appear in the order in which they are added.

Code fragment(s)

   _Add a point at (7.2, -4.3) to 'p':_
     pict p;

     pict_point(&p, 7.2, -4.3);

SPECIFICATION
     pict_line(P, X1, Y1, X2, Y2)
     P: pointer to 'pict'
     X1, Y1, X2, Y2: double

Description

   Add a line from (X1, Y1) to (X2, Y2) to the 'pict' pointed to by P.
Lines added to the same 'pict' appear in the order in which they are
added.

Code fragment(s)

   _Add a line from (7.2, -4.3) to (9.1, 2.6) to 'p':_
     pict p;

     pict_line(&p, 7.2, -4.3, 9.1, 2.6);


File: dap,  Node: Shapes,  Next: Text,  Prev: Elements,  Up: Picture functions

8.4 Shapes
==========

SPECIFICATION
     pict_circle(P, X, Y, R)
     P: pointer to 'pict'
     X, Y, R: double

Description

   Make the 'pict' pointed to by P a circle of radius R, centered at (X,
Y).  NOTE: If a picture is to contain more than one circle, then those
circles must be created in separate 'pict's that are linked together.

Code fragment(s)

   _Add a circle with center (7.2, -4.3) and radius 3.0 to 'p':_
     pict p;

     pict_circle(&p, 7.2, -4.3, 3.0);

SPECIFICATION
     pict_rectangle(P, X, Y, XSIDE, YSIDE)
     P: pointer to 'pict'
     X, Y, XSIDE, YSIDE: double

Description

   Add a rectangle whose lower left corner is a (X, Y) and has
horizontal sides of length XSIDE and vertical sides of length YSIDE to
the 'pict' pointed to by P.  NOTE: If a picture is to contain more than
one rectangle but those rectangles are not to be connected, then those
rectangles must be created in separate 'pict's that are linked together.

Code fragment(s)

   _Add a rectangle with lower left corner (7.2, -4.3), width 4.0, and
height 4.5 to 'p':_
     pict p;

     pict_rectangle(&p, 7.2, -4.3, 4.0, 4.5)

SPECIFICATION
     pict_hrect(P, SPACING, X, Y, XSIDE, YSIDE)
     pict_bhrect(P, SPACING, X, Y, XSIDE, YSIDE)
     P: pointer to 'pict'
     SPACING, X, Y, XSIDE, YSIDE: double

Description

   Add a forward-hashed (respectively, backward-hashed) rectangle whose
lower left corner is at (X, Y) and has horizontal sides of length XSIDE
and vertical sides of length YSIDE to the 'pict' pointed to by P.  The
horizontal space between hash lines is SPACING.  NOTE: If a picture is
to contain more than one rectangle but those rectangles are not to be
connected, then those rectangles must be created in separate 'pict's
that are linked together.

Code fragment(s)

   _Add a rectangle with lower left corner (3.5, 29.0), width 1.0,
height 5.0, and with hashes sloping upwards at a spacing of 2.0 points
to 'p':_
     pict p;

     pict_hrect(&p, 2.0, 3.5, 29.0, 1.0, 5.0);

   _Add a rectangle with lower left corner (3.5, 29.0), width 1.0,
height 5.0, and with hashes sloping downwards at a spacing of 2.0 points
to 'p':_
     pict p;

     pict_bhrect(&p, 2.0, 3.5, 29.0, 1.0, 5.0);

SPECIFICATION
     pict_curve(P, X, Y, T0, T1, NSEGMENTS)
     P: pointer to 'pict'
     X, Y: pointer to function returning double
     T0, T1: double
     NSEGMENTS: int

Description

   Add a curve to the 'pict' pointed to by P.  The curve is
parameterized by X and Y, which point to functions that take a single
argument of type double and return a result of type double.  If X is
'NULL', then that function is taken to be the identity function.  The
parameter varies from T0 to T1 in NSEGMENTS steps.  Curves (and lines
and points) added to the same 'pict' are connected in the order in which
they are added.  NOTE: If a picture is to contain more than one curve
but those curves are not to be connected, then those curves must be
created in separate 'pict's that are linked together.

Code fragment(s)

   _Add to 'p' a curve parameterized by 'cos' and 'sin' with parameter
running from 0.0 to 2.0 * 3.14159 in 100 steps:_
     pict p;

     pict_curve(&p, &cos, &sin, 0.0, 2.0 * 3.14159, 100);

   _Add to 'p' a graph of 'exp' running from 0.0 to 3.0 in the
horizontal direction in 100 steps:_
     pict p;

     pict_curve(&p, NULL, &exp, 0.0, 3.0, 100);


File: dap,  Node: Text,  Next: Transformations,  Prev: Shapes,  Up: Picture functions

8.5 Text
========

SPECIFICATION
     pict_text(P, TEXT, X, Y, ANGLE, POS)
     P: pointer to 'pict'
     TEXT, POS: string
     X, Y, ANGLE: double

Description

   Add text TEXT to the 'pict' pointed to by P.  The string TEXT may
contain substrings enclosed between pairs of '^' for superscripts and
between pairs of '|' for subscripts.  The string TEXT may also contain
newline characters ('\n') for multi-line text.  The string POS consists
of either two or three letters that specify the position of the point
with coordinates X and Y relative to the text, as follows.  The first
character of POS is either 'l', 'c', or 'r', for left, center, or right,
respectively, and the second letter is either 't', 'm', or 'b', for top,
middle, or bottom, respectively.  If the optional third character of POS
is a space, then a blank rectangle is formed to hold the text.  The
double ANGLE is counter-clockwise rotation in degrees to be applied to
text.

Code fragment(s)

   _Add to 'p' the text "cm^3^ of H|2|O" (with the '3' as a superscript
and the '2' as a subscript) placed horizontally with its bottom center
at the point (306.0, 72.0):_
     pict p;

     pict_text(&p, "cm^3^ of H|2|O", 306.0, 72.0, 0.0, "cb");


File: dap,  Node: Transformations,  Next: Graphics output file,  Prev: Text,  Up: Picture functions

8.6 Transformations
===================

SPECIFICATION
     pict_translate(P, X, Y)
     P: pointer to 'pict'
     X, Y: double

Description

   Translate (i.e., shift) the 'pict' pointed to by P by X in the
x-direction and Y in the y-direction.  If the 'pict' is linked to
another 'pict', then that 'pict' is translated the same way, and so on
until there are no more links.

Code fragment(s)

   _Translate all 4 pictures in the linked array 'p' 306.0 points to the
right and 72.0 points up:_
     pict p[4];

     pict_translate(p, 306.0, 72.0);

SPECIFICATION
     pict_scale(P, X, Y, SX, SY)
     P: pointer to 'pict'
     X, Y, SX, SY: double

Description

   Scale the 'pict' pointed to by P by SX in the x-direction and SY in
the y-direction, leaving the point at (X, Y) fixed.  If the 'pict' is
linked to another 'pict', then that 'pict' is scaled the same way, and
so on until there are no more links.

Code fragment(s)

   _Scale all 4 pictures in the linked array 'p' by 1.5 in the
horizontal direction and 2.0 in the vertical direction, relative to the
fixed point (306.0, 72.0):_
     pict p[4];

     pict_scale(p, 306.0, 72.0, 1.5, 2.0);

SPECIFICATION
     pict_rotate(P, X, Y, DEGREES)
     P: pointer to 'pict'
     X, Y, DEGREES: double

Description

   Rotate the 'pict' pointed to by P counter-clockwise by DEGREES around
the point at (X, Y).  If the 'pict' is linked to another 'pict', then
that 'pict' is rotated the same way, and so on until there are no more
links.

Code fragment(s)

   _Rotate all 4 pictures in the linked array 'p' by 45.0 degrees
counterclockwise around the fixed point (306.0, 400.0):_
     pict p[4];

     pict_rotate(p, 306.0, 400.0, 45.0);


File: dap,  Node: Graphics output file,  Next: Picture datasets,  Prev: Transformations,  Up: Picture functions

8.7 Graphics output file
========================

A graphics output file must be started with a call to 'pict_init' (or a
function, such as 'pict_port', that calls 'pict_init') and ended with a
call to 'pict_end'.

SPECIFICATION
     pict_port(NPAGES)
     pict_land(NPAGES)
     NPAGES: int

Description

   Calls 'pict_init' to set up NPAGES portrait or landscape pages.

Code fragment(s)

   _Initialize a graphics output file for 3 pages in landscape
orientation:_
     pict_land(3);

SPECIFICATION
     pict_init(ORIENT, BBOXXL, BBOXYB, BBOXXR, BBOXYT, NPAGES)
     ORIENT, BBOXXL, BBOXYB, BBOXXR, BBOXYT, NPAGES: int

Description

   Initialize the graphics output file.  The character (not string)
ORIENT is either 'l', for landscape or 'p' for portrait.  The bounding
box is specified by the BBOX parameters and the number of pages by
NPAGES.  'pict_init' is called by 'pict_portrait' and 'pict_landscape'.

Code fragment(s)

   _Initialize a graphics output file for 4 pages in portrait
orientation with a bounding box with lower left corner (0, 0) and upper
right corner (612, 792):_
     pict_init('p', 0, 0, 612, 792, 4);

SPECIFICATION
     pict_page()

Description

   Begin new page.

SPECIFICATION
     pict_show(P)
     P: pointer to 'pict'

Description

   Write the picture commands to display the 'pict' pointed to by P into
the graphics output file.  If P is linked to another 'pict', then show
writes out the commands for that pict and so on until there are no more
links.

Code fragment(s)

   _Display the 4 'pict's in the linked array 'p':_
     pict p[4];

     pict_show(p);

SPECIFICATION
     pict_end()

Description

   Terminate the graphics output file.


File: dap,  Node: Picture datasets,  Prev: Graphics output file,  Up: Picture functions

8.8 Picture datasets
====================

SPECIFICATION
     pict_save(P, NPICTS, DATASET)
     P: pointer to 'pict'
     NPICTS: integer
     DATASET: string

Description

   This function is useful for saving picture information generated by
graphics functions, such as 'plotlogreg', that may require lengthy
execution times to generate pictures.  Saved picture datasets can be
restored quickly by calling 'pict_rest'.

   The function 'pict_save' saves the picture information in the array
of 'pict's P to the datasets DATASET.picXXXX, DATASET.ptsXXXX, and
DATASET.txtXXXX, where 'XXXX' is the index of the 'pict' in the array.
If NPICTS is 0, then 'pict_save' only saves the elements of 'p' that are
linked together, starting at the first element.  Otherwise, 'pict_save'
saves NPICTS 'pict's in the array.  NOTE: graphics functions, such as
'plot', link an extra 'pict' for each page or overlayed 'pict's for the
axes.

   The following details are not needed for saving 'pict' arrays
generated by 'dap' graphics functions.  'Pict_save' calls itself to save
patterns, if any, referenced in elements of P using DATASET.patXXXX as
the DATASET argument.  Patterns must be either single 'pict's or linked
arrays.  A link in the array P must always be to an element with an
index larger than the element linking to it.  (This condition is always
satisfied by the 'pict' arrays generated by graphics functions.)

Code fragment(s)

   _Save the 4 'pict's in the linked array 'p' in a picture datasets
with base name 'picture':_
     pict p[4];

     pict_save(p, 0, "picture");

   _Save the 4 'pict's in the unlinked array 'p' in a picture datasets
with base name 'picture':_
     pict p[4];

     pict_save(p, 4, "picture");

   _Save the 10 'pict's created by 'plotlogreg' in a picture datasets
with base name 'grad':_
     pict_save(plotlogreg("grad", "grad/1", "GPA", "==", 5, "year", 2, 0.95),
               10, "grad");

SPECIFICATION
     pict_rest( DATASET)
     DATASET: string
     RETURNS: pointer to 'pict'

Description

   Allocates an array of 'pict's and restores into that array a picture
saved to DATASET by 'pict_save'.

Code fragment(s)

   _Restore a picture from picture datasets with base name 'picture'
into the array array 'p':_
     pict *p;

     p = pict_rest("picture");

   _Restore and display a picture with 2 pages, created by 'plotlogreg',
from picture datasets with base name 'grad':_
     nport(pict_rest("grad"), 8, 4);


File: dap,  Node: Examples,  Next: Appendix I,  Prev: Picture functions,  Up: Top

9 Examples
**********

This chapter contains examples to illustrate the use of dap.  Data
files, programs, and output for the examples are provided in a directory
named 'examples'.

* Menu:

* Analysis of variance examples::
* Linear regression examples::
* Categorical data analysis examples::
* Logistic regression examples::
* Standard graphical output::
* Custom graphics::


File: dap,  Node: Analysis of variance examples,  Next: Linear regression examples,  Up: Examples

9.1 Analysis of variance
========================

These examples are from:

   * AMD: Milliken, G.A. and Johnson, D.E. 1984.  Analysis of Messy
     Data.  Van Nostrand Reinhold: New York.  473pp.

   * ED: Cochran, W.G. and Cox, G.M. 1957.  Experimental Designs.  John
     Wiley & Sons: New York.  611pp.


     /* AMD pp. 128 - 134: unbalanced layout using SBS  */

     data;
      infile "amd128.dat" firstobs=2; /* space separated, skip 1 header line */
      length treat $ 6 block $ 6;
      input treat block y;

     proc glm;
      class treat block;
      model y = treat block treat*block;
      lsmeans treat block / tukey;

     /* AMD pp. 249 - 251: using SBS
      * Two factors crossed, another nested within
      * levels of one crossed factor
      */

     data;
      infile "amd249.dat" firstobs=2;
      length a $ 1 b $ 1 c $ 1;
      input b c a y1 y2; /* two values per cell */
      y = y1;
      output;
      y = y2;
      output;

     proc glm;
      class a b c;
      model y = a b a*b c*b a*c*b;
      test h=a e=a*b;
      test h=b e=a*b b*c a*b*c;
      test h=a*b e=a*b*c;
      test h=c*b e=a*c*b;


     /* AMD pp. 265 - 273 using SBS
      * Random model, unbalanced
      */

     data;
      infile "amd265.dat" firstobs=2;
      length plant $ 1 site $ 1 worker $ 1;
      input plant worker site efficiency;

     proc glm;
      class plant site worker;
      model efficiency = plant plant*worker plant*site plant*site*worker;
      test h=site*plant e=site*worker*plant;

     proc glm;
      class plant site worker;
      model efficiency = plant plant*worker site*worker*plant;
      test h=worker*plant e=site*worker*plant;
      test h=plant e=worker*plant site*worker*plant;



     /* AMD pp. 285 - 289 using SBS
      * Mixed model, balanced
      */

     data;
      infile "amd285.dat" firstobs=2;
      length machine $ 1 person $ 1;
      input machine person prod1 prod2 prod3; /* 3 observations per cell */
      productivity = prod1;
      output;
      productivity = prod2;
      output;
      productivity = prod3;
      output;

     proc glm;
      class machine person;
      model productivity = machine person machine*person;
      test h=person e=machine*person;
      lsmeans machine / e=machine*person lsd;



     /* AMD pp. 290 - 295 using SBS
      * Mixed model, unbalanced
      */

     data;
      infile "amd290.dat" firstobs=2;
      length machine $ 1 person $ 1;
      input machine person productivity;

     proc glm;
      class machine person;
      model productivity = machine person machine*person;
      test h=person e=machine*person;
      lsmeans machine / e=machine*person lsd;



     /* AMD pp. 297 - 308 using SBS
      * Split plot
      */

     data;
      infile "amd297.dat" firstobs=2;
      length fertilizer $ 1 block $ 1 variety $ 1;
      input block variety fertilizer yield;

     proc glm;
      title "Whole plot (block, fertilizer) analysis";
      class fertilizer block variety;
      model yield = fertilizer block;
      lsmeans fertilizer / e=fertilizer*block LSD;

     proc glm;
      title "Subplot (variety) analysis";
      class fertilizer block variety;
      model yield = fertilizer block variety
                    fertilizer*block fertilizer*variety;



     /* ED pp. 122 - 125 using SBS
      * Latin square
      */

     data;
      infile "ed122.dat" firstobs=2;
      length sampler $ 1 area $ 1 order $ 1;
      input order area sampler error;

     proc glm;
      class sampler area order;
      model error = sampler area order;
      lsmeans sampler / lsd;


     /* ED pp. 176 using SBS and proc dap
      * Without covariate, with contrasts
      */

     data muscle;
      infile "sas976.dat" dlm="\t" firstobs=3;
      length rep $ 1 time $ 1 current $ 1 number $ 1;
      input rep time current number y;

     proc glm;
      class rep current time number;
      model y=rep current time number current*time current*number
              time*number current*time*number;
      contrast "curr 1 vs curr 2" current 1 -1;

     /* To construct the constrast for testing "time in current 3",
      * we have to modify the muscle.srt.mns.con file produced by glm.
      */
     proc dap;
     { /* start with brace to enclose everything */
       inset("muscle.srt.mns.con")
        {
          char rep[2], current[2], time[2];
          double y;
          char _type_[9]; /* N, MEAN, VAR, ERROR, CONTR, LSMEAN */
          int _term_; /* specifies term to which contrast applies */
          int more; /* to control stepping through dataset */
          double c1[4], c2[4], c3[4]; /* contrast with 3 df */
          outset("muscle.con", ""); /* datast for the F-test */
          /* set up the contrast coefficients */
          c1[0] = 1; c1[1] = 0; c1[2] = 0; c1[3] = -1;
          c2[0] = 0; c2[1] = 1; c2[2] = 0; c2[3] = -1;
          c3[0] = 0; c3[1] = 0; c3[2] = 1; c3[3] = -1;
          for (more = step(); more; )
           {
             output(); /* N, MEAN, VAR */
             step();
             output();
             step();
             output();
             for (step(); strcmp(_type_, "CONTR"); step()) /* get to CONTR lines */
               output();
             _term_ = 4; /* bits: 1 is rep, 2 is current, 4 is time */
             if (!strcmp(current, "3")) /* only in current 3 */
              {
                y = c1[time[0] - '1']; /* convert time to index */
                output();
                y = c2[time[0] - '1'];
                output();
                y = c3[time[0] - '1'];
                output();
              }
             else
              {
                y = 0.0;
                output();
                output();
                output();
              }
             while (more && !strcmp(_type_, "CONTR")) /* look for the ones we want */
                more = step();
             while (more && !strcmp(_type_, "LSMEAN")) /* get to next cell or end */
              {
                output();
                more = step();
              }
           }
        }
       /* muscle.con only has time in numerator so don't need to specify it */
       ftest("muscle.con", "y rep current time number", "", "", "");
     }


     /* AMD pp. 173 - 177:
      * missing treatment combinations
      */

     data amd173;
      infile "amd173.dat" firstobs=2;
      length treat $ 2 block $ 2;
      input treat block y;

     proc sort data=amd173;
      by treat block;

     proc means data=amd173 N MEAN VAR noprint;
      var y;
      by treat block;
      output out=amd173.mns;

     /* Now we have to create "by hand" the .con files for
      * the custom F-tests for the contrasts that are meaningful
      * in the presence of empty cells.
      */
     /* The first F-test (p. 175-76) is the interaction:
      * m11 - m13 - m21 + m23 = 0 and m21 - m22 - m31 + m32 = 0
      */
     proc dap;
     { /* start with a brace to enclose everything here */
       inset("amd173.mns") /* file from model statement */
        {
          char treat[3], block[3]; /* we're in C here! */
          double y;
          char _type_[9]; /* set this to CONTR */
          int _term_;     /* bits specify the effect */
          double c1[7], c2[7]; /* coeffs of the contrasts */
          int c; /* cell number */
          outset("amd173.mns.con", "treat block y _term_");
          /* cells, in sort order, are:
          /*   11       13       21       22      23       31      32 */
          c1[0]=1;c1[1]=-1;c1[2]=-1;c1[3]= 0;c1[4]=1;c1[5]= 0;c1[6]=0;
          c2[0]=0;c2[1]= 0;c2[2]= 1;c2[3]=-1;c2[4]=0;c2[5]=-1;c2[6]=1;
          _term_ = 3; /* bit 1 for treat, bit 2 for block */
          for (c = 0; step(); c++) /* while there's another cell */
           {
             output(); /* N, MEAN, VAR */
             step();
             output();
             step();
             output();
             strcpy(_type_, "CONTR");
             y = c1[c];
             output();
             y = c2[c];
             output();
           }
        }
       ftest("amd173.mns.con", "y treat block", "treat*block", "", "");

     /* The second F-test (p. 176-77) is the treat effect:
      * m11 + m13 - m21 - m23 = 0 and m21 + m22 - m31 - m32 = 0
      */
       inset("amd173.mns") /* file from model statement */
        {
          char treat[3], block[3]; /* we're in C here! */
          double y;
          char _type_[9]; /* set this to CONTR */
          int _term_;     /* bits specify the effect */
          double c1[7], c2[7]; /* coeffs of the contrasts */
          int c; /* cell number */
          outset("amd173.mns.con", "treat block y _term_");
          /* cells, in sort order, are:
          /*   11      13       21      22       23       31      32 */
          c1[0]=1;c1[1]=1;c1[2]=-1;c1[3]=0;c1[4]=-1;c1[5]= 0;c1[6]= 0;
          c2[0]=0;c2[1]=0;c2[2]= 1;c2[3]=1;c2[4]= 0;c2[5]=-1;c2[6]=-1;
          _term_ = 1; /* bit 1 for treat */
          for (c = 0; step(); c++) /* while there's another cell */
           {
             output(); /* N, MEAN, VAR */
             step();
             output();
             step();
             output();
             strcpy(_type_, "CONTR");
             y = c1[c];
             output();
             y = c2[c];
             output();
           }
        }
       ftest("amd173.mns.con", "y treat block", "treat", "", "");
     }


File: dap,  Node: Linear regression examples,  Next: Categorical data analysis examples,  Prev: Analysis of variance examples,  Up: Examples

9.2 Linear regression
=====================

     /* Bickel, P.J. and Doksum, K.A. 1977
      * Mathematical Statistics:
      * Basic Ideas and Selected Topics
      * Holden-Day: Oakland. 493.pp.
      * Example pp. 95 - 97.
      */

     data;
       infile "ms95.dat" firstobs=2;
       input soilphos plantphos;

     proc reg;
      model plantphos = soilphos;
      plot phantphos * soilphos;


     /* Rao, C.R. and Toutenberg, H. 1995 using SBS
      * Linear Models: Least Squares and Alternatives
      * Springer-Verlag: New York. 352 pp.
      * Example pp. 50 - 60.
      */

     data;
       infile "lm50.dat" firstobs=2;
       input y x1 x2 x3 x4;

     proc corr;
      var x1 x2 x3 x4 y;
      title "Correlations";

     proc reg;
      model y = x4;
      title "Model building";

     proc reg;
      model y = x4;
      add x1;

     proc reg;
      model y = x4 x1;
      add x3;

     proc reg;
      model y = x4 x1 x3;
      add x2;


File: dap,  Node: Categorical data analysis examples,  Next: Logistic regression examples,  Prev: Linear regression examples,  Up: Examples

9.3 Categorical data analysis
=============================

These examples are from CDA: Agresti, A. 1990.  Categorical Data
Analysis.  John Wiley & Sons: New York.  558pp.

     /* CDA pp. 49 - 50 using SBS */

     data;
      infile "cda50.dat" firstobs=2;
      length income $ 5 jobsat $ 10;
      input income jobsat count;

     proc freq;
      tables income * jobsat / measures chisq expected
                               norow nocol nopercent;
      weight count;

     /* CDA pp. 232 - 233 using SBS */

     data;
      infile "cda233.dat" firstobs=2;
      length penicillin $ 5 delay $ 4 response $ 5;
      input penicillin delay response count;

     proc freq;
      tables penicillin * delay * response / norow nocol nopercent cmh;
      weight count;


     /* CDA pp. 135 - 138, 171 - 174, 176 - 177
      * Here we fit loglinear models in table 6.3 on p. 172
      */
     #include <dap.h>

     void main()
     {
       infile("cda171.dat", " ")
         {
           char defendant[6], victim[6], penalty[4];
           double n;
           input("defendant victim penalty n");
           outset("cda171", "");
           skip(2);
           while (step())
             output();
         }

       sort("cda171", "defendant victim penalty", "");

       title("(DV, P) vs (D, V, P)");
       loglin("cda171.srt", "n defendant victim penalty",
              "victim penalty defendant", "defendant*victim penalty", "");

       sort("cda171.srt.llm", "defendant victim _type_ penalty", "");
       table("cda171.srt.llm.srt", "defendant victim", "_type_ penalty n",
             "s6.2 30", "");

       title("(DV, VP) vs (DV, P)");
       loglin("cda171.srt", "n defendant victim penalty",
              "defendant*victim penalty",
              "defendant*victim victim*penalty", "");
       sort("cda171.srt.llm", "defendant victim _type_ penalty", "");
       table("cda171.srt.llm.srt", "defendant victim", "_type_ penalty n",
             "s6.2 30", "");

       title("(DV, DP, VP) vs (DV, VP)");
       loglin("cda171.srt", "n defendant victim penalty",
              "defendant*victim victim*penalty",
              "defendant*victim defendant*penalty victim*penalty", "");
       sort("cda171.srt.llm", "defendant victim _type_ penalty", "");
       table("cda171.srt.llm.srt", "defendant victim", "_type_ penalty n",
             "s6.2 30", "");
     }


     /* CDA pp. 261 - 269
      * Here we fit the logit model for linear-by-linear association
      * to Table 8.2 on page 268.
      */
     #include <dap.h>

     double expect(double param[8], double class[2]);

     void main()
     {
       infile("cda262.dat", " ")
         {
           char Income[6], JobSat[10];
           double income, jobsat, count;
           input("Income JobSat count");
           outset("cda262", "");
           skip(1);
           while (step())
             {
               /* we have to convert to double for categ */
               if (!strcmp(Income, "<6"))
                 income = 0.0;
               else if (!strcmp(Income, "6-15"))
                 income = 1.0;
               else if (!strcmp(Income, "15-25"))
                 income = 2.0;
               else if (!strcmp(Income, ">25"))
                 income = 3.0;
               if (!strcmp(JobSat, "VeryDis"))
                 jobsat = 0.0;
               else if (!strcmp(JobSat, "LittleDis"))
                 jobsat = 1.0;
               else if (!strcmp(JobSat, "ModSat"))
                 jobsat = 2.0;
               else if (!strcmp(JobSat, "VerySat"))
                 jobsat = 3.0;
               output();
             }
         }

       {
         double param[8];
         int p;

         param[0] = 1.0;
         for (p = 1; p < 8; p++)
           param[p] = 0.0;
         categ("cda262", "count income jobsat", &expect, param,
               "mu <6 6-15 15-25 VD LD MS ?Inc*Sat", "", "");
         sort("cda262.cat", "income _type_ jobsat", "");
         table("cda262.cat.srt", "income", "_type_ jobsat count", "6.2", "");
       }
     }

     /* We use an independent subset of the parameters in order to
      * incorporate the zero-sum constraints. Thus, if class[0] == 3,
      * for example, then we use the fact that lambda^{income}_{>25} is
      * minus the sum of the other lambda^{income} parameters.
      */
     double expect(double param[8], double class[2])
     {
       double lx, ly;

       if (class[0] < 3.0)
         lx = param[1 + (int) class[0]];
       else
         lx = -(param[1] + param[2] + param[3]);
       if (class[1] < 3.0)
         ly = param[4 + (int) class[1]];
       else
         ly = -(param[4] + param[5] + param[6]);
       return exp(param[0] + lx + ly + param[7] * class[0] * class[1]);
     }


File: dap,  Node: Logistic regression examples,  Next: Standard graphical output,  Prev: Categorical data analysis examples,  Up: Examples

9.4 Logistic regression
=======================

     /* Agresti, A.  1990.  Categorical Data Analysis.
      * John Wiley & Sons: New York.  558pp.
      * Example pp. 87 - 89 using SBS with proc dap
      */
     data cda88;
       infile "cda88.dat" firstobs=2;
       input labind ncases nremiss;

     proc dap;
     nport(plotlogreg("cda88", "nremiss/ncases", "labind",
                      "== MAXX40 NXTICKS5 MAXY1 NYTICKS6 NYDIGITS2 NXDIGITS1",
                      5, "", 1, 0.95), 4, 4);



File: dap,  Node: Standard graphical output,  Next: Custom graphics,  Prev: Logistic regression examples,  Up: Examples

9.5 Standard graphical output
=============================

     /* Using plotmeans to plot means, both as symbols
      * and joined by lines, and 95% confidence intervals
      * of two groups of data together.
      */
     #include <dap.h>

     void main()
     {
     infile("standard.dat", " ")
       {
         int part;
         double x, y;

         input("x y part");
         outset("mtest", "");
         while (step())
           output();
       }

     title("Means of y. Error bars are 95% confidence for means");
       {
         pict *p;

         sort("mtest", "part x", "");
         p = plotmeans("mtest.srt", "y", "x", "SEM 1.96", "part", 2);
     /* p[0] and p[1] are error bars and means as points for group 1 */
         strcpy(p[1].pict_type, "TRIA");
     /* p[2] and p[3] are error bars and means as points for group 2 */
         strcpy(p[3].pict_type, "SQUA");

         nport(p, 4, 4);
       }
     }


File: dap,  Node: Custom graphics,  Prev: Standard graphical output,  Up: Examples

9.6 Custom graphics
===================

     /* This example illustrates the construction
      * of custom graphics.  We create two distributions
      * and display them as a split histogram: the bars
      * of one distribution extend horizontally to the
      * left and the bars of the other extend
      * horizontally to the right and are shaded.
      */
     #include <dap.h>

     #define NBARS 10

     void main()
     {
      /* these variables are not in the datasets */
     double min, max;  /* extremes of both
                        * distributions together
                        */
     double width;     /* width of the bars */

     infile("custom.dat", " ")
       {
         double x;
         int part;

         input("x part");
         outset("split", "");
         while (step())
           output();
       }

     means("split", "x", "MIN MAX", ""); /* find min, max */
     inset("split.mns")
       {
         double x;
         int n;
         char _type_[9];

         for (n = 0; n < 2; n++)
           {
             step();             /* and store them */
             if (!strcmp(_type_, "MIN"))
               min = x;
             else
               max = x;
           }
       }

     width = (max - min) / ((double) NBARS);

     inset("split")      /* compute class for each x */
       {
         double x;
         int class;

         outset("class", "x class part");
         while (step())
           {
             class = (int) floor((x - min) / width);
             if (class < 0)
               class = 0;
             else if (class > NBARS - 1)
               class = NBARS - 1;
             output();
           }
       }

     sort("class", "part class", "");
     /* compute counts in each class for each distribution */
     means("class.srt", "count", "N", "part class");

       {
       pict p[21];  /* one pict for each class for each part
                     * plus one for the axes
                     */
       int pn;

       pict_initpict(NULL, p);  /* initialize the pict structs */
       for (pn = 1; pn < 21; pn++)
         pict_initpict(p + pn - 1, p + pn);

       inset("class.srt.mns")
         {
           int part, class;
           double classmin, count;

           while (step())
             {
               classmin = min + width * ((double) class);
               /* make a rectangle */
               pict_rectangle(p + NBARS * part + class,
                   0.0, classmin, (part ? count : -count), width);
               /* shade the ones on the right */
               if (part)
                 p[NBARS * part + class].pict_fgray = 0.8;
             }
         }
       /* set up the axes */
       pict_autoaxes(p, "Count", "X", "==", &fabs, NULL,
                               "Split histogram", 1);
       /* and make it all appear */
       pict_port(1);
       pict_page();
       pict_show(p);
       pict_end();
       }
     }


File: dap,  Node: Appendix I,  Next: Appendix II,  Prev: Examples,  Up: Top

Appendix I: Settable parameters
*******************************

The following list of settable parameters and their default values is in
'dap.h':

     /* Parameters for variables */
     DAP_MAXVAR 256  /* max number of variables in a dataset */
                     /* if changed to >= 10,000, change dimstr in dap0.c */
     DAP_NAMELEN 15  /* max length of variable names (+1 for null) */
     DAP_INTLEN 20  /* max number of char in char representation of int */
     DAP_LISTLEN (256 * (16 + 6))
      /* max length of list of variables: dap_maxvar *
       * (max var name length + room for bracketed index)
       * This may not be entirely safe! (but most likely is)
       */
     DAP_TOOLONG 10 /* max # times to print "string too long" message */
     DAP_STRLEN 63  /* max length of some string values */

     /* Parameters for tables */
     DAP_MAXROWS 1024  /* max rows for table() */
     DAP_MAXCOLS 64  /* max columns for table() */
     DAP_MAXCLAB 128  /* max number of column labels */
     DAP_MAXROWV 8  /* max number of row variables */
     DAP_MAXCOLV 8  /* max number of column variables */
     DAP_LABLEN 63  /* max number of non-null char in column label */

     /* Parameters for datasets */
     DAP_SETDIR "dap_sets"  /* where datasets are stored */
     DAP_MAXVAL 32768  /* max number of values for some stat functions*/
     DAP_MAXCELL 512  /* max number of cells in some internal tables */
     DAP_MAXTREAT 9  /* max number of factors for ANOVA */

     /* Parameters for grouping */
     DAP_MAXBARS 128  /* max number of bars for histograms, grouping */
     DAP_MAXLEV 96  /* max number of levels of a variable */

     /* Parameters for I/O */
     DAP_LINELEN 2047  /* max number of char for input line (+1 for null) */
     DAP_OUTREPORT 100000
        /* report multiples of this number of lines written */

     /* Parameters for graphics */
     DAP_MAXPTS 16384  /* max number of points in a pict */
     DAP_MAXCHAR 65536  /* max number of text chars in all the picts */
     DAP_MAXNTXT 128  /* max number of text chars in a pict */
     DAP_MAXTXT 127   /* max number of chars in a single string */
     DAP_MAXFONT 63   /* max number of chars in a font name */

     /* Parameters for numerical algorithms */
     DAP_REDTOL 1e-9 /* to tell if row is zero in reduction */
     DAP_ORTHTOL 1e-9 /* to tell if row is zero in orthog */
     DAP_ZEROTOL 1e-6 /* to tell if row is zero in matrix ops */
     DAP_TOL 1e-8    /* for pivoting, etc. in matrix ops */
     DAP_CTOL 1e-6   /* for iterative reweighted least sq (logreg) */
     DAP_KTOL 1e-6   /* for significance of Kolmogorov statistic */
     DAP_PRTOL 1e-6  /* for inverse prob functs: should disappear */
     DAP_ADDTOZERO 1e-8  /* for contingency tables */
     DAP_MAXITER 500 /* max number of iterations */
     DAP_MAXEX1 20  /* max number of values for exact test */
     DAP_MAXEX2 20  /* max number of values for exact test */
     DAP_CATTOL 0.0000005 /* tolerance for convergence in categ() */

     /* Parameters for memory files */
     DAP_NRFILES 128  /* number of files stored in memory */
     DAP_RFILESIZE 16384  /* max number of bytes in a memory file */
     DAP_MAXLINES 2048  /* max number of lines in memory file:
                         * keep at dap_rfilesize / 8
                         */
     DAP_MAXMEM 1048576 /* memory buffer size for sorting */
     DAP_TMPDIR "dap_tmp" /* directory for temporary files for sorting */

     /* Memory allocation tracing */
     DAP_MEMTRACE NULL  /* if non-NULL, print trace of malloc and free
                         * and if address = dap_memtrace, then...
                         */
     DAP_MABORT 0  /* abort on malloc */
     DAP_FABORT 0  /* abort on free */


File: dap,  Node: Appendix II,  Next: Appendix III,  Prev: Appendix I,  Up: Top

Appendix II: Essentials of C syntax
***********************************

This appendix explains the most basic syntax of C needed for using dap.
There are many books to which you can refer for more detailed or more
advanced descriptions of C. Note that the GNU editor 'emacs' has special
provisions for editing C programs.

* Menu:

* Variables and operations::
* Functions::
* Loops and 'if's::


File: dap,  Node: Variables and operations,  Next: Functions,  Prev: Appendix II,  Up: Appendix II

Variables and operations
========================

A "variable" is a box in which one or more numbers or characters, or
even more complicated objects called "structures", are stored.  You
_must_ use a "declaration" to indicate exactly what kind of contents the
box will hold and what name you are going to use to refer to the box
before you use the box to store anything or else the computer won't know
what kind of information is stored in the box and how to use it.  (Names
must contain only letters and numbers and '_' and must not start with a
number.)  For example,

     int n;
is a declaration that indicates that the box named 'n' will hold an
integer (whole number).  Non-integer numbers, such as '2.718', are
referred to as "double precision floating point" numbers, or simply as
"doubles".  For example,

     double x;
is a declaration that indicates that the box named 'x' will hold a
double.  There is a special value called "NaN", which stands for
"Not-a-Number", for undefined values of a double.

   Numbers and characters and structures can each be grouped into
ordered collections known as "arrays"; arrays of characters are called
"strings".  For example, the declaration

     char employee[21];
indicates that the box named 'employee' will hold a string of 21
characters, say, the employee's name.  The last character of a string of
characters is usually used to hold a special character that marks the
end of the string, so that 'employee' will really be limited to 20
ordinary characters.  The character that marks the end of a string is
called the "null character" and is denoted '\0'.

   You can also declare, for example,

     double y[3];
to indicate a box that will hold 3 doubles.  Brackets '[' and ']' also
allow you to refer to the individual doubles in the array: the three
elements of 'y' are 'y[0]', 'y[1]', and 'y[2]'.  (The numbering of array
elements always starts at 0.)  Such referencing can be used for arrays
of characters, integers, or structures, too.

   The most common kind of structure in dap is the 'pict' structure,
which contains graphical information that is used by graphics functions;
'pict's are most often collected into arrays.  In some cases you may not
know for certain or care how many 'pict' structures are in the array, in
which case you can use a declaration like this:

     pict *p;
which indicates that the graphics function that sets up the array of
picts to be stored in the box named 'p' will allow for however many
picts that graphics function needs.  In this case, 'p' is usually
referred to as a "pointer" to 'pict', and in that sense, 'p' is
interpreted as the location in the computer's memory of the first 'pict'
in the array.  Nevertheless, you can still refer to the 'pict's in the
array as 'p[0]', 'p[1]', etc.

   The pointer concept, as a location in the computer's memory, is used
in other contexts, too.  One use is to be able to distinguish between a
string that has no interesting characters in it, that is, a string whose
first character is the null character, and a string that doesn't exist
at all.  The former is called a "null string", and is denoted '""', and
the latter is called a "null pointer", and is denoted 'NULL'.  Another
use of pointers involves functions, which are described in the next
section.  Functions have locations in the computer's memory and can be
referred to by pointers: if 'f' is a function, then '&f' is a pointer to
that function.

   There are many operations that can be used on variables, but the most
common operations are copying and arithmetic operations.  For example,
the "statement"

     x = y + z;
computes the sum of the numbers in the boxes named 'y' and 'z' and
copies that sum into the box named 'x'; note that the contents of 'y'
and 'z' are unchanged.  Note that the paradoxical-looking statement

     x = -x;
says to copy the negation of the contents of 'x' back into 'x'.  Copying
strings is more complicated and is described in the next section.

   Two very common arithmetic operations that can be used only on 'int'
variables are '++', '--': For example, the statement

     n++;
increments, i.e., increases by 1, the number stored in 'n'.  Similarly,

     n--;
decrements, i.e., decreases by 1, the number stored in 'n'.


File: dap,  Node: Functions,  Next: Loops and 'if's,  Prev: Variables and operations,  Up: Appendix II

Functions
=========

"Functions" are program parts that are usually stored in "libraries" and
can be used from a program.  For example, a dap program could contain
the statement

     means("data", "x", "SUM", "");
which "calls", i.e., uses, the function 'means', which is stored in a
library that is supplied with dap, to compute the sum of the values of
the variable 'x' in the dataset 'data'.  The comma-separated, quoted
strings '"data"', '"x"', '"SUM"', and '""' are called "arguments" to the
function and they tell the function what to operate on and how.  This
particular function will create a dataset named 'data.mns' that will
contain the computed sum.

   Two functions that are not supplied with dap but that are available
nonetheless in the standard C library and that are commonly used in dap
programs are 'strcpy' and 'strcmp'.  The first is used for copying
strings and the second is used for comparing strings.  For example,
following the declaration

     char employee[21];
you could write the statement

     strcpy(employee, "Bassein, Susan");
which calls the 'strcpy' function to copy the 14 characters between the
quotes into the string 'employee' and follow it with the null character,
for a total of 15 characters.  NOTE: An explicit string of characters
must be enclosed in double quotes ("..."), not single quotes ('...').
WARNING: Serious program bugs can be caused by copying more characters
into a string than are allotted in the declaration!

   The 'strcmp' function is typically used in loops and 'if's and is
described in the next section.

   Functions can also "return a value", which means that the function
can provide a value that can be copied into a variable.  For example,
after the declaration

     int more;
you could write

     more = step();

   This statement calls the function 'step', which attempts to read one
line from the input data file or dataset and then returns the integer 1
or 0, if there was or was not, respectively, another line to be read
from the file or dataset.  (Note that although 'step' does not require
any arguments, the parentheses are still necessary, to identify it as a
call to a function.)  Thus, 'more' would contain the value 1 if 'step'
successfully read another line or the value 0 if the previous call to
'step' had read the last line in the input data file or dataset.

   You can also define functions in your program.  In particular, 'main'
is a function that must appear in every dap program.  The "body" of the
definition of a function must always be enclosed between '{' and '}'.
The example program cda262.c (*note Categorical data analysis
examples::) illustrates the definition and use of a function required by
the categorical data analysis function 'categ' to compute expected cell
frequencies from parameter values.


File: dap,  Node: Loops and 'if's,  Prev: Functions,  Up: Appendix II

Loops and 'if's
===============

"Loops" allow an action to be repeated, either until some condition
arises or for a fixed number of times.  The most common loop in dap
programs looks like this (with possible enhancements):

     while (step())
       output();
This loop repeats reading a line from the input data file or dataset and
writing the data to the output dataset until there are no more lines to
be read.  More specifically, it attempts to read a line and if there was
a line to be read, it writes the data to the output dataset and attempts
to read the next line; otherwise it "breaks out of the loop" and
continues to the next line of the program.  Note that a value of 1 (or,
in fact, any non-zero value) is taken to mean "TRUE" and a value of 0 is
taken to mean "FALSE", so that these lines can be interpreted as saying,
"While (i.e., as long as) it is TRUE that step has read another line,
output the data from that line".

   A 'for' loop can be used to read, say, the first 100 lines of the
input data file or dataset:

     int n;

     for (n = 1; n <= 100; n++)
       {
         step();
         output();
       }
The 'for' statement has three parts within the parentheses, separated by
semi-colons: the "initialization", 'n = 1', which starts the loop; the
"test", 'n <= 100', which acts as though it is inside the parentheses in
a 'while' statement; and the "increment", 'n++', which gets performed
after each repetition of the body of the 'for' loop.  (Note that the
body of the 'for' in this case must be enclosed between '{' and '}'
because, unlike the body of the 'while' above, it contains more than one
statement.)

   The previous example will fail if there are fewer than 100 lines in
the input data file or dataset because 'step' will stop your program if
you try to read another line of the input data file or dataset after a
previous call to 'step' has returned a 0.  One better alternative would
be to use an 'if':

     int n;

     for (n = 1; n <= 100; n++)
       {
         if (step())
           output();
         else
           break;
       }
In this example, the 'break' causes the program to break out of the loop
when 'step' returns a 0.

   Suppose you wanted to write into the output dataset all the lines
from the input data file for which the 'employee' was named "Bassein,
Susan".  You could use the "logical negation" operator '!' with the
string comparison function 'strcmp' as follows:

     char employee[21];

     while (step())
       {
         if (!strcmp(employee, "Bassein, Susan"))
           output();
       }
because 'strcmp' returns 0 if the strings are the same and a non-zero
number otherwise and '!' turns a 0 into a 1 and a non-zero integer into
0.

   The C language provides two operators that allow you to combine
conditions to be tested in 'while', 'for', and 'if' statements: logical
"and", '&&', and logical "or", '||'.  For example, the previous code
could be modified to select only those records for "Bassein, Susan" that
had a value greater than or equal to 10 for a variable named 'hours':

     char employee[21];
     double hours;

     while (step())
       {
         if (!strcmp(employee, "Bassein, Susan") && hours >= 10.0)
           output();
       }


File: dap,  Node: Appendix III,  Next: Appendix IV,  Prev: Appendix II,  Up: Top

Appendix III: Troubleshooting
*****************************

Many things can go wrong with a program.  At the simplest level, there
can be an error in "syntax", which would cause the preprocessor or the
compiler to be unable to interpret what is meant by a statement.  For
example, a syntax error commonly made by novices is to forget to include
the semi-colon that is required at the end of every declaration or
statement.  Another common error is to have a left brace '{' without a
matching right brace '}' (or vice versa); using appropriate indentation
in your program and the features of your text editor will help you find
unmatched braces.  If your program has a syntax error, you will get a
message indicating the line number of the statement containing the error
and why the preprocessor or the compiler couldn't interpret that
statement.  (Missing semi-colons often confuse the compiler so badly
that the error message can be hard to interpret.)  In that case, you
simply edit your program to correct the error and compile and run it
again.

   If your program uses too many variables, lines that are too long,
variable names or strings that are too long, etc., then you will get a
message that indicates the problem during execution.  You can solve that
problem by setting the value of the appropriate parameter as described
in *note Reading files and datasets::.

   More serious bugs will result in the program "crashing", which means
that the program will stop before completing its task, often with no
output of any sort.  In that case, the system will produce a file named
'core', which is a snapshot of what point the program reached when it
crashed.  If that happens, exit dap and use a "debugger" to examine the
core file.  For example, to use the GNU debugger 'gdb' on the core file
produced by a crash in prog.c, you would type

     gdb prog.dap core
Then, typing

     where
will tell you the number of the line reached by your program, and the
functions that it called, when the program crashed.  A debugger is a
powerful and somewhat complicated program; you should read at least some
of its documentation before you use it.

   If a program doesn't crash but still doesn't produce output, most
probably it is executing in an "infinite loop", that is, a loop whose
condition for terminating is never met.  Such a situation is
particularly dangerous if there is a call to 'output' in tha loop, so
that more and more lines are being written to the output dataset, which
therefore runs the risk of completely filling up your disk.  You can
terminate a program by typing "control-C" (_twice_, if you are using the
Emacs interface) which means pressing both the 'Control' (or 'Ctrl') key
and the 'C' key at the same time.

   Still more serious bugs will result in the program giving nonsense
results.  Often, you can track down such bugs by inserting calls to the
dap 'print' function at strategic points in your program, and running
the program again, to display intermediate files to see where the
program started to have problems.  If that fails, a debugger is a good
tool for tracking down unintended values of your variables.

   The most serious bugs will result in the program giving
sensible-looking but wrong results.  To catch bugs of that sort requires
a thorough understanding of approximately what your results should look
like, some experience with the statistical functions you are using, and
a lot of patience.


File: dap,  Node: Appendix IV,  Next: FAQ,  Prev: Appendix III,  Up: Top

Appendix IV: SBS
****************

This section contains miscellaneous notes and warnings regarding the use
of SBS. WARNING: When processing FILE.sbs, dap writes (or overwrites)
the file FILE.c.  Note that because the syntax and options of SBS and
dap graphics procedures are not very compatible, many dap graphics
options are not available in SBS (which is one reason that I wrote dap
in the first place); for complete access to dap graphics options (or
statistical options) from SBS, use a 'proc dap' statement (see below).
In addition, you can define your own functions in a separate '.c' file
that you include on the command line to run dap.  (To declare such
functions in the '.sbs' file, use a 'proc dap' statement at the
beginning of the file.)  Note that if the program does not use a
graphics proc, compiling will produce a number of warnings about unused
variables, all of whose names begin and end with an underscore '_'; you
may ignore them.

   One peculiarity that SBS inherits from C through dap is that
character variables that are explicitly used in a data step always need
to appear in a 'length' statement, no matter whether the data step gets
its data from a 'set', a 'merge' or an 'infile' statement.

   Important notes regarding data steps (at least through this version
of dap):

  1. Comparison, assignment, and concatenation of strings must be
     performed using the C functions 'strcmp' (or its variants),
     'strcpy' (or its variants), and 'strcat' (or its variants);

  2. C-style subscripting (i.e., with '[ ]') must be used for obtaining
     individual characters from a string except that in SBS, array
     indexes start at 1, not 0 as in C.

  3. Mnemonics are not accepted for relational or logical operators
     (e.g., 'ne' is not accepted for '^=');

  4. The only statements accepted in the body of a data step, other than
     numerical assignment statements, are 'if-then', 'if-then-else',
     'do', 'do while', 'end', and 'output';

  5. FIRST.variable is allowed by 'by' groups, but not LAST.variable.

  6. Syntax errors in the body of a data step may not be caught by the
     SBS-to-dap translator, but will subsequently be caught by either
     the dap preprocessor or the C compiler.  However, the line numbers
     referred to by those programs will be the line numbers of the dap
     program into which your SBS program was translated, which you can
     view by opening up file FILE.c if you ran dap on FILE.sbs.

     data [OUTPUT-FILE-NAME [({drop | keep}=VARIABLE [... VARIABLE])];
     length VARIABLE-1 $ LENGTH-1 [... VARIABLE-N $ LENGTH-N];
     infile "INFILE-NAME" [{delimiter | dlm}="DELIMETER"]
                            [firstobs=N];
     input VARIABLE-1 [START-COL-1 [-END-COL-1]]
           [... VARIABLE-N [START-COL-N [-END-COL-N]]];
     set DATASET-NAME;
     merge DATASET-NAME-1 [({drop | keep}=VARIABLE [... VARIABLE])]
          DATASET-NAME-2 [({drop | keep}=VARIABLE [... VARIABLE])];
     by VARIABLE-LIST;
     {drop | keep} VARIABLE-LIST;

     SBS note: for column input, it is not possible to skip columns,
     i.e., 'start-col-1' must be 1 and each succeeding 'start-col' must
     be one more than the preceeding 'end-col'.

     proc dap;
     DAP-STATEMENT

     SBS note: DAP STATEMENT can either be enclosed in braces '{ }' or
     end with a semi-colon ';'.  Attempting to use dap graphics and SBS
     graphics in the same program will produce unpredictable and,
     perhaps, undesirable results.  Note that DAP STATEMENT is run as-is
     by dap and, in particular, indexes of array subscripts start at 0.
     The DAP STATEMENT cannot use the '0x' prefix for hexidecimal
     numbers.


File: dap,  Node: FAQ,  Next: Index,  Prev: Appendix IV,  Up: Top

Frequently Asked Questions
**************************

* Menu:

* I cannot find a function::
* I want to split a dataset::
* Logistic regression reported a singular matrix::
* How do I add a line to a plot?::


File: dap,  Node: I cannot find a function,  Next: I want to split a dataset,  Prev: FAQ,  Up: FAQ

I cannot find a function
========================

Q: I cannot find a function to delete spurious zeros from my dataset
without deleting anything else.  What do I do?

   A: You have to write some C code (*note Appendix II::) for that:
     while (step())
       {
         if (yield > 0.0)
           output();
       }


File: dap,  Node: I want to split a dataset,  Next: Logistic regression reported a singular matrix,  Prev: I cannot find a function,  Up: FAQ

I want to split a dataset
=========================

Q: I want to split a dataset based on the value of a variable.  How do I
do that?

   A: Assume that the variable to be used is a character variable named
'part' with 9 characters (including the terminating null) and that
dataset 'set' is sorted by 'part'.  The following code fragment creates
a dataset for each value of 'part' and names it that value.

     inset("set")
       {
         char part[9];
         int partv[1];

         daplist("part", partv, 1);
         if (step())  /* to get started */
           {
             outset(part, "");
             output();
             while (step())  /* to continue */
               {
                 if (dap_newpart(partv, 1))
                   outset(part, "");
                 output();
               }
           }
       }


File: dap,  Node: Logistic regression reported a singular matrix,  Next: How do I add a line to a plot?,  Prev: I want to split a dataset,  Up: FAQ

Logistic regression reported a singular matrix
==============================================

Q: Logistic regression reported a singular matrix, but my data seems OK.

   A: You may need to lower the value of DAP_CTOL (*note Appendix I::),
which is used to zero-out matrix entries that appear to be non-zero only
as the result of round-off errors.


File: dap,  Node: How do I add a line to a plot?,  Prev: Logistic regression reported a singular matrix,  Up: FAQ

How do I add a line to a plot?
==============================

Q: I plotted a dataset using 'plot' and I want to add a line to it.  How
do I do that without knowing the scaling and translating used by 'plot'?

   A: In your call to 'plot', specify 'MINX', 'MAXX', 'MINY', and
'MAXX'.  Don't use 'nport' or 'nland'; rather use 'pict_port',
'pict_land', or 'pict_init' to start the graphics section of your
program (and don't forget 'pict_page', 'pict_show', and 'pict_end').
Then declare an array of 2 'pict's and use 'pict_initpict' to initialize
them as a list.  Then use 'pict_line' on the first of these 2 picts and
call 'pict_autoaxes' with the same axis specifications (although you can
set 'NXTICKS' and 'NYTICKS' to 0 if you wish).  You can use the same
axis labels, overwrite them, or leave them as null strings.  Finally,
call 'pict_show'.

   Here's an example:


     #include <dap.h>

     void main()
     {
       infile (NULL, NULL)
         {
           double x, y;
           int n;
           outset("gtest", "");
           for (n = 0; n < 10; n++)
             {
               x = varnorm();
               y = varnorm();
               output();
             }
         }
       {
         pict *p, p1[2];

         pict_port(1);
         pict_page();

         p = plot("gtest", "x y", "", "== MINX-4 MAXX4 MINY-4 MAXY4",
                  NULL, NULL, 1);
         pict_show(p);

         pict_initpict(NULL, p1);
         pict_initpict(p1, p1 + 1);
         pict_line(p1, -3.0, 2.0, 2.0, -1.0);
         pict_autoaxes(p1, "", "",
                       "== MINX-4 MAXX4 MINY-4 MAXY4 NXTICKS0 NYTICKS0",
                       NULL, NULL, "", 1);
         pict_show(p1);

         pict_end();
       }
     }


File: dap,  Node: Index,  Prev: FAQ,  Up: Top

Index
*****

 [index ]
* Menu:

* #define:                               The preprocessor.    (line   9)
* _corr_:                                Correlations.        (line  22)
* _term_:                                Analysis of variance.
                                                              (line  39)
* _type_:                                Input and output.    (line  72)
* _var1_:                                Correlations.        (line  22)
* _var2_:                                Correlations.        (line  22)
* abort:                                 Invoking Dap.        (line  61)
* abort <1>:                             Appendix III.        (line  51)
* analysis of variance:                  Analysis of variance.
                                                              (line  18)
* analysis of variance <1>:              Analysis of variance examples.
                                                              (line   6)
* ANOVA:                                 Analysis of variance.
                                                              (line  18)
* ANOVA <1>:                             Analysis of variance examples.
                                                              (line   6)
* append:                                Manage datasets.     (line  15)
* arguments:                             Invoking Dap.        (line  70)
* arguments <1>:                         Invoking Dap.        (line 103)
* arguments <2>:                         Invoking Dap.        (line 104)
* array:                                 Reading files and datasets.
                                                              (line  49)
* array <1>:                             Variables.           (line  28)
* array <2>:                             Variables and operations.
                                                              (line  27)
* array of char:                         Description and example.
                                                              (line 118)
* association:                           Categorical data analysis.
                                                              (line  57)
* association <1>:                       Categorical data analysis.
                                                              (line  65)
* autoaxes:                              Axes.                (line  43)
* axes:                                  Axes.                (line  13)
* axes <1>:                              Axes.                (line  43)
* axes <2>:                              Axes.                (line  99)
* binary:                                Categorical data analysis examples.
                                                              (line   6)
* binomial coefficient:                  Miscellaneous functions.
                                                              (line  10)
* broken lines:                          Pict structure.      (line  48)
* bug:                                   Variables.           (line  18)
* bug <1>:                               Analysis of variance.
                                                              (line  34)
* bug <2>:                               Functions.           (line  33)
* bug <3>:                               Appendix III.        (line   6)
* C:                                     Description and example.
                                                              (line  13)
* caption:                               Output files.        (line  51)
* caption <1>:                           Axes.                (line  43)
* categ:                                 Categorical data analysis.
                                                              (line 127)
* categ <1>:                             Categorical data analysis.
                                                              (line 199)
* categ <2>:                             Statistics utilities.
                                                              (line   9)
* categorical data:                      Categorical data analysis examples.
                                                              (line   6)
* categorical data analysis:             Categorical data analysis.
                                                              (line 127)
* categorical data analysis <1>:         Categorical data analysis.
                                                              (line 199)
* categorical data analysis <2>:         Statistics utilities.
                                                              (line   9)
* char, array:                           Description and example.
                                                              (line 118)
* chart (SBS proc):                      Histogram.           (line  19)
* chi-squared:                           Categorical data analysis.
                                                              (line  32)
* chi-squared <1>:                       Chi-squared distribution.
                                                              (line   6)
* chi-squared <2>:                       Categorical data analysis examples.
                                                              (line   6)
* choose:                                Miscellaneous functions.
                                                              (line  10)
* circle:                                Shapes.              (line  10)
* CMH:                                   Categorical data analysis.
                                                              (line  36)
* Cochran-Mantel-Haenszel:               Categorical data analysis.
                                                              (line  36)
* Cochran-Mantel-Haenszel <1>:           Categorical data analysis examples.
                                                              (line   6)
* column percentage:                     Categorical data analysis.
                                                              (line  41)
* combinations:                          Miscellaneous functions.
                                                              (line  10)
* command line arguments:                Invoking Dap.        (line  70)
* command line arguments <1>:            Invoking Dap.        (line 103)
* commas, not:                           Variables.           (line  23)
* comparing strings:                     Functions.           (line  36)
* comparing strings <1>:                 Loops and 'if's.     (line  63)
* compiler:                              Invoking Dap.        (line  88)
* compress:                              Transformations.     (line  30)
* constants:                             Reading files and datasets.
                                                              (line  77)
* constants <1>:                         Appendix I.          (line   7)
* contingency table:                     Categorical data analysis.
                                                              (line  17)
* contingency table <1>:                 Categorical data analysis examples.
                                                              (line   6)
* contrasts:                             Analysis of variance.
                                                              (line  23)
* control:                               Analysis of variance.
                                                              (line 154)
* copy:                                  Manage datasets.     (line  15)
* copying strings:                       Functions.           (line  21)
* corr:                                  Correlations.        (line  37)
* corr (SBS proc):                       Correlations.        (line  14)
* correlation:                           Correlations.        (line  36)
* count:                                 Categorical data analysis.
                                                              (line  44)
* cross classification:                  Categorical data analysis examples.
                                                              (line   6)
* cross tabulation:                      Categorical data analysis examples.
                                                              (line   6)
* cross-classification:                  Categorical data analysis.
                                                              (line  17)
* cross-tabulation:                      Categorical data analysis.
                                                              (line  17)
* curve:                                 Shapes.              (line  83)
* dap (SBS proc):                        Appendix IV.         (line   6)
* dap.h:                                 Reading files and datasets.
                                                              (line  12)
* dap.h <1>:                             Reading files and datasets.
                                                              (line  77)
* dap1.h:                                Reading files and datasets.
                                                              (line  15)
* dappp:                                 Reading files and datasets.
                                                              (line   6)
* dap_dl:                                The preprocessor.    (line  23)
* dap_dl <1>:                            The preprocessor.    (line  28)
* dap_head:                              Output files.        (line   9)
* dap_il:                                The preprocessor.    (line  23)
* dap_il <1>:                            The preprocessor.    (line  28)
* dap_list:                              Partitioning a dataset.
                                                              (line  12)
* dap_main:                              The preprocessor.    (line  16)
* dap_mark:                              Positioning within a dataset.
                                                              (line   8)
* dap_mark <1>:                          Positioning within a dataset.
                                                              (line  20)
* dap_newpart:                           Partitioning a dataset.
                                                              (line  51)
* dap_rest:                              Modifying output.    (line  16)
* dap_rewind:                            Positioning within a dataset.
                                                              (line  16)
* dap_save:                              Modifying output.    (line   8)
* dap_sets:                              Input and output.    (line  83)
* dap_sl:                                The preprocessor.    (line  23)
* dap_sl <1>:                            The preprocessor.    (line  28)
* dap_swap:                              Partitioning a dataset.
                                                              (line  39)
* dap_vd:                                The preprocessor.    (line  23)
* dap_vd <1>:                            The preprocessor.    (line  26)
* darkness:                              Pict structure.      (line  71)
* darkness <1>:                          Pict structure.      (line  74)
* dashing:                               Pict structure.      (line  48)
* data step (SBS):                       Appendix IV.         (line  53)
* dataset:                               Variables.           (line  31)
* dataset <1>:                           Datasets.            (line   6)
* dataset <2>:                           Input and output.    (line  83)
* dataset <3>:                           Positioning within a dataset.
                                                              (line  16)
* dataset <4>:                           Manage datasets.     (line  15)
* dataset in memory:                     Datasets.            (line  26)
* dataset in memory <1>:                 Input and output.    (line  78)
* dataset on disk:                       Datasets.            (line  26)
* dataset on disk <1>:                   Input and output.    (line  78)
* dataset, output:                       Input and output.    (line  62)
* dataset, partitioning:                 Datasets.            (line  15)
* dataset, partitioning <1>:             Partitioning a dataset.
                                                              (line  51)
* dataset, small:                        Datasets.            (line  26)
* dataset, small <1>:                    Input and output.    (line  78)
* datasets (SBS proc):                   Manage datasets.     (line  15)
* date:                                  Miscellaneous functions.
                                                              (line  63)
* date <1>:                              Miscellaneous functions.
                                                              (line  82)
* debugging:                             Invoking Dap.        (line 102)
* declaration:                           Reading files and datasets.
                                                              (line  37)
* declaration <1>:                       Variables.           (line   9)
* declaration <2>:                       Variables.           (line  13)
* declaration <3>:                       Variables and operations.
                                                              (line   8)
* define:                                The preprocessor.    (line   9)
* delimiter:                             Reading files and datasets.
                                                              (line  56)
* delimiter <1>:                         Datasets.            (line  12)
* diamonds:                              Pict structure.      (line  41)
* dimension:                             Reading files and datasets.
                                                              (line  49)
* display:                               Displaying the pictures.
                                                              (line  36)
* display <1>:                           Graphics output file.
                                                              (line  53)
* distribution-free:                     Nonparametric analyses.
                                                              (line  41)
* double:                                Variables and operations.
                                                              (line  19)
* Dunnett:                               Analysis of variance.
                                                              (line 153)
* editor:                                Invoking Dap.        (line  85)
* effects:                               Analysis of variance.
                                                              (line  18)
* empirical distribution function:       Nonparametric analyses.
                                                              (line  40)
* end of file:                           Input and output.    (line  32)
* EOF:                                   Input and output.    (line  32)
* error bar:                             Plotting means.      (line   6)
* estimate:                              Statistics utilities.
                                                              (line   9)
* exact test:                            Categorical data analysis.
                                                              (line  51)
* execution:                             Reading files and datasets.
                                                              (line  77)
* execution <1>:                         Appendix I.          (line   7)
* expand:                                Transformations.     (line  30)
* expected count:                        Categorical data analysis.
                                                              (line  47)
* exploratory data analysis:             Invoking Dap.        (line  76)
* extreme value:                         Miscellaneous functions.
                                                              (line  22)
* extreme values:                        Trimming extreme values.
                                                              (line  32)
* F distribution:                        F distribution.      (line   6)
* F-test:                                Analysis of variance.
                                                              (line  23)
* F-test <1>:                            Analysis of variance.
                                                              (line  85)
* fill:                                  Manage datasets.     (line  15)
* fill, darkness:                        Pict structure.      (line  74)
* Fisher's exact test:                   Categorical data analysis.
                                                              (line  51)
* Fisher's LSD:                          Analysis of variance.
                                                              (line 153)
* fixed-width:                           Reading files and datasets.
                                                              (line  57)
* font:                                  Pict structure.      (line  53)
* font <1>:                              Text.                (line  11)
* font size:                             Pict structure.      (line  58)
* fraction:                              Categorical data analysis.
                                                              (line  54)
* freq:                                  Categorical data analysis.
                                                              (line  17)
* freq (SBS proc):                       Categorical data analysis.
                                                              (line  17)
* glm (SBS proc):                        Analysis of variance.
                                                              (line  18)
* graph:                                 Shapes.              (line  83)
* graphics:                              Invoking Dap.        (line  47)
* graphics <1>:                          Displaying the pictures.
                                                              (line  37)
* graphics <2>:                          Graphics output file.
                                                              (line  14)
* graphics <3>:                          Graphics output file.
                                                              (line  28)
* graphics <4>:                          Graphics output file.
                                                              (line  70)
* gray level:                            Pict structure.      (line  71)
* gray level <1>:                        Pict structure.      (line  74)
* group:                                 Grouping lines in a dataset.
                                                              (line  16)
* hash:                                  Shapes.              (line  50)
* header:                                Output files.        (line   9)
* header file:                           Reading files and datasets.
                                                              (line  12)
* header file <1>:                       Reading files and datasets.
                                                              (line  77)
* header lines:                          Input and output.    (line  48)
* histogram:                             Histogram.           (line  12)
* I-beam:                                Pict structure.      (line  26)
* independence:                          Categorical data analysis.
                                                              (line  47)
* infile:                                Reading files and datasets.
                                                              (line  18)
* infile <1>:                            Reading files and datasets.
                                                              (line  53)
* infile <2>:                            Reading files and datasets.
                                                              (line  56)
* infile <3>:                            Variables.           (line   7)
* initialize:                            Pict structure.      (line  93)
* input:                                 Variables.           (line  29)
* input <1>:                             Input and output.    (line   9)
* input <2>:                             Input and output.    (line  27)
* input <3>:                             Input and output.    (line  48)
* inset:                                 Reading files and datasets.
                                                              (line  18)
* inset <1>:                             Variables.           (line   7)
* insufficient memory:                   Reading files and datasets.
                                                              (line  90)
* int:                                   Variables and operations.
                                                              (line  17)
* interquartile range:                   One variable statistics.
                                                              (line 187)
* invalid data:                          Input and output.    (line  48)
* invert:                                Miscellaneous functions.
                                                              (line 101)
* invoking Dap:                          Invoking Dap.        (line   6)
* join:                                  Splitting and joining lines.
                                                              (line  33)
* keep 'lst' file:                       Invoking Dap.        (line  74)
* keep 'lst' file <1>:                   Invoking Dap.        (line  76)
* Kendall's Tau-b:                       Categorical data analysis.
                                                              (line  65)
* Kolmogorov:                            Nonparametric analyses.
                                                              (line  41)
* landscape:                             Displaying the pictures.
                                                              (line  37)
* landscape <1>:                         Graphics output file.
                                                              (line  14)
* landscape <2>:                         Graphics output file.
                                                              (line  28)
* least square means:                    Analysis of variance.
                                                              (line 117)
* least square means <1>:                Analysis of variance.
                                                              (line 144)
* line:                                  Elements.            (line  27)
* line graph:                            Scatter plot or line graph.
                                                              (line  19)
* line graph <1>:                        Pict structure.      (line  16)
* line segments:                         Pict structure.      (line  19)
* line width:                            Pict structure.      (line  62)
* line, darkness:                        Pict structure.      (line  71)
* linear regression:                     Linear regression.   (line  66)
* linear regression <1>:                 Regression plots.    (line  12)
* linear regression <2>:                 Linear regression examples.
                                                              (line   6)
* link:                                  Pict structure.      (line  93)
* local variable:                        Reading files and datasets.
                                                              (line  37)
* log file:                              Output files.        (line   9)
* logistic (SBS proc):                   Logistic regression. (line  15)
* logistic regression:                   Categorical data analysis.
                                                              (line 127)
* logistic regression <1>:               Logistic regression. (line  15)
* logistic regression <2>:               Regression plots.    (line  50)
* logistic regression <3>:               Logistic regression examples.
                                                              (line   6)
* logistic regression <4>:               Logistic regression reported a singular matrix.
                                                              (line   7)
* logit models:                          Categorical data analysis.
                                                              (line 127)
* logit models <1>:                      Categorical data analysis.
                                                              (line 199)
* logit models <2>:                      Statistics utilities.
                                                              (line   9)
* loglinear models:                      Categorical data analysis.
                                                              (line 127)
* loglinear models <1>:                  Categorical data analysis.
                                                              (line 199)
* loglinear models <2>:                  Statistics utilities.
                                                              (line   9)
* lower:                                 Transformations.     (line  10)
* LSD:                                   Analysis of variance.
                                                              (line 153)
* lsmeans:                               Analysis of variance.
                                                              (line 117)
* lsmeans <1>:                           Analysis of variance.
                                                              (line 144)
* lst file:                              Invoking Dap.        (line  46)
* lst file <1>:                          Invoking Dap.        (line  48)
* lst file <2>:                          Invoking Dap.        (line  73)
* lst file <3>:                          Output files.        (line   9)
* main:                                  The preprocessor.    (line  16)
* main <1>:                              Functions.           (line  58)
* Mann-Whitney-Wilcoxon:                 Nonparametric analyses.
                                                              (line  41)
* manual:                                Description and example.
                                                              (line 115)
* mark:                                  Positioning within a dataset.
                                                              (line   8)
* match:                                 Merging datasets.    (line   9)
* matrix:                                Miscellaneous functions.
                                                              (line 101)
* maximize:                              Miscellaneous functions.
                                                              (line  22)
* maximum:                               One variable statistics.
                                                              (line  30)
* maximum <1>:                           One variable statistics.
                                                              (line 151)
* mean:                                  One variable statistics.
                                                              (line  33)
* mean <1>:                              Plotting means.      (line   6)
* mean squares:                          Analysis of variance.
                                                              (line 109)
* means:                                 Trimming extreme values.
                                                              (line  32)
* means <1>:                             Plotting means.      (line  11)
* means (SBS proc):                      One variable statistics.
                                                              (line  17)
* measures of association:               Categorical data analysis.
                                                              (line  57)
* measures of association <1>:           Categorical data analysis.
                                                              (line  65)
* median:                                One variable statistics.
                                                              (line 154)
* memory allocation:                     Reading files and datasets.
                                                              (line  90)
* merge:                                 Variables.           (line  31)
* merge <1>:                             Merging datasets.    (line   9)
* minimize:                              Miscellaneous functions.
                                                              (line  22)
* minimum:                               One variable statistics.
                                                              (line  36)
* minimum <1>:                           One variable statistics.
                                                              (line 157)
* missing cells:                         Manage datasets.     (line  15)
* missing data:                          Input and output.    (line  35)
* model:                                 Analysis of variance.
                                                              (line  18)
* model <1>:                             Analysis of variance.
                                                              (line  28)
* move:                                  Transformations.     (line  10)
* multiple definition error:             Reading files and datasets.
                                                              (line  16)
* NaN:                                   Input and output.    (line  36)
* NaN <1>:                               One variable statistics.
                                                              (line 106)
* NaN <2>:                               Variables and operations.
                                                              (line  23)
* nested design:                         Analysis of variance.
                                                              (line  32)
* nested design <1>:                     Analysis of variance.
                                                              (line  34)
* new part:                              Partitioning a dataset.
                                                              (line  51)
* nland:                                 Displaying the pictures.
                                                              (line  12)
* nominal:                               Categorical data analysis.
                                                              (line  57)
* nonparametric:                         Nonparametric analyses.
                                                              (line  41)
* normal:                                Normal probability plot.
                                                              (line  11)
* normal <1>:                            Normal distribution. (line   6)
* normal probability plot:               Normal probability plot.
                                                              (line  11)
* npar1way (SBS proc):                   Nonparametric analyses.
                                                              (line  15)
* nport:                                 Histogram.           (line  12)
* nport <1>:                             Normal probability plot.
                                                              (line  11)
* nport <2>:                             Scatter plot or line graph.
                                                              (line  19)
* nport <3>:                             Plotting means.      (line  11)
* nport <4>:                             Displaying the pictures.
                                                              (line  12)
* NULL:                                  Variables.           (line  25)
* NULL <1>:                              Variables and operations.
                                                              (line  67)
* null string:                           Variables.           (line  24)
* null string <1>:                       Variables and operations.
                                                              (line  66)
* number of observations:                One variable statistics.
                                                              (line  39)
* number of observations <1>:            One variable statistics.
                                                              (line  95)
* number of observations <2>:            One variable statistics.
                                                              (line 160)
* odds ratio:                            Categorical data analysis.
                                                              (line  62)
* order, sort:                           Sorting a dataset.   (line  19)
* ordinal:                               Categorical data analysis.
                                                              (line  65)
* ordinal <1>:                           Categorical data analysis examples.
                                                              (line   6)
* orientation:                           Graphics output file.
                                                              (line  14)
* orientation <1>:                       Graphics output file.
                                                              (line  28)
* outliers:                              Trimming extreme values.
                                                              (line  31)
* output:                                Input and output.    (line 108)
* output dataset:                        Input and output.    (line  62)
* output, graphics:                      Displaying the pictures.
                                                              (line  37)
* output, graphics <1>:                  Graphics output file.
                                                              (line  14)
* output, graphics <2>:                  Graphics output file.
                                                              (line  28)
* output, graphics <3>:                  Graphics output file.
                                                              (line  70)
* outset:                                Variables.           (line  29)
* outset <1>:                            Input and output.    (line  62)
* page:                                  Graphics output file.
                                                              (line  45)
* paired:                                Categorical data analysis.
                                                              (line  74)
* parameters:                            Reading files and datasets.
                                                              (line  77)
* parameters <1>:                        Appendix I.          (line   7)
* partitioning:                          Partitioning a dataset.
                                                              (line  51)
* partitioning a dataset:                Datasets.            (line  15)
* partv:                                 Partitioning a dataset.
                                                              (line  15)
* partvars:                              Datasets.            (line  15)
* pattern:                               Pict structure.      (line  80)
* pattern <1>:                           Pict structure.      (line  85)
* patterns:                              Pict structure.      (line  45)
* pctiles:                               One variable statistics.
                                                              (line 214)
* percent:                               Categorical data analysis.
                                                              (line  77)
* percent, row:                          Categorical data analysis.
                                                              (line  80)
* percentage, column:                    Categorical data analysis.
                                                              (line  41)
* percentile points:                     One variable statistics.
                                                              (line 191)
* percentiles:                           One variable statistics.
                                                              (line 215)
* pict structure:                        Pict structure.      (line   6)
* pict, clear:                           Pict structure.      (line 111)
* pict, initialize:                      Pict structure.      (line  93)
* pict, link:                            Pict structure.      (line  93)
* picture:                               Pict structure.      (line  10)
* picture <1>:                           Graphics output file.
                                                              (line  14)
* picture <2>:                           Graphics output file.
                                                              (line  28)
* picture <3>:                           Graphics output file.
                                                              (line  53)
* plot:                                  Scatter plot or line graph.
                                                              (line  19)
* plot <1>:                              Plotting means.      (line   6)
* plot <2>:                              Regression plots.    (line  12)
* plot <3>:                              Regression plots.    (line  50)
* plot (SBS proc):                       Scatter plot or line graph.
                                                              (line  19)
* plotmeans:                             Plotting means.      (line  11)
* point:                                 Elements.            (line  22)
* pointer:                               Variables and operations.
                                                              (line  57)
* pointer <1>:                           Variables and operations.
                                                              (line  62)
* points:                                Pict structure.      (line  29)
* portrait:                              Displaying the pictures.
                                                              (line  37)
* portrait <1>:                          Graphics output file.
                                                              (line  14)
* portrait <2>:                          Graphics output file.
                                                              (line  28)
* position:                              Positioning within a dataset.
                                                              (line   8)
* preprocessor:                          Reading files and datasets.
                                                              (line   6)
* print:                                 Displaying a dataset.
                                                              (line  13)
* print <1>:                             Displaying a dataset.
                                                              (line  51)
* print (SBS proc):                      Displaying a dataset.
                                                              (line  13)
* ps file:                               Invoking Dap.        (line  47)
* ps file <1>:                           Invoking Dap.        (line  73)
* q-q plot:                              Normal probability plot.
                                                              (line  11)
* quartile:                              One variable statistics.
                                                              (line 181)
* quartile <1>:                          One variable statistics.
                                                              (line 184)
* quotes:                                Functions.           (line  32)
* radius:                                Pict structure.      (line  64)
* raise:                                 Transformations.     (line  10)
* random:                                Normal distribution. (line   6)
* random <1>:                            Uniform distribution.
                                                              (line   6)
* range:                                 One variable statistics.
                                                              (line  42)
* range <1>:                             One variable statistics.
                                                              (line 190)
* rank:                                  Grouping lines in a dataset.
                                                              (line  16)
* rank (SBS proc):                       Grouping lines in a dataset.
                                                              (line  16)
* read a line:                           Input and output.    (line  27)
* read a line <1>:                       Input and output.    (line  48)
* reading this manual:                   Description and example.
                                                              (line 115)
* rectangle:                             Shapes.              (line  28)
* rectangle <1>:                         Shapes.              (line  50)
* reg (SBS proc):                        Linear regression.   (line  18)
* regression, linear:                    Linear regression.   (line  65)
* regression, linear <1>:                Regression plots.    (line  12)
* regression, linear <2>:                Linear regression examples.
                                                              (line   6)
* regression, logistic:                  Logistic regression. (line  15)
* regression, logistic <1>:              Regression plots.    (line  50)
* regression, logistic <2>:              Logistic regression examples.
                                                              (line   6)
* remove:                                Manage datasets.     (line  15)
* rename:                                Manage datasets.     (line  15)
* rewind:                                Positioning within a dataset.
                                                              (line  16)
* rotate:                                Transformations.     (line  51)
* row percent:                           Categorical data analysis.
                                                              (line  80)
* running Dap:                           Invoking Dap.        (line   6)
* Satterthwaite:                         Analysis of variance.
                                                              (line 110)
* SBS syntax:                            Description and example.
                                                              (line 133)
* SBS syntax <1>:                        Appendix IV.         (line   6)
* scale:                                 Transformations.     (line  30)
* scatter plot:                          Scatter plot or line graph.
                                                              (line  19)
* scatter plot <1>:                      Pict structure.      (line  29)
* sd:                                    One variable statistics.
                                                              (line  46)
* sd <1>:                                One variable statistics.
                                                              (line  50)
* segments:                              Pict structure.      (line  19)
* sem:                                   One variable statistics.
                                                              (line  54)
* sem <1>:                               One variable statistics.
                                                              (line  58)
* semi-colon:                            Appendix III.        (line  10)
* settable parameters:                   Reading files and datasets.
                                                              (line  77)
* settable parameters <1>:               Appendix I.          (line   7)
* settable parameters <2>:               Appendix III.        (line  25)
* Shapiro-Wilk:                          Normal probability plot.
                                                              (line  11)
* shift:                                 Transformations.     (line  10)
* show:                                  Graphics output file.
                                                              (line  53)
* shrink:                                Transformations.     (line  30)
* signed rank:                           Nonparametric analyses.
                                                              (line  41)
* size:                                  Pict structure.      (line  64)
* size <1>:                              Transformations.     (line  30)
* size, font:                            Pict structure.      (line  58)
* skip lines:                            Input and output.    (line  48)
* solid areas, darkness:                 Pict structure.      (line  74)
* Somers' D:                             Categorical data analysis.
                                                              (line  65)
* sort:                                  Sorting a dataset.   (line  13)
* sort <1>:                              Sorting a dataset.   (line  25)
* sort (SBS proc):                       Sorting a dataset.   (line  13)
* split:                                 Splitting and joining lines.
                                                              (line   9)
* square:                                Shapes.              (line  28)
* squares:                               Pict structure.      (line  32)
* standard deviation:                    One variable statistics.
                                                              (line  46)
* standard deviation <1>:                One variable statistics.
                                                              (line  50)
* standard deviation <2>:                Plotting means.      (line   6)
* standard error:                        Plotting means.      (line   6)
* standard error of the mean:            One variable statistics.
                                                              (line  54)
* standard error of the mean <1>:        One variable statistics.
                                                              (line  58)
* step:                                  One variable statistics.
                                                              (line  63)
* stop:                                  Appendix III.        (line  51)
* strcmp:                                Functions.           (line  36)
* strcmp <1>:                            Loops and 'if's.     (line  63)
* strcpy:                                Functions.           (line  21)
* stretch:                               Transformations.     (line  30)
* string:                                Description and example.
                                                              (line 118)
* string <1>:                            Variables and operations.
                                                              (line  28)
* string values:                         Datasets.            (line  12)
* string, null:                          Variables and operations.
                                                              (line  66)
* strings, comparing:                    Functions.           (line  36)
* strings, comparing <1>:                Loops and 'if's.     (line  63)
* strings, copying:                      Functions.           (line  21)
* structure, pict:                       Pict structure.      (line   6)
* Student's t:                           One variable statistics.
                                                              (line  72)
* Student's t <1>:                       t distribution.      (line   6)
* subscripts:                            Output files.        (line  60)
* sum:                                   One variable statistics.
                                                              (line  66)
* superscripts:                          Output files.        (line  61)
* surveyselect (SBS proc):               Survey selection.    (line  12)
* swap:                                  Partitioning a dataset.
                                                              (line  39)
* syntax:                                Description and example.
                                                              (line  13)
* syntax <1>:                            Appendix III.        (line   7)
* t:                                     One variable statistics.
                                                              (line  72)
* t distribution:                        t distribution.      (line   6)
* t-test:                                One variable statistics.
                                                              (line  76)
* table:                                 Displaying a dataset.
                                                              (line  51)
* tables:                                Invoking Dap.        (line  46)
* tabulate (SBS proc):                   Displaying a dataset.
                                                              (line  51)
* terminate:                             Appendix III.        (line  51)
* text:                                  Text.                (line  11)
* thickness, lines:                      Pict structure.      (line  62)
* tick:                                  Axes.                (line  99)
* ticks:                                 Axes.                (line  13)
* ticks <1>:                             Axes.                (line  43)
* title:                                 Output files.        (line  51)
* title <1>:                             Axes.                (line  43)
* title (SBS statement):                 Output files.        (line  57)
* transform:                             Transformations.     (line  10)
* transform <1>:                         Transformations.     (line  30)
* transform <2>:                         Transformations.     (line  51)
* translate:                             Transformations.     (line  10)
* triangles:                             Pict structure.      (line  35)
* triangles <1>:                         Pict structure.      (line  38)
* trim:                                  Trimming extreme values.
                                                              (line  32)
* troubleshooting:                       Appendix III.        (line   6)
* Tukey:                                 Analysis of variance.
                                                              (line 153)
* turn:                                  Transformations.     (line  51)
* type:                                  Input and output.    (line  72)
* type, picture:                         Pict structure.      (line  10)
* uncertainty coefficient:               Categorical data analysis.
                                                              (line  57)
* undeclared:                            Variables.           (line  13)
* undeclared <1>:                        Variables and operations.
                                                              (line   8)
* uniform distribution:                  Uniform distribution.
                                                              (line   6)
* univariate (SBS proc):                 One variable statistics.
                                                              (line 138)
* unknown variable:                      Variables.           (line  13)
* unknown variable <1>:                  Variables and operations.
                                                              (line   8)
* variable:                              Variables.           (line  13)
* variable <1>:                          Variables and operations.
                                                              (line   8)
* variable lists:                        Variables.           (line  22)
* variable names:                        Variables.           (line  14)
* variables as arguments:                Variables.           (line  22)
* variance:                              One variable statistics.
                                                              (line  80)
* variance <1>:                          One variable statistics.
                                                              (line  84)
* variance <2>:                          One variable statistics.
                                                              (line  88)
* variance <3>:                          One variable statistics.
                                                              (line  92)
* viewer:                                Invoking Dap.        (line  96)
* weight:                                One variable statistics.
                                                              (line  69)
* weight <1>:                            One variable statistics.
                                                              (line  98)
* weight <2>:                            One variable statistics.
                                                              (line 196)
* width, lines:                          Pict structure.      (line  62)
* Wilcoxon:                              Nonparametric analyses.
                                                              (line  41)
* words:                                 Text.                (line  11)



Tag Table:
Node: Top212
Node: Overview and invocation957
Node: Description and example1158
Node: Invoking Dap8752
Node: Program structure15037
Node: Reading files and datasets15388
Node: Variables20066
Node: Output files22041
Node: The preprocessor24313
Node: Datasets25605
Node: Input and output27685
Ref: Input and output-Footnote-131752
Node: Positioning within a dataset31840
Node: Partitioning a dataset32305
Node: Modifying output35706
Node: Manage datasets36176
Node: Managing and displaying data39379
Node: Sorting a dataset39855
Node: Merging datasets42331
Node: Displaying a dataset45031
Node: Splitting and joining lines49248
Node: Grouping lines in a dataset51998
Node: Trimming extreme values56012
Node: Statistics functions57228
Node: Survey selection57741
Node: One variable statistics58496
Node: Correlations65108
Node: Analysis of variance66695
Node: Categorical data analysis75197
Node: Linear regression86294
Node: Logistic regression89567
Node: Nonparametric analyses92674
Node: Statistics utilities94288
Node: Graphics functions96672
Node: Histogram97046
Node: Normal probability plot100406
Node: Scatter plot or line graph101693
Node: Plotting means105701
Node: Regression plots108966
Node: Displaying the pictures113342
Node: Utilities114482
Node: Chi-squared distribution114931
Node: F distribution115890
Node: Normal distribution116922
Node: t distribution118001
Node: Uniform distribution118928
Node: Miscellaneous functions119381
Node: Picture functions122692
Node: Pict structure124139
Node: Axes127130
Node: Elements132044
Node: Shapes132883
Node: Text136339
Node: Transformations137645
Node: Graphics output file139441
Node: Picture datasets141244
Node: Examples143793
Node: Analysis of variance examples144257
Node: Linear regression examples153775
Node: Categorical data analysis examples154882
Node: Logistic regression examples159786
Node: Standard graphical output160431
Node: Custom graphics161493
Node: Appendix I164518
Node: Appendix II168351
Node: Variables and operations168831
Node: Functions173200
Node: Loops and 'if's176118
Node: Appendix III179439
Node: Appendix IV182971
Node: FAQ186735
Node: I cannot find a function187014
Node: I want to split a dataset187438
Node: Logistic regression reported a singular matrix188423
Node: How do I add a line to a plot?188924
Node: Index190775

End Tag Table
