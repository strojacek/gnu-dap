\input texinfo @c -*- texinfo -*-
@c %**start of header
@setfilename dap
@settitle Dap
@defindex in
@c %**end of header

@ifinfo
@definfoenclose strong,,
@end ifinfo

@dircategory Dap statistics and graphics package
@direntry
* Dap: (dap).                The Dap statistics package
@end direntry

@setchapternewpage odd

@titlepage
@title Dap 3.5
@subtitle Data analysis & presentation

@author Susan Bassein, Ph.D.

@c Include the Distribution inside the titlepage so
@c that headings are turned off.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001, 2002, 2003, 2004,2014
Free Software Foundation, Inc.

Published by the Free Software Foundation @*
59 Temple Place Suite 330 @*
Boston, MA 02111-1307 @*
USA @*

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Free Software Foundation.
@end titlepage

@node Top
@ifinfo
@top Dap
This document describes version 3.5 of the Dap statistics and graphics package.
Dap is a GNU program.
@end ifinfo

@menu
* Overview and invocation::
* Program structure:: C-style dap programs only
* Datasets:: I/O and management.  
* Managing and displaying data:: Processing datasets.  
* Statistics functions:: Data analysis.  
* Graphics functions:: Presentation.  
* Utilities:: Probability and miscellaneous functions.  
* Picture functions:: Low level operations on pictures.
* Examples:: Sample programs. 
* Appendix I:: Settable parameters
* Appendix II:: Essentials of C syntax
* Appendix III:: Troubleshooting
* Appendix IV:: SBS
* FAQ:: Frequently asked questions
* Index::

@end menu

@node Overview and invocation,Program structure,Top,Top
@chapter Overview and invocation

@menu
* Description and example::
* Invoking Dap::
@end menu

@node Description and example,Invoking Dap,,Overview and invocation
@section Description, an example, and reading this manual

Dap is a small statistics and graphics package based on C.
As of Version 3.0, dap can read SBS programs to perform basic statistical
analyses, thus freeing the user from learning and using C syntax
for straightforward tasks,
while retaining access to the C-style graphics and statistics
features provided by the original implementation (@pxref{Appendix IV}).
Dap provides core methods of data management,
analysis, and graphics commonly used in statistical
consulting practice.
Anyone familiar with the basic syntax of C
@inindex C
@inindex syntax
programs can learn to use the C-style features of
dap quickly and easily from this manual and the examples it provides;
advanced features of C are not necessary,
although they are available.
(@ref{Appendix II} provides a brief description of the C syntax needed to use
those features of dap dependent on it.)
Because dap processes files one line at a time, rather than reading entire files
into memory, it can be used on data sets that have very large numbers of lines
and/or large numbers of variables.

Dap consists of: an interactive front end that
controls editing, compiling, execution, and viewing;
an optional SBS-to-C-style-dap translator that can convert an SBS program into
a C-style dap program;
a preprocessor that facilitates data input and output by
converting a C-style dap program into an ordinary C program; and a library of
statistics functions and graphics functions.
Typical use of dap involves the following steps:

@enumerate
@item
Obtain, or use a text editor to create, one or more data files in acceptable
formats.
@item
Invoke (i.e., run) @samp{dap} to create or view an SBS or C-style
dap program that will read and process the data file(s) to
produce tables and/or graphics.
(See @ref{Invoking Dap} to find out how to run dap.
If you want to use the C-style features of dap and
are unfamiliar with C, read @ref{Appendix II} before creating
your C-style dap program.)
@item
Tell dap to compile (i.e., translate into machine usable form) your SBS
or C-style dap program and execute (i.e., run) your program.
@item
If the previous step was successful, view your tables and/or
graphics; otherwise, if there are errors in your program, you will have to edit your program
further and repeat Step 3.
@end enumerate

The following program examples illustrate the basic structure
of simple SBS and C-style dap programs and how functions in the library are used in dap.

@example
/* A SIMPLE SBS PROGRAM */
data;                  /* Begin data step */
 infile "two" delimiter="\t" firstobs=2;
                       /* The infile statement: identifies "two" as
                        * the file to read from, specifies that
                        * the delimiter is a tab, i.e. the numbers
                        * in each line in "two" are separated by a
                        * single tab character, and directs the
                        * program to skip one header line and start
                        * data input on the second line of the file "two".
                        */
 input x y;            /* The first number on each line of "two"
                        * will be held in x and the second number
                        * will be held in y
                        */
proc plot;             /* Run the plot procedure to display a scatter-plot... */
 plot y * x / box;     /* ...using y for the vertical axis and x for the
                        * horizontal and enclosing the plot in a box
                        */

@end example

@example
/* A SIMPLE C-STYLE DAP PROGRAM */
#include <dap.h>       /* REQUIRED: includes prototypes of
                        * statistics and graphics functions
                        */

void main()            /* REQUIRED: main runs everything */
@{
/* This part of the program reads in data from an ordinary file
 * and writes it out to a dataset, which is the kind of file
 * on which the library functions can operate to perform
 * exploratory data analysis, graphical interpretation, and
 * statistical analyses.
 */
infile("two", "\t")    /* The infile statement: identifies "two" as
                        * the file to read from and specifies that
                        * the delimiter is a tab, i.e. the numbers
                        * in each line in "two" are separated by a
                        * single tab character
                        */
  @{                    /* Beginning of infile statement body */
  double x, y;         /* specify that x and y are variables that
                        * hold @dfn{double-precision floating point}
                        * numbers, i.e., numbers that are not
                        * necessarily whole numbers
                        */
  input("x y");        /* The first number on each line of "two"
                        * will be held in x and the second number
                        * will be held in y
                        */
  outset("xyset", ""); /* Create a dataset "xyset" and write all
                        * the variables to it
                        */
  skip(1);             /* The data file contains 1 header line;
                        * skip it
                        */
  while (step())       /* Read in the file, one line at a time */
    output();          /* and write it to the dataset "xyset" */
  @}                    /* end of infile statement body */

/* This line runs the plot function to get a scatter-plot, then
 * displays the result graphically using the nport function; the
 * various options used are described in the section for the plot
 * and nport functions.  
 */
nport(plot("xyset", "x y", "", "==", NULL, NULL, 1), 1, 1);
@}
@end example

For each C-style dap function, this manual
@inindex manual
@inindex reading this manual
gives:

@enumerate
@item
@strong{SPECIFICATION}: This is an abstract template for the function that indicates the
types of the parameters (string,
@inindex string
@inindex array of char
@inindex char, array
i.e., array of char, double, array of double, int,
or array of int), and the return value, if any; @strong{bold face} indicates
literal text, @var{italics} indicates parameters for which you choose your own
names. The corresponding SBS template, if available, is also provided.

@item
@strong{Description}: A description of the functionality and use of the function.
If there is a corresponding SBS proc, notes on its usage follow.

@item
@strong{Code fragment(s)}: These are one or more examples of calling the function, with made-up values
for the parameters; for complete examples of use, see the final chapter
(@pxref{Examples}) or consult the index.  
@end enumerate

@inindex SBS syntax
For the SBS templates, the following should be noted.
Elements within square brackets @samp{[ ]} are optional and
some, although permitted, may have no effect.
Elements within braces @samp{@{ @}}, separated by a vertical bar @samp{|} are
alternatives.
Keywords may be in upper or lower case.
Single and double quotes must be used as in C, i.e., use double quotes
for strings (whether or not they are one character long) and
use single quotes only for character values.
Not all statements listed below the @samp{data} or @samp{proc}
statements are required and multiple statements of some types may be allowed.

@node Invoking Dap,,Description and example,Overview and invocation
@section Invoking Dap
@inindex running Dap
@inindex invoking Dap

To run dap, you must type a command which looks like one of the following
(in which the bracketed items are optional and are described below):

@noindent
@strong{SPECIFICATION}

@display
@strong{dap [-k] [-d] @var{file1}.c [ @var{file2}.c ... ] [-a @var{arg1} ...]}
@strong{dap [--keep] [--debug] @var{file1}.c [ @var{file2}.c ... ] [--args @var{arg1} ...]}
@strong{dap [-k] [-d] @var{file1}.sbs [ @var{file2}.c ... ]}
@strong{dap [--keep] [--debug] @var{file1}.sbs [ @var{file2}.c ... ]}
@end display

@noindent
@strong{Description}

The following description is based on using the GNU editor Emacs to
interact with dap.
If you don't use Emacs, you can still use dap, but in the commands
specified above, use @samp{daprun} in place of @samp{dap}; in that case,
you will have to open your editor and/or file viewer to edit your program
and view your text output.

When you type the command to run dap:

@enumerate
@item
The editor Emacs (type the command @file{info emacs}
for the manual) is opened for the named SBS or C-style dap file(s).
Each file is created, but is empty, if it doesn't exist.
When you are finished editing your file(s), save it (them), but do not
exit unless you are finished running dap.
@item
Emacs will have a buffer called @samp{Async Shell Command}; select that buffer
and you will be
asked whether to compile the named SBS or C file(s) and run the resulting
executable file (if the compilation is successful).
If you answer @samp{y}, then dap
runs the preprocessor on the named SBS or C file(s) to produce
@var{file1}.dap.c [ @var{file2}.dap.c ... ].
If you answer @samp{q}, then dap stops running (and you can either leave Emacs
running for some other purpose or exit it).

@item
If the preprocessing is successful, 
then dap runs a C compiler on the preprocessed file(s), linking
library functions as necessary, to produce @var{file1}.dap.
@item
If the compilation is successful, then dap removes the @file{dap.c} file(s)
(unless the @samp{-d} or @samp{--debug} option is present) and
runs the executable @var{file1}.dap, passing the arguments
@var{arg1}, ..., if any, and produces @var{file1}.lst file for tables
@inindex tables
@inindex lst file
and @var{file1}.ps for graphics, as requested.
@inindex graphics
@inindex ps file
There are Emacs buffers for
the @file{lst} and @file{log} files, but you must use
@samp{Revert buffer}
@inindex lst file
in the @samp{File} menu to see the most recent results.
A viewer will be opened for the @file{ps} file,
if it exists.

@item
Each time a dataset or datafile is read through to the end
during execution, the number
of lines read from the dataset or datafile is displayed in your
@samp{Async Shell Command} buffer and written to the @file{log} file.
If @samp{dap_outreport} (@pxref{Appendix I}) is positive
(default: 100000), then dap reports, in your @samp{Async Shell Command} buffer,
each time that an additional @samp{dap_outreport}
lines have been written to a dataset;
if your program is writing to a dataset inside an infinite loop,
this helps you abort the program to avoid filling up your disk
(by holding down the @samp{Ctrl} key and pressing the @samp{C} key @emph{twice}).
@inindex abort

@item
If there were errors or warnings, they will be written
to the @file{err} and you will see them displayed in your
@samp{Async Shell Command} buffer.

@item
At this point, you can edit (and save!) your SBS or C-style dap files again or quit.
@end enumerate

If the @samp{-a} or @samp{--args}
@inindex arguments
@inindex command line arguments
option is present (C-style dap programs only),
then all the arguments that follow it on the command
are passed to the @samp{main} in your program as @samp{argv}.
In all cases, the @file{lst} and @file{ps} files
@inindex lst file
@inindex ps file
are removed before the
first execution, but if the @samp{-k} or @samp{--keep} option is present, then the @file{lst}
file is kept
@inindex keep @file{lst} file
and appended to from one cycle to the next.  
(Keeping the @file{lst} file from one cycle to the next can be useful for
exploratory data analysis,
@inindex exploratory data analysis
@inindex keep @file{lst} file
such as model building for linear regression
or loglinear models, in which it is useful to have a record of a
succession of analyses without running the cumulative set of analyses
repeatedly.)

@strong{NOTE:} If your system uses @samp{locale}s, then you must set
your environment variable @samp{LC_COLLATE} to @samp{C} in order to
obtain correct sorting.

The editor
@inindex editor
invoked is /usr/bin/emacs unless the environment variable @samp{DAPEDITOR}
specifies a different location for Emacs.
Emacs is invoked with no options unless the environment variable
@samp{DAPEDOPTS} is set to a single string of all the options desired.  
The compiler
@inindex compiler
used is /usr/bin/gcc unless the environment variable @samp{DAPCOMPILER}
is set to a different compiler.
The compiler is invoked with no options unless the environment variable
@samp{DAPCOMPOPTS} is set to a single string of all the options desired.  
The @file{lst} file is displayed in its entirety in its buffer
unless the environment variable @samp{DAPPAGER} is set to a pager
(such as @file{more}).
That pager is invoked with no options unless the environment variable
@samp{DAPPAGEOPTS} is set to a single string of all the options desired.  
The @file{ps} file is viewed
@inindex viewer
with /usr/bin/X11/gv unless the environment variable @samp{DAPVIEWER}
is set to a different graphics viewer.
The viewer is invoked with no options unless the environment variable
@samp{DAPVIEWOPTS} is set to a single string of all the options desired.  

The executable @var{file1}.dap can be run, or debugged,
@inindex debugging
on its own.
If the @samp{-a} or @samp{--args}
@inindex arguments
@inindex command line arguments
option was used when the source files were processed, then arguments
@inindex arguments
(without the @samp{-a} or @samp{--args}) are used on the command line.
If you want to use @samp{gdb}
to debug @var{file1}.dap, include @samp{-g} as one
of your compiler options and use the @samp{-d} or @samp{--debug} option when you run
dap so that the @file{.dap.c} files will not be removed.

@noindent
@strong{Code fragment(s)}

@emph{Run @file{dap} on the file @file{tweedle.c}:}
@example
dap tweedle.c
@end example

@emph{Run @file{dap} on the file @file{tweedle.sbs}:}
@example
dap tweedle.sbs
@end example

@emph{Run @file{dap} on the files @file{tweedle.c} and @file{dee.c}:}
@example
dap tweedle.c dee.c
@end example

@emph{Run @file{dap} on the files @file{tweedle.sbs} and @file{dee.c}:}
@example
dap tweedle.sbs dee.c
@end example

@emph{Run @file{dap} on @file{tweedle.c}; append to @file{tweedle.lst} in each cycle:}
@example
dap -k tweedle.c
dap --keep tweedle.c
@end example

@emph{Run @file{dap} on @file{tweedle.c}; pass arguments @samp{17}
and @samp{dum} to @samp{main} in @file{tweedle.c}:}
@example
dap tweedle.c -a 17 dum
dap tweedle.c --args 17 dum
@end example

@emph{Run @file{dap} on @file{tweedle.c}; do not remove @file{tweedle.dap.c} for debugging:}
@example
dap -d tweedle.c
dap --debug tweedle.c
@end example

@node Program structure,Datasets,Overview and invocation,Top
@chapter Program structure

This chapter concerns C-style dap programs only.

@menu
* Reading files and datasets:: inset and infile and roc import.  
* Variables::
* Output files:: @file{err}, @file{log}, @file{lst}, and @file{ps}
* The preprocessor:: dappp
@end menu

@node Reading files and datasets,Variables,,Program structure
@section Reading files and datasets

@inindex preprocessor
@inindex dappp
This section and the next apply only to C-style dap programs.
C-style dap programs are C programs with two additional statement types
and additional library functions to perform statistical and graphical tasks.
All C-style dap programs must contain a line

@example
#include <dap.h>
@end example
@noindent
to include the dap header file
@inindex header file
@inindex dap.h
before the function @samp{main} and any variable declarations, except that
if the program resides in more than one @file{C} file, only one of those
files must include @file{dap.h} while the others must include @file{dap1.h} instead.
@inindex dap1.h
(This is to avoid multiple definitions
@inindex multiple definition error
of dap parameters.)

The two additional statement types are @samp{infile} and @samp{inset}
@inindex infile
@inindex inset
statements, which
are used to set up input from files and datasets and which
have the following syntaxes:

@noindent
@strong{SPECIFICATION}

@display
@strong{infile(@var{datafile}, @var{delimiter}) @{ @dots{} @}}
@var{datafile}, @var{delimiter:} string

@strong{inset(@var{dataset}) @{ @dots{} @}}
@var{dataset:} string
@end display

@noindent
@strong{Description}

The body of @samp{infile} and @samp{inset} statements
may contain local variable declarations, an @samp{outset}
statement, and statements to process the input file or dataset.
In addition, the body an @samp{infile} statement may contain an
@samp{input} statement.

The local variable declarations
@inindex local variable
@inindex declaration
in the body of @samp{infile} and @samp{inset} statements
are restricted to the following types:

@example
double name;
double name[number];
double name[string];
int name;
int name[number];
int name[string];
char name[number];
char name[string];
@end example

When the dimension
@inindex dimension
of the array
@inindex array
is given as a string, that string must
appear in a @samp{#define} somewhere in the file before the declaration.

A program can generate data without reading from
a file.  In that case, an @samp{infile} statement
@inindex infile
is still required, but both
arguments can be given as @samp{NULL}.  

The delimiter
@inindex delimiter
argument to an @samp{infile}
@inindex infile
statement can be in one of two forms, one for
delimited fields and the other for fixed-width
@inindex fixed-width
fields.
If the file to be read is simply delimited text, the
the delimiter argument is a string (not a character) consisting
of the single delimiter character.  If the file has fixed-width fields, then
the delimiter argument is an alternating sequence of any non-numerical
character and numbers that specify the field widths, in order and
without spaces (unless the non-numerical character is a space).  For
example:

@example
infile("data", "x6x5x8")
or for sbs
PROC IMPORT  out = data datafile =  "Pres2007Clustered.csv"  dbms  = csv //support tab and dlm
delimiter = ',' replace ;  //support getnames=yes/no;
run ;
@end example
@noindent
specifies three data fields of widths 6, 5, and 8, respectively.

It is inappropriate to call a dap statistics or graphics function from
within the body of an @samp{infile} or @samp{inset} statement; results from such a
call are unpredictable.

The header file @file{dap.h} defines parameters
@inindex header file
@inindex dap.h
@inindex execution
@inindex parameters
@inindex constants
@inindex settable parameters
that control the execution of dap.  For example, @samp{dap_maxvar} is the maximum
number of variables allowed in any dataset.
To change any of these parameters, use a preprocessor @samp{#define} line
in your program @strong{before} the line that includes @samp{dap.h}.
For example,

@example
#define DAP_MAXVAR 512
#include <dap.h>
@end example
@noindent
will set the maximum number of variables to 512 instead of the default 256.
Note that such a @samp{#define} line does @emph{not} end with a semi-colon.

It is not necessary to use a @samp{#define} such as the one above
if you do not wish to change the values of the parameters from their defaults.
However, some dap functions have limitations
@inindex memory allocation
@inindex insufficient memory
on how many values
they can process at one time and if you have a dataset that is particularly large,
then you may receive a memory allocation error message.
That message will usually contain a suggestion of which parameter
may need changing.  The parameters available for modification are listed
in Appendix I (@pxref{Appendix I}).

@noindent
@strong{Code fragment(s)}

@emph{Read space-delimited data file @file{tweedledee} with
values for @samp{name}, @samp{wages}, and @samp{tips} on each line and
write those values to dataset @file{tweedledee}:}
@example
infile("tweedledee", " ")
  @{
    char name[21];
    double wages, tips;
    input("name wages tips");
    outset("tweedledee", "");
    while (step())
      output();
  @}
@end example

@emph{Read from dataset @file{tweedledee}, compute @samp{income}
as the sum of @samp{wages} and @samp{tips},
and write to dataset @file{tweedledum}:}
@example
inset("tweedledee")
  @{
    double wages, tips, income;
    outset("tweedledum", "");
    while (step())
      @{
        income = wages + tips;
        output();
      @}
  @}
@end example

@node Variables,Output files,Reading files and datasets,Program structure
@section Variables

This section applies only to C-style dap programs.
The variables declared in the body of an @samp{infile}
@inindex infile
or @samp{inset}
@inindex inset
statement
are available for reading from the specified file or dataset and for
writing to the specified dataset.  It is not necessary to
declare
@inindex declaration
all the variables in an input or output dataset; only those variables
that are used explicitly in a statement in the body of the @samp{infile} or @samp{inset}
statement
(i.e., not in a quoted string as an argument to
a function such as @samp{input}, @samp{outset}, or @samp{dap_list}),
must be declared.
@inindex unknown variable
@inindex undeclared
@inindex variable
@inindex declaration
Avoid using variable (or function) names
@inindex variable names
that begin with
@samp{dap_} or @samp{pict_} or end with @samp{dap_}.
WARNING: Within an @samp{inset} statement, if you declare and set the value
of a variable that is already in the dataset
referenced by the @samp{inset} statement, values that your program gives to
that variable will be overwritten on each call to @samp{step}.
@inindex bug

Data management, statistics, graphics, and other C-style dap functions take lists of variables
as arguments.  Such lists must always be given as strings
@inindex variables as arguments
@inindex variable lists
of variable names (sometimes with other specifications included), separated by
spaces (not commas).
@inindex commas, not
Generally, the null string ("", not @samp{NULL})
@inindex null string
is a shorthand
for a list of all the variables in the dataset and @samp{NULL}
@inindex NULL
is a shorthand
for none of the variables in the dataset.

Arrays
@inindex array
of int or double may be referenced, by the array name with no brackets or indices,
in calls to @samp{input} and
@inindex input
@samp{outset}.
@inindex outset
Individual array elements, with their bracketed indices,
may also be referenced in calls to those same functions, but not in calls to
@samp{dataset}
@inindex dataset
or @samp{merge},
@inindex merge
for which arrays of int or double must be referenced by the array name,
with no brackets or indices.
For all other C-style dap functions, each element of an array of
int or double that is to be used must appear with its bracketed index.  

@node Output files,The preprocessor,Variables,Program structure
@section Output: the @file{err}, @file{log}, @file{lst}, and @file{ps} files

The user's program can write directly to the @file{lst} and @file{log} files using
stream functions (@samp{putc}, @samp{fputs}, @samp{fprintf}, etc.)
on @samp{dap_lst} and @samp{dap_log}, respectively.
The following function may be called to display
a section header in the @file{lst} file:
@inindex dap_head
@inindex header
@inindex lst file
@inindex log file

@noindent
@strong{SPECIFICATION}

@display
@strong{dap_head(@var{partv}, @var{npartv})}
@var{partv:} array of int
@var{npartv:} int
@end display

@noindent
@strong{Description}

If @var{partv} is not @samp{NULL}, the header includes
the values of the variables defining a part of the file
or dataset (@pxref{Partitioning a dataset}).
NOTE: @samp{dap_head} makes a system call to @samp{time}
and calls the GNU library function @samp{ctime}; consequently,
user-defined functions with those names will interfere with
the date displayed by @samp{dap_head}.

@noindent
@strong{Code fragment(s)}

@emph{Write header, with current title, if any, to @file{lst} file:}
@example
while (step())
  @{
    ...
    dap_head(NULL, 0);
    ...
  @}
@end example

@emph{With input dataset sorted by
the variables @samp{state}, @samp{county}, and @samp{city},
write header, with current title, if any, and with current values of
@samp{state}, @samp{county}, and @samp{city},
to @file{lst} file:}
@example
int fooparts[3];
...
dap_list("state county city", fooparts, 3);
while (step())
  @{
    ...
    dap_head(fooparts, 3);
    ...
  @}
@end example

A title may be specified as part of the section head or as caption
in graphical output by calling:

@inindex title
@inindex caption

@noindent
@strong{SPECIFICATION}
@display
@strong{title(@var{the-title})}
@var{thetitle:} string
@end display

@display
title "@var{the-title}";
@end display

@inindex title (SBS statement)

@noindent
@strong{Description}

The string @var{the-title} may contain newline ('\n') characters for multi-line titles.
For graphical output captions, subscripts
@inindex subscripts
are specified by enclosing them
in vertical bars (@samp{|}) and superscripts
@inindex superscripts
are specified by enclosing them in
carets (@samp{^}).
If a title has been specified by @samp{title},
then a graphics function that produces a separate page for each part of a
partitioned dataset will include in the caption the value(s) of the variable(s)
defining the partition.

@noindent
@strong{Code fragment(s)}

@emph{Set title for @samp{dap_head}:}
@example
title("Analysis of variance\nfor crop yields");
title("CFU per cm^2^ of surface area");
@end example

@node The preprocessor,,Output files,Program structure
@section The preprocessor: dappp

The preprocessor, which is named dappp, reads @var{file}.c,
performs the following four actions to create @var{file}.dap.c:  

@enumerate
@item
Process simple @samp{#defines} of the form:
@inindex #define
@inindex define

@example
#define @var{string} @var{n}
@end example

in which @var{string} starts with a letter or with @samp{_} and
@var{n} is a positive integer.  

@item
Replace @samp{main} with @samp{dap_main}
@inindex dap_main
@inindex main
so that the @samp{main} internal to dap can
set up variables and the output files before calling @samp{dap_main}.

@item
Append a semicolon to each @samp{infile} or @samp{inset} statement header to prepare
it for the C compiler.  

@item
Append calls to @samp{dap_vd}, @samp{dap_dl}, @samp{dap_il}, and @samp{dap_sl}
@inindex dap_vd
@inindex dap_dl
@inindex dap_il
@inindex dap_sl
after declarations in the body of @samp{infile} and @samp{inset} statements.  

@end enumerate

The @samp{dap_vd}
@inindex dap_vd
function tells the internal dap routines
the names and types of variables so that datasets can be processed
appropriately.  The @samp{dap_dl}, @samp{dap_il}, and @samp{dap_sl}
@inindex dap_dl
@inindex dap_il
@inindex dap_sl
functions create links
between the variables in the user's program and the internal dap storage
to allow input and output.
These functions are appended to the last line of the user's declarations
so that line numbers in C compiler messages for @var{file}.dap.c correspond
exactly to line numbers in @var{file}.c.  

@node Datasets,Managing and displaying data,Program structure,Top
@chapter Datasets

Datasets
@inindex dataset
are data files with an additional first line that
specifies the names and types of the variables whose values follow.
The only other differences between datasets and data files are that
(1) integers and double precision floating point numbers are encoded
as text in a way that loses no precision and which allows sorting
to be performed in the usual alphanumeric order and (2) the delimiter
between fields on a line is always @samp{|}.  (A consequence of this
is that string values
@inindex string values
@inindex delimiter
cannot contain @samp{|}.)

@inindex partitioning a dataset
@inindex dataset, partitioning
@inindex partvars
Most C-style dap data management, statistics, and graphics functions
have an argument, called @var{partvars} in the specifications,
that allows parts of a dataset to be processed separately.
(SBS programs use a @samp{by} statement.)
To do that, first sort the dataset by the values of an
ordered list of variables: each part is defined as a set of lines
for which the values of all of those variables are constant.
Then the same variables in the same order must be named in the @var{partvars} argument 
of the function that is subsequently used to process the sorted dataset. 
If no partitioning is desired, then @var{partvars} should be the null string ("").

Dap allows datasets
@inindex dataset in memory
@inindex dataset, small
@inindex dataset on disk
that are not too large to be stored in memory instead of on disk in order
to speed processing.
To specify that a dataset is to be stored in memory,
precede the name of the dataset with a @samp{<}
in the call to @samp{outset} that creates it and in calls to functions that read it.
Note that a dataset that is stored in memory will not be retained after the
current dap session.

Only the last section in this chapter, @samp{Manage datasets}, has information
relevant to SBS programs.
For input for SBS programs, see @xref{Appendix IV}.

@menu
* Input and output:: input, step, skip, outset, output.  
* Positioning within a dataset:: dap_mark, dap_rewind.  
* Partitioning a dataset:: dap_list, dap_newpart, dap_swap.  
* Modifying output:: dap_save, dap_rest.  
* Manage datasets:: dataset.  
@end menu

@node Input and output,Positioning within a dataset,,Datasets
@section Input and output

@noindent
@strong{SPECIFICATION}
@display
@strong{input(@var{variable-list})}
@var{variable-list:} string
@end display
@inindex input

@noindent
@strong{Description}

The string @var{variable-list}
is a space-separated list of the names of the variables,
in order, on each line of the data file to be read;
@var{variable-list}
may contain the names of arrays or individual array elements.
Do not call @samp{input} for a dataset.

@noindent
@strong{Code fragment(s)}

@emph{Specify that (the beginning of) each line of the
input data file contains two fields whose values are to
be read into the variables @samp{fert} and @samp{yield},
in order:}
@example
input("fert yield");
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{step()}
@var{Returns:} int
@end display
@inindex read a line
@inindex input

@noindent
@strong{Description}

Attempts to read one line of the file or dataset specified by @samp{infile}
or @samp{inset}, respectively.
Returns 1 if a line was read, 0 if EOF
@inindex EOF
@inindex end of file
was reached before any characters
were read; in this latter case, all input variables retain their
values from the previous line.
The program exits with an error message if
@samp{step} is called after an EOF was reached.
Missing integer
@inindex missing data
data is read in as 0.
Data of type double that is missing or is @samp{.} is set to
NaN@footnote{"Not a Number": see the function @samp{finite}
in the GNU/Linux Programmer's Manual.}.
@inindex NaN

@noindent
@strong{Code fragment(s)}

@emph{Read all the lines of the current input dataset or data
file and write them to the current output dataset:}
@example
while (step())
  output();
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{skip(@var{nlines})}
@var{nlines:} int
@end display
@inindex read a line
@inindex skip lines
@inindex input
@inindex invalid data
@inindex header lines

@noindent
@strong{Description}

Skips @var{nlines} lines of the input data file.
This is useful for skipping header lines in a data file.

@noindent
@strong{Code fragment(s)}

@emph{Skip 3 lines of the input data file:}
@example
skip(3);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{outset(@var{dataset}, @var{variable-list})}
@var{dataset}, @var{variable-list:} string
@end display
@inindex dataset, output
@inindex output dataset
@inindex outset

@noindent
@strong{Description}

The string @var{dataset} is the name of the data set to be written.
The string @var{variable-list}
is either a space-separated list of the names of the variables
to be included in the output data set,
a @samp{!} followed by a space-separated list of the names of the variables
to be excluded from the output data set,
or a null string (not @samp{NULL}), which
specifies that all variables are to be included in the output data set.
The output data set always includes a variable named @samp{_type_}, which
is a string of length 9 (includes terminating null) and
@inindex _type_
@inindex type
which indicates the type of the observation.
The string @var{variable-list} may contain the names of arrays, without bracketed indices,
or individual array elements, but in either case the entire array is included
in or excluded from the output dataset.

If the dataset
@inindex dataset in memory
@inindex dataset, small
@inindex dataset on disk
is small and need not be retained after the current dap session,
then @var{dataset} may begin with a @samp{<} to specify that the dataset is
to be stored in memory rather than on disk; this will speed processing.
The string @var{dataset} must then begin with a @samp{<} in calls to functions that
read it.
If @var{dataset} does not begin with a @samp{<}, then
@samp{outset} creates the data set in the subdirectory
@samp{dap_sets}
@inindex dataset
@inindex dap_sets
of the current directory.  If
@samp{dap_sets} does not exist, @samp{outset} creates it.
A call to @samp{outset} must be preceded by an
@samp{infile} or @samp{inset} statement;
if no input file or dataset is desired, you may use
@samp{NULL} as the file specified by @samp{infile} and @samp{NULL} as the delimiter string.

@noindent
@strong{Code fragment(s)}

@emph{Name the output dataset @samp{tweedledee} and
specify that it will contain the values of the variables
@samp{alice} and @samp{caterpillar} only:}
@example
outset("tweedledee", "alice caterpillar");
@end example

@emph{Name the output dataset @samp{tweedledum} and
specify that it will contain the values of all the variables
that are either in the input dataset or are declared in
the current @samp{infile} or @samp{inset} statement:}
@example
outset("tweedledum", "");
@end example

@emph{Name the output dataset @samp{tweedledum} and
specify that it will be stored in memory, not on disk, and
that it will contain the values of all the variables
that are either in the input dataset or are declared in
the current @samp{infile} or @samp{inset} statement:}
@example
outset("<tweedledum", "");
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{output()}
@end display
@inindex output

@noindent
@strong{Description}

Writes one line of data to the output dataset specified by @samp{outset}.

@node Positioning within a dataset, Partitioning a dataset, Input and output, Datasets
@section Positioning within a dataset

@noindent
@strong{SPECIFICATION}
@display
@strong{dap_mark()}
@end display
@inindex mark
@inindex position
@inindex dap_mark

@noindent
@strong{Description}

Marks a position in a dataset: a call to @samp{dap_rewind} rewinds the dataset
to that position.

@noindent
@strong{SPECIFICATION}
@display
@strong{dap_rewind()}
@end display
@inindex dap_rewind
@inindex rewind
@inindex dataset

@noindent
@strong{Description}

Rewinds the input dataset to the location saved by the most recent call to
@samp{dap_mark}.
@inindex dap_mark

@node Partitioning a dataset, Modifying output, Positioning within a dataset, Datasets
@section Partitioning a dataset

@noindent
@strong{SPECIFICATION}
@display
@strong{dap_list(@var{variable-list}, @var{partv}, @var{npartv})}
@var{variable-list:} string
@var{partv:} array of int
@var{npartv:} int
@var{Returns:} int
@end display
@inindex dap_list

@noindent
@strong{Description}

Fills the array @var{partv}
@inindex partv
with the indices of the at most
@var{npartv} variables whose names are in the space-separated list
@var{variable-list}.
Returns the number of variables actually listed.

@noindent
@strong{Code fragment(s)}

@emph{With the input dataset sorted by the values of the variables
@samp{first} and @samp{last}, prepare @samp{namev} for use in
@samp{dap_head} or @samp{dap_newpart}:}
@example
int namev[2];
dap_list("first last", namev, 2);
@end example

@emph{In the function @samp{foo}, prepare @samp{varv} for use in
@samp{dap_head} or @samp{dap_newpart}:}
@example
foo(char *varlist)
  @{
    int varv[3];
    int numvars;

    numvars = dap_list(varlist, varv, 3);
    ...
  @}
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{dap_swap()}
@end display
@inindex swap
@inindex dap_swap

@noindent
@strong{Description}

Swaps the two most recently read input file or dataset lines so that
the program can complete processing of a part of that file or dataset after it detects
the beginning of a new part.

@noindent
@strong{SPECIFICATION}
@display
@strong{dap_newpart(@var{partv}, @var{npartv});}
@var{partv:} array of int
@var{npartv:} int
@var{Returns:} int
@end display
@inindex dap_newpart
@inindex new part
@inindex dataset, partitioning
@inindex partitioning

@noindent
@strong{Description}

Returns 1 if the beginning of a new part, or the end of the file or the
dataset, has been reached, 0 otherwise.

A collection of variables can be used to define parts of a dataset for which
all the variables in that collection are constant.  For example, if a dataset
@samp{names} has a variable @samp{first} that gives a person's first name and a
variable @samp{last} that gives a person's last
name, then sorting the dataset by @samp{last} and @samp{first} will define parts, each of
which contains all the records for one person (assuming no two people in the
dataset have the same first and last name).  
The following example program fragment counts how many records belong to each
person; it is assumed that the dataset has previously been
sorted by @samp{last} and @samp{first}.  
(This example is for illustrative purposes only: the same task can be done
in one line with the @samp{means} function.)

@noindent
@strong{Code fragment(s)}

@example
inset("names")
  @{
    int nrecords;   /* count of records */
    int partv[2];   /* array of numerical ids for variables */
    int more;       /* flag: is there more input? */
  
    dap_list("last first", partv, 2);  /* sets up numerical ids */
    for (nrecords = 0, more = 1; more; nrecords++)
      @{
        more = step();             /* read 1 line or end of dataset */
        if (dap_newpart(partv, 2)) /* test if beginning of part
                                    * defined by last and first
                                    */
          @{
            dap_swap();      /* back to last line in previous part */
            dap_head(partv, 2);  /* display header for that part */
            fprintf(dap_lst, "%d records\n", nrecords);
                                 /* display the number of records */
            dap_swap();          /* back to beginning of new part
                                  * or end of dataset
                                  */
            nrecords = 0;        /* re-initialize n for new part */
          @}
      @}
  @}
@end example

@node Modifying output, Manage datasets, Partitioning a dataset, Datasets
@section Modifying output

@noindent
@strong{SPECIFICATION}
@display
@strong{dap_save()}
@end display
@inindex dap_save

@noindent
@strong{Description}

Saves the most recently read input file or dataset line so that
the values of the variables can be modified for an additional output.

@noindent
@strong{SPECIFICATION}
@display
@strong{dap_rest()}
@end display
@inindex dap_rest

@noindent
@strong{Description}

Restores the most recently read input file or dataset line that was
saved by @samp{dap_save}.

@node Manage datasets,, Modifying output, Datasets
@section Manage datasets

@noindent
@strong{SPECIFICATION}
@display
@strong{dataset(@var{oldname}, @var{newname}, @var{action})}
@var{oldname}, @var{newname}, @var{action:} string
@end display

@display
proc datasets;
append @{base | out@}=@var{newname} [@{data | new@}=@var{oldname}];
change @var{oldname-1}=@var{newname-1} [... @var{oldname-n}=@var{newname-n}];
delete @var{filename-1} ... @var{filename-n};
@end display

@inindex dataset
@inindex copy
@inindex rename
@inindex append
@inindex remove
@inindex fill
@inindex missing cells
@inindex datasets (SBS proc)

@noindent
@strong{Description}

Performs the specified action on the datasets @var{oldname} and, if the action is not
@samp{REMOVE}, @var{newname}.
The string @var{action} must contain one of the words
@samp{APPEND}, @samp{RENAME}, @samp{COPY}, @samp{FILL}, or @samp{REMOVE}.

@samp{APPEND} appends
the dataset @var{oldname} at the end of @var{newname}. For @samp{APPEND},
only those variables existing
in @var{newname} are retained from @var{oldname} and if a variable
in @var{newname} does not appear in
@var{oldname}, the value of that variable is set to the null string if of type string or
0 if of type int or double.

@samp{RENAME} changes the name of the dataset from @var{oldname} to @var{newname}.

@samp{COPY} may be followed by a space-separated list
of variable specifications, each of
which has the form @var{variable-name} or @var{variable-name}
> @var{new-variable-name}. In either case, only the variables listed will be retained in
the copy of the dataset and in the second case, those variables will be renamed as
indicated. If @var{variable-name} refers to an array, then no index may be specified and
the entire array is retained and, if indicated, renamed.

@samp{FILL} makes a copy, named @var{newname}, of the dataset @var{oldname}
with the values in missing cells filled by 0.0 for variables of type double,
0 for variables of type int, and the null-string @samp{""}
for variables of type string.
@samp{FILL} must be followed by two space-separated lists which are separated by a
@samp{:}. The first list names the variables whose values are to be filled and
the second list names the variables that classify the cells in the dataset.
The dataset must be sorted by the classification variables in that order.

@samp{REMOVE} deletes the dataset @var{oldname}.

@noindent
@strong{Code fragment(s)}

@emph{Append the contents of the dataset @file{tweedledee} to
the dataset @file{tweedledum}:}
@example
dataset("tweedledee", "tweedledum", "APPEND");
@end example

@emph{Change the name of the dataset @file{tweedledee} to
@file{tweedledum}:}
@example
dataset("tweedledee", "tweedledum", "RENAME");
@end example

@emph{Make a copy of the dataset @file{tweedledee} and name the new
dataset @file{tweedledum}:}
@example
dataset("tweedledee", "tweedledum", "COPY");
@end example

@emph{Make a copy of the dataset @file{tweedledee} but retain
the values of @samp{alice} and @samp{mushroom} only, and name the
new dataset @file{tweedledum}:}
@example
dataset("tweedledee", "tweedledum", "COPY alice mushroom");
@end example

@emph{Make a copy of the dataset @file{tweedledee}, retain
the values of @samp{alice} and @samp{mushroom} only, name the
new dataset @file{tweedledum}, and change the name of @samp{alice}
to @samp{tall} in the new dataset:}
@example
dataset("tweedledee", "tweedledum", "COPY alice>tall mushroom");
@end example

@emph{Make a copy, named @file{tweedledum}, of the dataset @file{tweedledee},
which is sorted by @samp{SES}, @samp{race}, and @samp{gender}, with the missing
cells filled with 0.0 for the variable @samp{count}:}
@example
dataset("tweedledee", "tweedledum", "FILL count : SES race gender");
@end example

@emph{Remove the dataset @file{tweedledee}:}
@example
dataset("tweedledee", "", "REMOVE");
@end example

@node Managing and displaying data, Statistics functions, Datasets, Top
@chapter Managing and displaying data

These functions manipulate or display the data within a dataset (not a data file).

@menu
* Sorting a dataset:: sort
* Merging datasets:: merge
* Displaying a dataset:: print and table
* Splitting and joining lines:: split and join
* Grouping lines in a dataset:: group
* Trimming extreme values:: trim
@end menu

@node Sorting a dataset,Merging datasets,,Managing and displaying data
@section Sorting a dataset

@noindent
@strong{SPECIFICATION}
@display
@strong{sort(@var{dataset}, @var{variable-list}, @var{modifiers})}
@var{dataset}, @var{variable-list}, @var{modifiers:} string
@end display

@display
proc sort [data=@var{dataset-name}] [out=@var{dataset-name}] [nodupkey];
by [descending] @var{variable-1} [... [descending] @var{variable-n}]
@end display

@inindex sort
@inindex sort (SBS proc)

@noindent
@strong{Description}

Writes to @var{dataset}.srt the result of sorting
@var{dataset} in the order specified by the space-separated,
ordered list of variables @var{variable-list},
according to @var{modifiers}.
The original dataset is left unchanged.
If @var{modifiers}
is the null string, then all variables are sorted in increasing order
@inindex order, sort
and all sorted lines are kept.
Otherwise, @var{modifiers} is a space separated list of
@samp{u} and/or an ordered string of @samp{i} and @samp{d}
(no spaces) whose length equals the number of variables in
@var{variable-list:} @samp{u} means retain only one record in a group of lines for which
all the values of all the variables in @var{variable-list} are identical;
@samp{i} indicates that the corresponding variable will be sorted in increasing
order and @samp{d} indicates decreasing order.
@inindex sort
NOTE: sort allocates enough memory for sorting small to moderately large disk files
efficiently; for very large files, consider setting DAP_MAXMEM (@pxref{Appendix I}).

@noindent
@strong{Code fragment(s)}

@emph{Create a copy of the dataset @file{people} sorted by @samp{height}
in ascending order and by @samp{weight} in ascending order within
groups with equal @samp{height} and name
the new dataset @file{people.srt}:}
@example
sort("people", "height weight", "");
@end example

@emph{Create a copy of the dataset @file{people} sorted by @samp{height}
in descending order and by @samp{weight} in ascending order within
each group of lines with constant @samp{height} and name
the new dataset @file{people.srt}:}
@example
sort("people", "height weight", "di");
@end example

@emph{Create a copy of the dataset @file{people} sorted by @samp{last}
in ascending order and by @samp{weight} in ascending order within
each group of lines with constant @samp{height}, but retain only one line from
each group of lines with the constant @samp{last} and @samp{first},
and name the new dataset @file{people.srt}:}
@example
sort("people", "last first", "u");
@end example

@emph{Create a copy of the dataset @file{people} sorted by @samp{last}
in descending order and by @samp{weight} in descending order within
each group of lines with constant @samp{height}, but retain only one line from
each group of lines with the constant @samp{last} and @samp{first},
and name the new dataset @file{people.srt}:}
@example
sort("people", "last first", "u dd");
@end example

@node Merging datasets,Displaying a dataset,Sorting a dataset,Managing and displaying data
@section Merging datasets

@noindent
@strong{SPECIFICATION}
@display
@strong{merge(@var{dataset1}, @var{variable-list1}, @var{dataset2}, @var{variable-list2}, @var{partvars}, @var{outputset})}
@var{dataset1}, @var{variable-list1}, @var{dataset2}, @var{variable-list2}, @var{partvars}, @var{outputset:} string
@end display
@inindex merge
@inindex match

@noindent
@strong{Description}

Performs a many-to-one or one-to-one merge of
@var{dataset1} and @var{dataset2} and writes the result to @var{outputset}.
(For usage in an SBS @samp{data} step, see @xref{Appendix IV}.)
A variable is renamed in the output dataset if the variable name is followed by
@samp{> @var{newname}}.
Only the variables in @var{variable-list1}, renamed if requested,
are included from @var{dataset1}
and only the variables in @var{variable-list2}, renamed if requested,
are included from @var{dataset2};
these two variable lists must be disjoint.
Individual array elements may not be referenced in the variable lists; array
names must appear without bracketed indices.
If either variable list is a @samp{NULL}
pointer, then no variables are included from
that dataset; this can be used to select observations
from a dataset.
If either variable list is the null string ("", not @samp{NULL}),
then all variables from that dataset are included.
If either variable list contains the character @samp{!} before the first
variable name, then the named variables are excluded from, not included in,
the output dataset.
If @var{partvars} is not the null string or @samp{NULL}, then
matching is based on the variables in @var{partvars:}
for each part of the datasets @var{dataset1} and @var{dataset2}
specified by the variables in @var{partvars},
the first observation in @var{dataset2}
is matched with all observations from @var{dataset1};
both datasets must be sorted by @var{partvars} before merging.
Otherwise, observations in the two datasets are matched one-to-one
until one or both datasets are exhausted.

@noindent
@strong{Code fragment(s)}

@emph{Merge datasets @file{pretreat} and @file{posttreat} into a new
dataset @samp{changes} by matching
lines with corresponding values of @samp{name}; retain the values
of @samp{name} and @samp{preweight} from @file{pretreat} and
the values of @samp{postweight} from @file{posttreat}:}
@example
merge("pretreat", "name preweight",
      "posttreat", "postweight", "name", "changes");
@end example

@emph{Merge datasets @file{pretreat} and @file{posttreat} into a new
dataset @samp{changes} by matching
lines with corresponding values of @samp{name}; retain the values
of @samp{name} and @samp{weight} from @file{pretreat} and
the values of @samp{weight} from @file{posttreat}, but change the name of
@samp{weight} from @file{pretreat} to @samp{preweight} and
the name of @samp{weight} from @file{posttreat} to @samp{postweight}
in the dataset @file{changes}:}
@example
merge("pretreat", "name weight>preweight",
      "posttreat", "weight>postweight", "name", "changes");
@end example

@node Displaying a dataset,Splitting and joining lines,Merging datasets,Managing and displaying data
@section Displaying a dataset

@noindent
@strong{SPECIFICATION}
@display
@strong{print(@var{dataset}, @var{variable-list})}
@var{dataset}, @var{variable-list:} string
@end display

@display
proc print [data=@var{dataset-name}];
var @var{variable-list};
@end display

@inindex print
@inindex print (SBS proc)

@noindent
@strong{Description}

Displays the values of variables in @var{dataset}.
If @var{variable-list} is NULL or the null string or a string containing
only tabs or only commas, the values
of all variables are printed, otherwise just those of the named variables
are printed.
If the variables in @var{variable-list} are separated by spaces, then output
contains value of the @samp{_type_} variable and the observation number.
Otherwise, the variables must be separated by tabs or commas and
the value of the @samp{_type_} variable and the observation number are omitted.
No special handling is performed for strings containing tabs or commas.
@noindent
@strong{Code fragment(s)}

@emph{Display the values of all the variables of the dataset @file{names}:}
@example
print("names", "");
@end example

@emph{Display the values, separated by tabs, of all the variables of the dataset @file{names}:}
@example
print("names", "\t");
@end example

@emph{Display the values of @samp{first} and @samp{last}
of the dataset @file{names}:}
@example
print("names", "first last");
@end example

@emph{Display the values, separated by commas, of @samp{first}, @samp{middle}, and @samp{last}
of the dataset @file{names}:}
@example
print("names", "first, middle,last");
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{table(@var{dataset}, @var{row-vars}, @var{col-vars}, @var{format}, @var{partvars})}
@var{dataset}, @var{row-vars}, @var{col-vars}, @var{format}, @var{partvars:} string
@end display

@display
proc tabulate [data=@var{dataset-name}] [format=@var{width.places}];
[class @var{class-variable-list};]
[var @var{analysis-variable};]
table @var{row-variable-1} [... @var{row-variable-n}],
      @var{column-variable-1} [... @var{column-variable-n}] * @var{analysis-variable}
      [/ @{rtspace | rts@}=@var{number}];
by @var{variable-list};
@end display

@inindex print
@inindex table
@inindex tabulate (SBS proc)

@noindent
@strong{Description}

Displays values from @var{dataset} in tabular form.
The values of the variables in @var{row-vars} label the rows hierarchically and
the values of the variables in @var{col-vars} label the columns hierarchically
except that the last variable in @var{col-vars} is the variable of type double
whose values are displayed in the cells of the table.
The string @var{format} is of either of the two forms,
@var{width}.@var{precision} or @var{width}.
The first specifies that @var{width} characters
should be allotted for each cell and @var{precision} digits should be displayed to the right
of the decimal point.
The second only specifies the number of characters to be allotted for each cell
and lets the program choose the "best" allocation of decimals.
The @samp{table} function does not sort the data except that it sorts the columns if an
@samp{s} appears before the @var{width}.@var{precision} specification; thus, the data must be sorted by
the @var{partvars} (if any), @var{row-vars}, and @var{col-vars} before calling @samp{table}.
The @var{width}.@var{precision} can also be followed by
a number indicating how many columns to allocate for the combined
row labels, including column dividers.
@samp{Table} does not process the data and expects at most one value of the
numerical variable for each distinct combination
of the row and column variables; see function @samp{split}
(@pxref{Splitting and joining lines}) for datasets with multiple numerical
values to display.

SBS note: In @samp{proc tabulate}, the @samp{class} and @samp{var} statements have no effect and may be omitted.

@noindent
@strong{Code fragment(s)}

@emph{Display a table, with cells 6 characters long and values displayed
to 1 decimal place,
of the values of @samp{height} with the rows
labeled by @samp{last} and @samp{first} and the columns labeled by
@samp{county}:}
@example
table("names", "last first", "county height", "6.1", "");
@end example

@emph{Display tables, one for each @samp{state},
with cells 6 characters long and values displayed
to 1 decimal place,
of the values of @samp{height} with the rows
labeled by @samp{last} and @samp{first} and the columns labeled by
@samp{county}:}
@example
table("names", "last first", "county height", "6.1", "state");
@end example

@emph{Display a table, with cells 6 characters long and values displayed
to 1 decimal place,
of the values of @samp{height} with the rows
labeled by @samp{last} and @samp{first} and the columns labeled by
@samp{county}, with @samp{county} sorted in ascending order:}
@example
table("names", "last first", "county height", "s6.1", "");
@end example

@node Splitting and joining lines,Grouping lines in a dataset,Displaying a dataset,Managing and displaying data
@section Splitting and joining lines

@noindent
@strong{SPECIFICATION}
@display
@strong{split(@var{dataset}, @var{variable-list}, @var{class-value-vars})}
@var{dataset}, @var{variable-list}, @var{class-value-vars:} string
@end display
@inindex split

@noindent
@strong{Description}

For each line of @var{dataset}, writes to @var{dataset}.spl one line
for each variable in @var{variable-list}, with the value of the first
variable in @var{class-value-vars}
set to the name of that variable and the value of the second set to the
value.
All the variables in @var{variable-list} must have the same type, which will be
the type of the second variable in @var{class-value-vars}.
All variables in @var{dataset} except those @var{variable-list} appear
in @var{dataset}.spl, in addition to the two new variables named in
@var{class-value-vars}.
This function is useful for preparing a dataset for function @samp{table}.

@noindent
@strong{Code fragment(s)}

@emph{Create a new dataset @file{people.spl} that is a copy of
@file{people} except that each person's height and weight are on consecutive lines
so that @samp{table} can be called to display both values on the same line:}
@example
split("people", "height weight", "statname statistic");
table("people.spl", "name", "statname statistic", "6.0", "");
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{join(@var{dataset}, @var{partvars}, @var{value-var})}
@var{dataset}, @var{partvars}, @var{value-var:} string
@end display
@inindex join

@noindent
@strong{Description}

For consecutive lines in @var{dataset} distinguished by values of
the last variable named in @var{partvars}, which must be a string
variable, writes one line to @var{dataset}.joi.
In each part of @var{dataset} specified by all but the last variable
named in @var{partvars},
for each distinct value of the last variable named in @var{partvars},
the new dataset @var{dataset}.joi contains one new variable
whose name is that value and whose value is set to the value of
@var{value-var} in the corresponding line of @var{dataset}.
@var{dataset} must be sorted by @var{partvars} and
the same set of values of the last variable named in @var{partvars}
must occur in every part defined by all the variables but the last
in @var{partvars}.
Neither the last variable name in @var{partvars} nor
the variable @var{value-var} appears in @var{dataset}.joi.
This function is useful, for example, for preparing a dataset for
function @samp{plot}.

@noindent
@strong{Code fragment(s)}

@emph{Create a new dataset @file{people.joi} that is a copy of
@file{people} except that each person's height and weight, which were
given as values of the variable @samp{statistic} of type double,
on separate lines identified by the values @samp{height} and @samp{weight}
of the string variable @samp{statname}, now appear as variables named
@samp{height} and @samp{weight} on a single line:}
@example
join("people", "city name statname", "statistic");
nport(plot("people.joi", "height weight", "city",
            "", NULL, NULL, 3), 3, 1);
@end example

@node Grouping lines in a dataset,Trimming extreme values,Splitting and joining lines,Managing and displaying data
@section Grouping lines in a dataset

@noindent
@strong{SPECIFICATION}
@display
@strong{group(@var{dataset}, @var{variable-specification}, @var{partvars})}
@var{dataset}, @var{variable-specification}, @var{partvars:} string
@end display

@display
proc rank [data=@var{dataset-name}] [out=@var{dataset-name}]
          [@{fraction | f | percent | p | groups=@var{number}@}];
by @var{variable-list};
[ranks @var{new-variable-list};]
var @var{variable-list};

@end display

@inindex group
@inindex rank
@inindex rank (SBS proc)

@noindent
@strong{Description}

Writes to @var{dataset}.grp the observations of @var{dataset},
grouped according to the @var{variable-specification}.
Groups are numbered consecutively and are formed as specified by
@var{variable-specification}. @var{dataset} only needs to be
sorted by @var{partvars}, if there are any.

If @var{variable-specification} begins with either @samp{#}, @samp{/},
or @samp{%} then for each observation,
@var{group} computes either the number of the observation or
the fraction of the total number of observations or
the percent of the total number of observations, respectively.
@samp{#}, @samp{/}, or @samp{%} may be followed by a space and one of
@samp{+}, @samp{-}, @samp{+1}, @samp{+0}, @samp{-1}, or @samp{-0}
to indicate ascending order, starting from 0,
descending order, ending at 0,
ascending order, starting from 1,
ascending order, starting from 0,
descending order, ending at 1, or
descending order, ending at 0, respectively;
the default is ascending order, starting from 1.
This may in turn may be followed by a space-separated list of variables:
only those observations of the dataset for which all of these variables have
a finite (i.e., non-NaN) value are given group numbers and the remaining observations
are given a group number of NaN.

If @var{variable-specification} does not begin with
@samp{#}, @samp{/}, or @samp{%}, then it must be a space-separated list of
@var{variable-name} @var{ngroups-method}, in which
@var{ngroups-method} is either an integer followed by @samp{^} (no space in between)
for that number of groups
of equal width from the smallest observation to the largest or
an integer followed by
@samp{#} (no space in between), for that number of groups
of (approximately) equal counts from the smallest observation to the largest.
Only those observations for which all the grouping variables have finite
(i.e., non-NaN) values are given group numbers and the
remaining observations are given a group number of NaN.
The numbering of the groups starts at 1.

In addition to all variables in @var{dataset}, the output dataset contains
for each grouping variable, which must be of type double,
a new variable whose
name is formed by preceding the original variable name with an
underscore (@samp{_});
this new variable, which is also of type double,
contains the group number of the value of the original variable.
If only @samp{#}, @samp{/}, or
@samp{%},
was requested, then the new variable is named @samp{_N_}.

SBS note: In @samp{proc rank}, the @samp{ranks} statement is ignored: the output data
set always contains new variables for the ranks, as in
the dap function @samp{group}.

@noindent
@strong{Code fragment(s)}

@emph{Create a new dataset @file{people.grp} that is a copy of
@file{people} except that it has an additional variable named
@samp{_N_} that contains the line number, starting at 1:}
@example
group("people", "#", "");
@end example

@emph{Create a new dataset @file{people.grp} that is a copy of
@file{people} except that it has an additional variable named
@samp{_N_} that contains the line number, starting at 0:}
@example
group("people", "# +0", "");
@end example

@emph{Create a new dataset @file{people.grp} that is a copy of
@file{people} except that it has an additional variable named
@samp{_height} that contains a number from 1 to 5 that indicates
the quintile of the value of @samp{height}:}
@example
group("people", "height 5#", "");
@end example

@emph{Create a new dataset @file{people.grp} that is a copy of
@file{people} except that it has an additional variable named
@samp{_height} that contains a number from 1 to 5 that indicates
which of 5 equal length intervals, starting at the smallest value
of @samp{height} and ending at the largest,
contains the value of @samp{height}:}
@example
group("people", "height 5^", "county");
@end example

@node Trimming extreme values,,Grouping lines in a dataset,Managing and displaying data
@section Trimming extreme values

@noindent
@strong{SPECIFICATION}
@display
@strong{trim(@var{dataset}, @var{trim-specification}, @var{partvars})}
@var{dataset}, @var{trim-specification}, @var{partvars:} string
@end display

@noindent
@strong{Description}

Writes to @var{dataset}.trm the observations from @var{dataset}
for which the values of all of the variables in
@var{trim-specifications} do not lie in the upper or lower percent indicated in
@var{trim-specifications}.
The string @var{trim-specifications}
consists of space-separated pairs of
@var{variable-name} @var{percent}.
The variables listed in @var{trim-specifications} must be of type double.

@noindent
@strong{Code fragment(s)}

@emph{Create a new dataset named @file{wheat.trm} that contains only
those values of @samp{yield} that do not lie
in the upper or lower 5% of all the values of @samp{yield}:}
@example
trim("wheat", "yield 5", "");
@end example

@emph{Create a new dataset named @file{wheat.trm} that contains only
those lines of @file{wheat} whose value of @samp{yield} does not lie
in the upper or lower 5% of all the values of @samp{yield} and,
simultaneously, whose value of @samp{nitrogen} does not lie
in the upper or lower 10% of all the values of @samp{nitrogen}:}
@example
trim("wheat", "yield 5 nitrogen 10", "");
@end example
@inindex trim
@inindex means
@inindex extreme values
@inindex outliers

@node Statistics functions, Graphics functions, Managing and displaying data, Top
@chapter Statistics functions

@menu
* One variable statistics:: means and pctiles
* Survey selection:: survey select
* Correlations:: corr
* Analysis of variance:: effects, ftest, and lsmeans
* Categorical data analysis:: freq, categ, and loglin
* Linear regression:: linreg
* Logistic regression:: logreg
* Nonparametric analyses:: nonparam
* Statistics utilities:: estimate

@end menu

@node Survey selection
@section Survey selection
@noindent
@strong{SPECIFICATION}
@display
@strong{surveyselect(@var{dataset}, @var{variable-specification}, @var{stat-list}, @var{partvars})}
@var{dataset}, @var{variable-specification}, @var{stat-list}, @var{partvars:} string
@end display

@display
proc surveyselect [data=@var{dataset-name}] [out=@var{out-name}]  [method=@var{method-name}]  [n=@var{n-name}];
@end display

@inindex surveyselect (SBS proc)

@noindent
@strong{Description}

survey selection on a dataset.
method SRS and SYS are implemented.
Method SRS take [n] values in the dataset by randomization. 
Method SYS take [n] values in the dataset with a systematic algorithm starting with a simple random.

@example
proc surveyselect data =tPres2007 method=SRS  n = 220 out=sasPres2007 ;
run ;
@end example

@node One variable statistics,Correlations,,Statistics functions
@section One variable statistics

@noindent
@strong{SPECIFICATION}
@display
@strong{means(@var{dataset}, @var{variable-specification}, @var{stat-list}, @var{partvars})}
@var{dataset}, @var{variable-specification}, @var{stat-list}, @var{partvars:} string
@end display

@display
proc means [data=@var{dataset-name}] [noprint] [@var{statistics-list}]
           [vardf=@{df | wdf@}];
var @var{variable-list};
weight @var{variable};
by @var{variable-list};
output [out=@var{dataset-name}];
@end display

@inindex means (SBS proc)

@noindent
@strong{Description}

Writes to @var{dataset}.mns the statistics requested in
@var{stat-list} for the variables in @var{variable-specification}, which must be
of type double.
The @samp{means} function does not display its results in the @file{lst} file; use
@samp{print} or @samp{table} (@ref{Displaying a dataset}) after
calling @samp{means} to display the results from @var{dataset}.mns.
The statistics are given as values of the variables named in @var{variable-specification}
in @var{dataset}.mns.
The string @var{stat-list}
is a space separated list of one or more of the following statistics:

@strong{MAX}
@quotation
the maximum of the variable values
@end quotation
@inindex maximum

@strong{MEAN}
@quotation
the mean of the variable values
@end quotation
@inindex mean

@strong{MIN}
@quotation
the minimum of the variable values
@end quotation
@inindex minimum

@strong{N}
@quotation
the number of finite observations
@end quotation
@inindex number of observations

@strong{RANGE}
@quotation
the maximum minus the minimum of the variable values
@end quotation
@inindex range

@strong{SD} or @strong{STD}
@quotation
the sample standard deviation of the variable values (df = number of observations - 1)
@end quotation
@inindex standard deviation
@inindex sd

@strong{SDFREQ}
@quotation
the weighted sample standard deviation of the weighted variable values (df = sum of weights - 1)
@end quotation
@inindex standard deviation
@inindex sd

@strong{SEM} or @strong{STDERR}
@quotation
the sample standard error of the mean of the variable values (df = number of observations - 1)
@end quotation
@inindex standard error of the mean
@inindex sem

@strong{SEMFREQ}
@quotation
the weighted sample standard error of the mean of the variable values (df = sum of weights - 1)
@end quotation
@inindex standard error of the mean
@inindex sem

@strong{STEPxxxx}
@quotation
a sequence of @var{xxxx} + 1 equally spaced numbers from the minimum
to the maximum of the variable values, with xxxx an integer of at most 4 digits
@end quotation
@inindex step

@strong{SUM}
@quotation
the sum of the variable values
@end quotation
@inindex sum

@strong{SUMWT}
@quotation
the sum of the weight variable values
@end quotation
@inindex weight

@strong{T}
@quotation
the value of the t-statistic for the variable values
@end quotation
@inindex Student's t
@inindex t

@strong{TPROB} or @strong{PRT}
@quotation
the (two-tailed) probability that the absolute value of the t-statistic would equal or exceed the observed value
@end quotation
@inindex t-test

@strong{VAR}
@quotation
the sample variance of the variable values (df = number of observations - 1)
@end quotation
@inindex variance

@strong{VARFREQ}
@quotation
the weighted sample variance of the variable values (df = sum of weights - 1)
@end quotation
@inindex variance

@strong{VARM}
@quotation
the sample variance of the mean of the variable values (df = number of observations - 1)
@end quotation
@inindex variance

@strong{VARMFREQ}
@quotation
the weighted sample variance of the variable values (df = sum of weights - 1)
@end quotation
@inindex variance

For each observation in the output data set, the @samp{_type_}
variable names the statistic whose
value is given for the requested variable.
If the only statistic requested is @samp{N},
@inindex number of observations
then @var{variable-list}
may consist of a single variable
which need not be present in the input data set.
The string @var{variable-specification}
is a space-separated list of variables except that each weight
@inindex weight
variable is preceded by an @samp{*}.
For example,

@example
w x * u y z * v
@end example

@noindent
indicates that each value of @var{w} and @var{x}
is weighted by the value of @var{u} and that each value of
@var{y} and @var{z} is weighted by the value of
@var{v}.

For each variable separately,
means discards values for which either the value itself or
its weight value, if any, is a NaN.
@inindex NaN
The number of discarded values for each variable is reported
in the @file{log} file.

@noindent
@strong{Code fragment(s)}

@emph{For each distinct value of the variable @samp{plot},
compute and display the number of observations in dataset @file{wheat}
and the mean and variance of the values of @samp{yield} and
@samp{height}:}
@example
means("wheat", "yield height", "N MEAN VAR", "plot");
table("wheat.mns", "plot", "_type_ yield", "s6.1", "");
table("wheat.mns", "plot", "_type_ height", "s6.1", "");
@end example

@emph{For each distinct value of the variable @samp{county},
compute and display the number of observations in dataset @file{wheat}
and the mean and variance of the value of @samp{meanyield},
weighted by @samp{acres}:}
@example
means("wheat", "meanyield * acres", "N MEAN VAR", "county");
table("wheat.mns", "county", "_type_ meanyield", "s6.1", "");
@end example

@emph{For each distinct value of the pair of variables @samp{last}
and @samp{first}, compute the number of observations in dataset @file{names}:}
@example
means("names", "nrecords", "N", "last first");
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{pctiles(@var{dataset}, @var{variable-specification}, @var{stat-list}, @var{partvars})}
@var{dataset}, @var{variable-specification}, @var{stat-list}, @var{partvars:} string
@end display

@display
proc univariate [data=@var{dataset-name}] [noprint] [normal] [plot];
var @var{variable-list};
by @var{variable-list};
weight @var{variable};
output [out=@var{dataset-name}] [@var{statistics-list}];
@end display

@inindex univariate (SBS proc)

@noindent
@strong{Description}

Writes to @var{dataset}.pct the statistics requested in
@var{stat-list} for the variables @var{variable-specification}, which must be
of type double.
The @samp{pctiles} function does not display its results in the @file{lst} file; use
@samp{print} or @samp{table} (@ref{Displaying a dataset}) after calling
@samp{pctiles} to display the results from @var{dataset}.pct.
The statistics are given as values of the variables named in @var{variable-specification}
in @var{dataset}.pct.
The string @var{stat-list}
is a space separated list of one or more of the following statistics:

@strong{MAX}
@quotation
the maximum
@end quotation
@inindex maximum

@strong{MED} or @strong{MEDIAN}
@quotation
the median
@end quotation
@inindex median

@strong{MIN}
@quotation
the minimum
@end quotation
@inindex minimum

@strong{N}
@quotation
the number of observations
@end quotation
@inindex number of observations

@strong{P1}
@quotation
the 1% point
@end quotation

@strong{P5}
@quotation
the 5% point
@end quotation

@strong{P10}
@quotation
the 10% point
@end quotation

@strong{P90}
@quotation
the 90% point
@end quotation

@strong{P95}
@quotation
the 95% point
@end quotation

@strong{P99}
@quotation
the 99% point
@end quotation

@strong{Q1}
@quotation
the first quartile
@end quotation
@inindex quartile

@strong{Q3}
@quotation
the third quartile
@end quotation
@inindex quartile

@strong{QRANGE}
@quotation
the interquartile range
@end quotation
@inindex interquartile range

@strong{RANGE}
@quotation
the range
@end quotation
@inindex range

Up to 9 additional percentile points
@inindex percentile points
can be specified in the form @samp{P@var{xxxxx}}
in which @samp{xxxxx}
is a number, which may contain up to 5 characters, including a decimal point.

The string @var{variable-specification}
is a space-separated list of variables except that each weight
@inindex weight
variable is preceded by an @samp{*}.
For example,

@example
w x * u y z * v
@end example

@noindent
indicates that each value of @var{w} and @var{x}
is weighted by the value of @var{u} and that each value of
@var{y} and @var{z} is weighted by the value of
@var{v}.

@noindent
@strong{Code fragment(s)}

@emph{Compute and display the 10th, 25th, 50th (median), 75th, and 90th percentiles
of @samp{income} for each @samp{county} in the dataset @file{people}:}
@example
pctiles("people", "income", "P10 P25 MED P75 P90", "county");
table("people.pct", "county", "_type_ income", "s7.2", "");
@end example

@emph{Compute and display the 37.5th, 50th (median), and 62.5th percentiles
of @samp{income} for each @samp{county} in the dataset @file{people}:}
@example
pctiles("people", "income", "P37.5 MED P62.5", "county");
table("people.pct", "county", "_type_ income", "s7.2", "");
@end example
@inindex percentiles
@inindex pctiles

@node Correlations,Analysis of variance,One variable statistics,Statistics functions
@section Correlations

@noindent
@strong{SPECIFICATION}
@display
@strong{corr(@var{dataset}, @var{variable-list}, @var{partvars})}
@var{dataset}, @var{variable-list}, @var{partvars:} string
@end display

@display
proc corr [data=@var{dataset-name}] [outp=@var{dataset-name}] [noprint];
var @var{variable-list};
by @var{variable-list};
@end display

@inindex corr (SBS proc)

@noindent
@strong{Description}

Writes to @var{dataset}.cor the correlation statistics and their significances for
all pairs of the variables, each of which must be of type double,
in @var{variable-list}.
The @samp{corr} function does not display its results in the @file{lst} file; use
@samp{print} or @samp{table} (@ref{Displaying a dataset}) after calling
@samp{corr} to display the results from @var{dataset}.cor.
The output dataset contains the variables @samp{_var1_}, @samp{_var2_}, and @samp{_corr_}
@inindex _var1_
@inindex _var2_
@inindex _corr_
in addition to all the variables in @var{partvars}.
There is one pair of correlation and significance
values for each pair of numeric variables.
For each line of the output data set,
@samp{_var1_}, and @samp{_var2_}, contain the names of the variables being
reported on and @samp{_corr_}
contains the number of observations, the correlation coefficient, or its significance, as
indicated by the values @samp{N},
@samp{CORR}, and @samp{PCORR} of the @samp{_type_} variable, respectively.

@noindent
@strong{Code fragment(s)}

@emph{Compute and display the correlations and their signficances for
each pair of the variables @samp{height}, @samp{weight},
and @samp{income}:}
@example
corr("people", "height weight income", "");
sort("people.cor", "_type_ _var1_ _var2_", "");
table("people.cor.srt", "_var1_", "_var2_ _corr_", "6.2", "_type_");
@end example
@inindex corr
@inindex correlation

@node Analysis of variance,Categorical data analysis,Correlations,Statistics functions
@section Analysis of variance

@noindent
@strong{SPECIFICATION}
@display
@strong{effects(@var{dataset}, @var{variable-list}, @var{model}, @var{partvars})}
@var{dataset}, @var{variable-list}, @var{model}, @var{partvars:} string
@end display

@display
proc glm [data=@var{dataset-name}];
class @var{variable-list};
model @var{response-variable} = @var{effects-list};
by @var{variable-list};
contrast "@var{label}" @var{effect} @var{coefficient-list} [/ e=@var{effect}];
lsmeans @var{effect-list} / [e=@var{effect}] [alpha=@var{n}] @{DUNNETT | TUKEY | LSD@};
test h=@var{effect-list} e=@var{effect};

@end display

@inindex glm (SBS proc)
@inindex effects
@inindex analysis of variance
@inindex ANOVA
@inindex model

@noindent
@strong{Description}

For @var{dataset}, created by @var{means} with @samp{N}, @samp{MEAN}, and @samp{VAR},
but no other statistics requested, @var{effects} constructs a dataset named
@var{dataset}.con appropriate for @samp{ftest} and then calls @samp{ftest}
on the set of contrasts
@inindex contrasts
specified by all the terms together in @var{model}.
@samp{Ftest}
@inindex F-test
can be used on @var{dataset}.con
to perform F-tests on the contrasts that correspond to individual
terms in the model.
The first variable in @var{variable-list}
is the response variable, which must be of type double,
and the remainder are the treatment variables, all of which must be of type string.
The string @var{model}
@inindex model
is a space-separated list of terms in the model; all
possible terms not in the model are considered to be in
the error, in addition to the cell variances (if any).
Each term is either a treatment or a cross of two or more
treatments, which is indicated by an @samp{*} separated list of treatments.
Nesting
@inindex nested design
can be specified by including an effect in a cross
term without that effect appearing as a main effect.
NOTE:
@inindex bug
@inindex nested design
In the current version, 3.5, nested designs must be balanced and the
levels of the nested factors must be the same for each set of levels
of the factors within which they are nested; presumably,
this will be corrected in later versions.

The output dataset @var{dataset}.con contains a variable named @samp{_term_},
@inindex _term_
of type int, which indicates which terms the error and contrast lines refer to:
each bit in @samp{_term_}, with the lowest order bit corresponding to the
first treatment variable,
indicates whether the correspondingly numbered treatment in the model
is included in the term.
The error, contrast, and least-squares means terms in
@var{dataset}.con are adjusted for missing cells, but only the error
terms are orthogonalized.

SBS note: All the variables used in the @var{effects-list} of the @samp{model}
statement must be named in the @samp{class} statement, as dap only
allows categorical, string-valued, variables for the terms in the model.
Specify crossed and nested effects using @samp{*} only.
A @samp{test} statement automatically computes an appropriate combination of mean
squares from the terms in @samp{e=} error term list, if possible, to test the numerator and
applies the Satterthwaite approximation.
An @samp{lsmeans} statement that has an @samp{e=} option or that appears after
a @samp{contrast}, a @samp{test}, or another @var{lsmeans} statement
automatically runs an F-test with the same denominator.
In each @samp{contrast} statement, the effect to be tested must be a main effect,
the coefficients must appear in the sorting order of the
levels of that effect, they must be integers, and they must sum to zero.
For more complicated contrasts, see @xref{Analysis of variance examples}.

@noindent
@strong{Code fragment(s)}

@emph{Perform an analysis of variance on the completely randomized
one-way layout with
response variable @samp{yield} and treatment @samp{fert}:}
@example
effects("wheat.srt.mns", "yield fert", "fert", "");
@end example

@emph{Perform an analysis of variance (F-test on the model only)
on the one-way layout in a completely randomized block design with
response variable @samp{yield} and treatment @samp{fert},
blocked by @samp{block}, with main effects only:}
@example
effects("wheat.srt.mns", "yield fert block",
                 "fert block", "");
@end example

@emph{Perform an analysis of variance (F-test on the model only)
on the two-way layout in a completely randomized block design with
response variable @samp{yield} and treatments @samp{fert} and
@samp{variety}, blocked by @samp{block}, with main effects
and treatment interaction:}
@example
effects("wheat.srt.mns", "yield fert variety block",
                 "fert variety fert*variety block", "");
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{ftest(@var{dataset}, @var{variable-list}, @var{numerator}, @var{denominator}, @var{partvars})}
@var{dataset}, @var{variable-list}, @var{numerator}, @var{denominator}, @var{partvars:} string
@end display
@inindex F-test

@noindent
@strong{Description}

Performs an F-test on the hypothesis that all the contrasts specified by @var{numerator}
are zero, using the terms specified by @var{denominator},
and the variances of the cell means, as appropriate, as the error.
The string @var{variable-list} must list the response variable followed by all the variables
in the model and error terms.

The input dataset
must have the following format: for each cell, there must be a line
for the mean, the number of observations for that cell, and the variance
(these three may be in any order)
followed by the denominator terms and then the numerator terms.
These lines are identified respectively by the following values
of the @samp{_type_} variable: @samp{MEAN}, @samp{N}, @samp{VAR}, @samp{ERROR}, and @samp{CONTR}.
Additional lines, such as @samp{LSMEAN}, lines, may follow.
The numerator and denominator terms used for the test,
which need to be adjusted for missing data (as is done by
effects) but which do not need to be orthogonal, are identified by the value of the
@samp{_term_} variable in dataset (see @samp{effects}).
If @var{numerator} is null, then all the terms identified as
@samp{CONTR} are used in the test.
If @var{denominator}
is null, then the cell variances and all the terms identified as
@samp{ERROR} are used in the test.
If @var{denominator}
is non-null, then the cell variances are not included in the test and @samp{ftest}
constructs an appropriate combination of mean squares
@inindex mean squares
from the terms in
that denominator to test the numerator and applies the Satterthwaite
@inindex Satterthwaite
approximation.
Note, however, that @var{denominator}
must contain all possible terms that might be needed to construct that
combination of mean squares.

The function @var{ftest} writes out a dataset,
with the suffix of @var{dataset} replaced by .tst,
which contains only those error, contrast, and least-squares means terms
appearing in dataset that appear in the test.
This file is suitable for input to @var{lsmeans}.
@inindex lsmeans
@inindex least square means
At the end of that file are two lines, the first
with the mean-squared error appearing as the value of the response variable
and the second with the error degrees of freedom
appearing as the value of the response variable.
These lines are identified by the _type_ variable as
@samp{MSERROR} and @samp{ERRORDF}, respectively.

@noindent
@strong{Code fragment(s)}

@emph{Perform an F-test on the interaction term in the
in the two-way layout in a completely randomized block design with
response variable @samp{yield} and treatments @samp{fert} and
@samp{variety}, blocked by @samp{block} as a fixed effect, with main effects
and treatment interaction:}
@example
ftest("wheat.srt.mns.con", "yield fert variety block",
                                    "fert*variety", "", "");
@end example

@emph{Perform an F-test on the interaction term in the
in the two-way layout in a completely randomized block design with
response variable @samp{yield} and treatments @samp{fert} and
@samp{variety}, blocked by @samp{block} as a random effect, with main effects
and treatment interaction:}
@example
ftest("wheat.srt.mns.con", "yield fert variety block", "fert",
                                    "block fert*block", "");
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{lsmeans(@var{dataset}, @var{method}, @var{alpha}, @var{variable-list}, @var{treat}, @var{partvars}, @var{format})}
@var{dataset}, @var{method}, @var{variable-list}, @var{treat}, @var{partvars}, @var{format:} string
@var{alpha:} double
@end display
@inindex lsmeans
@inindex least square means

@noindent
@strong{Description}

For @var{dataset} produced by @samp{ftest} whose @var{numerator} is the same
as the @var{treat} of @samp{lsmeans},
computes the least-squares means of the levels of
@var{treat} and reports the minimum difference significant at level
@var{alpha} and places the comparison of them according to
@var{method} in a dataset named
@var{dataset-name}.lsm,
and displays a table of results, the cells of which are
formated according to @var{format} as for @var{table}.
The available methods are
@inindex LSD
@inindex Fisher's LSD
@inindex Tukey
@inindex Dunnett
@samp{LSD}, @samp{TUKEY}, and @samp{DUNNETT}.
For @samp{DUNNETT}, the first level of @var{treat} is taken to be the control.
@inindex control

@noindent
@strong{Code fragment(s)}

@emph{Compute and test, using the LSD method with significance level
0.05, least squares means
for the one-way layout in a completely randomized block design with
response variable @samp{yield} and treatment @samp{fert},
blocked by @samp{block}, with main effects only; the table of
results is displayed with cells 6 characters long and values
to 1 decimal place:}
@example
lsmeans("data.srt.mns.tst", "LSD", 0.05,
                    "yield treat block", "block", "", "8.4");
@end example

@node Categorical data analysis,Linear regression,Analysis of variance,Statistics functions
@section Categorical data analysis

@noindent
@strong{SPECIFICATION}
@display
@strong{freq(@var{dataset}, @var{variable-list}, @var{stat-list}, @var{partvars})}
@var{dataset}, @var{variable-list}, @var{stat-list}, @var{partvars:} string
@end display

@display
proc freq [data=@var{dataset-name}];
by @var{variable-list};
tables @var{variable-1} [* @var{variable-2} [... * @var{variable-n}]] /
             [out=@var{dataset-name}] [noprint] [nofreq] [noprecent]
             [norow] [nocol] [@var{statistics-list}];
weight @var{variable};
@end display

@inindex freq (SBS proc)
@inindex freq
@inindex contingency table
@inindex cross-tabulation
@inindex cross-classification

@noindent
@strong{Description}

Writes dataset @var{dataset}.frq with the variable @samp{_cell_},
of type double, set equal to the count, fraction, percent, or expected value under
independence, as requested by @var{stat-list}
for the cells with distinct values of the variables in
@var{variable-list}.
The dataset @var{dataset} must be sorted by @var{variable-list}.
The @samp{freq} function does not display its results in the @file{lst} file; use
@samp{print} or @samp{table} (@pxref{Displaying a dataset}) after calling
@samp{freq} to display the results from @var{dataset}.frq.
If @var{variable-list} contains a count-variable,
which must appear last in the list and must be preceded by an @samp{*}
and which must be of type double,
then the count, fraction, or percent is weighted by the values of that
count-variable for that cell.
The string @var{stat-list} is a space separated list of one or more of the following statistics:

@strong{CHISQ}
@inindex chi-squared
@quotation
for 2-dimensional tables, compute Pearson's chi-squared statistic and test
@end quotation

@strong{CMH}
@inindex CMH
@inindex Cochran-Mantel-Haenszel
@quotation
for tables of dimension 3 or higher, compute the Cochran-Mantel-Haenszel statistic and test,
with strata defined by the levels of all but the last two variables in
@var{variable-list}
@end quotation

@strong{COLPERC}
@inindex column percentage
@inindex percentage, column
@quotation
the percent of the number of observations in the column
@end quotation

@strong{COUNT}
@inindex count
@quotation
the number of observations
@end quotation

@strong{EXPECTED}
@inindex expected count
@inindex independence
@quotation
for 2-dimensional tables, the expected table entry under independence,
conditioned on the marginal totals
@end quotation

@strong{FISHER}
@inindex Fisher's exact test
@inindex exact test
@quotation
for 2x2 tables, computes Fisher's exact test
@end quotation

@strong{FRACTION}
@inindex fraction
@quotation
the fraction of the total number of observations
@end quotation

@strong{NOMINAL}
@inindex nominal
@inindex association
@inindex measures of association
@inindex uncertainty coefficient
@quotation
for 2-dimensional tables, compute the following measures of association of nominal variables and their asymptotic standard errors: uncertainty coefficients
@end quotation

@strong{ODDSRAT}
@inindex odds ratio
@quotation
for 2x2 tables, computes the odds ratio
@end quotation

@strong{ORDINAL}
@inindex ordinal
@inindex association
@inindex measures of association
@inindex Kendall's Tau-b
@inindex Somers' D
@quotation
for 2-dimensional tables, compute the following measures of association of ordinal variables and their asymptotic standard errors: gamma, Kendall's Tau-b, and Somers' D (column on row and row on column)
@end quotation

@strong{PAIR}
@quotation
for 2-dimensional tables, compute measures of association for matched pairs and
their asymptotic standard errors
@end quotation
@inindex paired

@strong{PERCENT}
@quotation
the percent of the total number of observations
@end quotation
@inindex percent

@strong{ROWPERC}
@quotation
the percent of the number of observations in the row
@end quotation
@inindex row percent
@inindex percent, row

For @samp{CHISQ}, @samp{FISHER}, @samp{ODDSRAT}, and @samp{ORDINAL},
the requested statistic and, if applicable, test is displayed in the @file{lst} file.
For @samp{COUNT}, @samp{EXPECTED}, @samp{FRACTION}, and @samp{PERCENT},
the requested @samp{_cell_} values are indicated in
@var{dataset}.frq by the corresponding value of the @samp{_type_} variable.
The input dataset must be sorted by the variables named in
@var{partvars} and @var{variable-list}.

@noindent
@strong{Code fragment(s)}

@emph{For each @samp{state} and @samp{county} in
the dataset @file{people}, compute and display the cell
percentages for a two-way table whose rows are labeled by
@samp{education} and whose columns are labeled by @samp{education}:}
@example
freq("people", "education income", "PERCENT", "state county");
table("people.frq", "education", "income _cell_",
                                             "3.0", "state county");
@end example

@emph{For each @samp{county} in
the dataset @file{people}, compute and display the cell
counts for a two-way table whose rows are labeled by
@samp{education} and whose columns are labeled by @samp{education};
also compute and display the cell counts expected under independence and
the Chi-squared statistic and its significance:}
@example
freq("people", "education income", "COUNT EXPECTED CHISQ", "county");
sort("people.frq", "county _type_ education income", "");
table("people.frq.srt", "education", "income _cell_",
                                             "6.0", "county _type_");
@end example

@emph{For each @samp{state} and @samp{county} in
the dataset @file{people}, compute and display the cell
percentages within row for a two-way table whose rows are labeled by
@samp{education} and whose columns are labeled by @samp{education}:}
@example
freq("people", "education income", "ROWPERC", "state county");
table("people.frq", "education", "income _cell_",
                                             "3.0", "state county");
@end example

@emph{For the dataset @file{rabbits.srt}, compute
the Cochran-Mantel-Haenszel statistic and its significance
for a three-way table that is stratified by
@samp{penicillin} and, within each stratum,
whose rows are labeled by
@samp{delay} and whose columns are labeled by @samp{response} and
whose cell counts are given by @samp{count};
:}
@example
freq("rabbits.srt", "penicillin delay response*count", "CMH", "");
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{categ(@var{dataset}, @var{variable-list}, @var{aux-variable-list}, @var{expect}, @var{param}, @var{select}, @var{partvars}, @var{trace})}
@var{dataset}, @var{variable-list}, @var{aux-variable-list}, @var{select}, @var{partvars}, @var{trace:} string
@var{expect:} pointer to function returning double
@var{param:} array of double
@end display
@inindex categ
@inindex categorical data analysis
@inindex loglinear models
@inindex logit models
@inindex logistic regression

@noindent
@strong{Description}

@samp{Categ} fits the model specified by the function @var{expect}
and the parameter selection string @var{select} to the data by
the method of maximum likelihood, reports goodness of fit statistics from the
comparison of the specified model with either a reduced
model or the saturated model, writes
the observed and fitted cell counts to @var{dataset}.cat,
with the @samp{_type_} variable set to @samp{OBS} and @samp{FIT}, respectively,
and the estimates and the covariance matrix to @var{dataset}.cov,
with the @samp{_type_} variable set to @samp{ESTIMATE} and
@samp{COVAR}, respectively, the @samp{_param1_}
and @samp{_param2_} variables indicating which of the parameters named in
@var{select} identify the row and column, and the @samp{_cov_} variable
containing the numerical value.
The first variable named in @var{variable-list} is the cell count for the cells.
Cells are classified by the remaining variables in @var{variable-list}.
Additional auxiliary variables, such as the total number
of observations or marginal totals, that are required for computing expected
cell counts (see @samp{expect} below) can be listed in @var{aux-variable-list}.
All variables in @var{variable-list} and in @var{aux-variable-list}
must be coded as double; this allows @samp{categ}
to work with continuous and categorical variables together.
The input dataset must be sorted according to the classification variables in
@var{variable-list} in the order that they appear there.
If non-null,
the trace option @var{trace} is passed to @samp{dap_maximize} for tracing the
maximum likelihood iteration.

The string @var{select} is a space-separated sequence of parameter
names, each one optionally preceded by either a @samp{!} to indicate that
it is to omitted from the model or @samp{?} to indicate that it should
be omitted from the reduced model only.
The number of parameters must equal the dimension of the @var{param} array
and the order corresponds to the order of entries in that array.
Note that the parameter names need not correspond to
variables in the dataset, they are used only to identify
their estimates in the output.
If there are no @samp{?}s, then the goodness of fit statistics
computed are relative to the saturated model.
If there are @samp{?}s, then the goodness of fit statistics are computed
relative to the reduced model obtained by setting all the @samp{?}s to @samp{!}s.

@samp{Categ} assumes that the parameters in @var{param} are independent and computes
the degrees of freedom as the number of cells minus the number of parameters.
See @samp{estimate} (@pxref{Statistics utilities}) to see how to obtain
statistics on the remaining parameters or contrasts.
The initial values of the parameters for the maximum likelihood estimation
must be supplied in the call to @samp{categ}; they are not modified by @samp{categ}.
The function pointed to by @var{expect} must take two parameters, an array of
parameter values, with dimension equal to the number of parameters
specified by the string @var{select},
followed by an array of classification, and possibly auxiliary, values,
with dimension equal to the number of classification and auxiliary
variables in @var{variable-list} and @var{aux-variable-list}, and return the
expected number of observations for the indicated cell, based on
the parameter, classification, and auxiliary (if any) values supplied.

Note: @samp{categ} creates or overwrites the dataset @var{dataset}.fil to
create a dataset with no missing cells for the analysis.

@noindent
@strong{Code fragment(s)}

@emph{Use the user-defined function @samp{expect} to fit and
test a loglinear model and print a table of the
observed and fitted cell counts; in the dataset @file{deathpen}, the
variable @samp{n} gives the cell counts for the three-way
table classified by @samp{def}, @samp{vic}, and @samp{pen} and
@samp{param} is an array of 7 independent parameters:}
@example
double expect(double param[8], double class[2]);
categ("cda262", "count income jobsat", &expect, param,
      "mu <6 6-15 15-25 VD LD MS ?Inc*Sat", "", "");
sort("cda262.cat", "income _type_ jobsat", "");
table("cda262.cat.srt", "income", "_type_ jobsat count", "6.2", "");

@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{loglin(@var{dataset}, @var{variable-list}, @var{model0}, @var{model1}, @var{partvars})}
@var{dataset}, @var{variable-list}, @var{model0}, @var{model1}, @var{partvars:} string
@end display
@inindex categ
@inindex categorical data analysis
@inindex loglinear models
@inindex logit models

@noindent
@strong{Description}

The function @samp{loglin} fits the hierarchical
loglinear models specified by @var{model0} and @var{model1}
and compares them.
The first variable named in @var{variable-list} gives the
cell counts and must be of type double, the remainder give the classification
and must be strings.
The strings @var{model0} and @var{model1} consist of one or more space-separated
terms, each term of which is a @samp{*}-separated list of classification variables.
The model specified by @var{model1} must incorporate at least as many effects
as the one specified by @var{model0}.
If @var{model0} is the null string (not NULL),
then @var{model1} is compared to the saturated model.
The dataset @var{dataset} must be sorted according to
the partitioning variables and the classification
variables in the order listed in @var{variable-list}.
Further, if the input dataset is partitioned, the input data for each part
must have the same table layout and size.
The function @samp{loglin} creates the dataset @var{dataset}.llm
and calls function @samp{categ}, which creates the dataset
@var{dataset}.llm.cat, which contains the observed and fitted cell counts and
is copied back to @var{dataset}.llm.

The output in the @file{lst} file reports the estimate and asymptotic standard
error for each of the independent parameters of the model, using zero-sum
constraints to eliminate dependent parameters.

@noindent
@strong{Code fragment(s)}

@emph{Compare the models @samp{vic*pen def*vic} and @samp{def*pen vic*pen def*vic}
using counts in @samp{n}, which gives the cell counts for the three-way
table classified by @samp{def}, @samp{vic}, and @samp{pen}:}
@example
loglin("deathpen", "n def vic pen",
       "vic*pen def*vic", "def*pen vic*pen def*vic", "");
sort("deathpen.llm", "def vic _type_ pen", "");
table("deathpen.llm.srt", "def vic", "_type_ pen n", "s6.2 30", "");
@end example

@node Linear regression,Logistic regression,Categorical data analysis,Statistics functions
@section Linear regression

@noindent
@strong{SPECIFICATION}
@display
@strong{linreg(@var{dataset}, @var{y-variable-list}, @var{x0-variable-list}, @var{x1-variable-list}, @var{partvars}, @var{x-dataset}, @var{level})}
@var{dataset}, @var{y-variable-list}, @var{x0-variable-list}, @var{x1-variable-list}, @var{partvars}, @var{x-dataset:} string
@var{level:} double
@end display

@display
proc reg [data=@var{dataset-name}] [outest=@var{dataset-name}];
model @var{response-variables} = @var{explanatory-variables};
[var @var{variable-list};]
[add @var{variable-list};]
by @var{variable-list};
[plot @var{y-variable} * @var{x-variable};]

@end display

@inindex reg (SBS proc)

@noindent
@strong{Description}

Performs ordinary least squares linear regression for each variable in
@var{y-variable-list} as a function of all the variables in @var{x0-variable-list}
and @var{x1-variable-list}, computes t-tests on each parameter, and
and tests the full model against the model with just the variables in
@var{x0-variable-list}.
The model always includes an intercept term, which is named _intercept_
and is always included implicitly in @var{x0-variable-list}.

Results are displayed in the @file{lst} file.
In addition, for each of the specified values of the variables in
@var{x0-variable-list} and @var{x1-variable-list},
observed and predicted values and lower and upper confidence limits
for the mean at @var{level} for each of the variables in
@var{y-variables} are written to @var{dataset}.reg
in lines identified by the respective values
@samp{OBS}, @samp{PRED}, @samp{LOWER}, and @samp{UPPER} of the @samp{_type_} variable.
These values are given as the values of the @var{y-variables} in @var{dataset}.reg.
If @var{x-dataset} is non-null, specified values for the x-variables
are read from that dataset; otherwise, the values of the x-variables in
@var{dataset} are used.
Finally,
the estimates and covariance matrix are written to the file @var{dataset}.cov,
with the @samp{_type_} variable set to @samp{ESTIMATE} and
@samp{COVAR}, respectively, the @samp{_response_} variable indicating
the response variable and the @samp{_param1_}
and @samp{_param2_} variables indicating which parameters
identify the row and column, and the @samp{_cov_} variable containing the numerical value.

SBS note: If you include a @samp{plot} statement, then the model must contain
only one response and one explanatory variable. If there is an @samp{add}
statement, the model will be fit as originally specified and with the
additional variables and the change in R-squared will be reported.
The @samp{var} statement is ignored in any case.

@noindent
@strong{Code fragment(s)}

@emph{Perform linear regression of the response variable @samp{strength}
on the independent variables @samp{length} and @samp{thickness}, based
on the values in the dataset @file{wires}, and
compare the full model with the reduced model that contains the
intercept term only:}
@example
linreg("wires", "strength", "", "length thickness", "", NULL, 0.0);
@end example

@emph{Perform linear regression of the response variable @samp{strength}
on the independent variables @samp{length} and @samp{thickness}, based
on the values in the dataset @file{wires}, and
compare the full model with the reduced model that contains the
intercept term and @samp{length} only; also compute predicted values and
the endpoints of 95% confidence intervals for the mean of the response
for the values of @samp{length}
and @samp{thickness} in the dataset @file{steps}:}
@example
linreg("wires", "strength", "length", "thickness", "", "steps", 0.95);
@end example
@inindex linear regression
@inindex regression, linear

@node Logistic regression,Nonparametric analyses,Linear regression,Statistics functions
@section Logistic regression

@noindent
@strong{SPECIFICATION}
@display
@strong{logreg(@var{dataset}, @var{y-spec}, @var{x0-var-list}, @var{x1-var-list}, @var{partvars}, @var{x-dataset-name}, @var{level})}
@var{dataset}, @var{y-spec}, @var{x0-var-list}, @var{x1-var-list}, @var{partvars}, @var{x-dataset-name:} string
@var{level:} double
@end display

@display
proc logistic [data=@var{dataset-name}] [outest=@var{dataset-name}];
model @{@var{variable} | @var{events}/@var{trials}@} = @var{explanatory-variables};
by @var{variable-list};

@end display

@inindex logistic (SBS proc)
@inindex logistic regression
@inindex regression, logistic

@noindent
@strong{Description}

Performs logistic regression for the response variable in
@var{y-spec} as a function of all the variables in
@var{x0-var-list} and @var{x1-var-list},
and tests the full model against the model with just the variables in
@var{x0-var-list}.
The model always includes an intercept term, which is named
@samp{_intercept_} and is always included implicitly in
@var{x0-var-list}.
Variables in @var{y-spec}, @var{x0-var-list}, and @var{x1-var-list}
must be of type double.
Two forms for the response in @var{y-spec}
are available: @var{events-variable} / @var{trials-number},
in which @var{trials-number} is an explicit number (e.g., 1 for binary data),
and @var{events-variable} / @var{trials-variable},
in which @var{events-variable}
is a count of successes in the number of trials specified by @var{trials-variable}.

Results are displayed in the @file{lst} file.
In addition, for each of the specified values of the variables in
@var{x0-var-list} and @var{x1-var-list},
observed and predicted probabilities
and lower and upper confidence limits at
@var{level} for the probability that the @var{events-variable}
is 1 are written to @var{dataset}.lgr
in lines identified by the respective values
@samp{PRED}, @samp{LOWER}, and @samp{UPPER} of the @samp{_type_} variable.
These values are given as the values of the @var{events-variable} in @var{dataset}.lgr.
If @var{x-dataset-name}
is non-null, specified values for the x-variables
are read from that dataset; otherwise, the values of the x-variables in
@var{dataset} are used.
Finally,
the estimates and covariance matrix are written to the file @var{dataset}.cov,
with the @samp{_type_} variable set to @samp{ESTIMATE} and
@samp{COVAR}, respectively, the @samp{_param1_}
and @samp{_param2_} variables indicating which parameters
identify the row and column, and the @samp{_cov_} variable containing the numerical value.

SBS note: only binary response is allowed, although the
@var{events}/@var{trials} form
allows that to be expressed as the result of a binomial experiment.

@noindent
@strong{Code fragment(s)}

@emph{Perform logistic regression with the binomial response variable
@samp{heartdis}, with values from 0 to @samp{ncases} in each observation,
on the independent variable @samp{bloodpress}, based on the values in
the dataset @file{heartrisk}:}
@example
logreg("heartrisk", "heartdis / ncases",
                 "", "bloodpress", "", NULL, 0.0);
@end example

@emph{Perform logistic regression with the binomial response variable
@samp{larvae}, with values from 0 to 10 in each observation,
on the independent variable @samp{co2}, based on the values in
the dataset @file{biocontrol}; also computed predicted values and
the endpoints of 95% confidence intervals for the mean response:}
@example
logreg("biocontrol", "larvae / 10",
                 "", "co2", "", "biocontrol.mns", 0.95);
@end example

@node Nonparametric analyses,Statistics utilities,Logistic regression,Statistics functions
@section Nonparametric analyses

@noindent
@strong{SPECIFICATION}
@display
@strong{nonparam(@var{dataset}, @var{variable-list}, @var{partvars})}
@var{dataset}, @var{variable-list}, @var{partvars:} string
@end display

@display
proc npar1way [data=@var{dataset-name}];
class @var{class-variable};
var @var{variable-list};
by @var{variable-list};

@end display

@inindex npar1way (SBS proc)

@noindent
@strong{Description}

If @var{variable-list} contains the name of only one variable,
which must be of type double, then @samp{nonparam}
tests the Wilcoxon signed rank statistic on the values of that variable.
If @var{variable-list}
contains the names of two variables, then the first must be of type double
and the second must be of type string.
If the second variable has two levels, then
@samp{nonparam} tests the Wilcoxon rank sum statistic
and the Kolmogorov two-sample statistic of the values
of the first variable classified by the values of the second.
If the second variable has more than two levels, then
@samp{nonparam} tests the Kruskal-Wallis statistic of the values
of the first variable classified by the values of the second.
The input dataset does not need to be sorted.

SBS note: In @samp{proc npar1way}, the @samp{class} and @samp{var} statements are required
and the class variable must be of type string.

@noindent
@strong{Code fragment(s)}

@emph{For each distince value of @samp{sex},
perform a Wilcoxon signed rank test on the values of @samp{weightchange}:}
@example
nonparam("diettest", "weightchange", "sex");
@end example

@emph{Perform a Kuskal-Wallis test on the values of @samp{weightchange}
as classified by @samp{drug}:}
@example
nonparam("diettest", "weightchange drug", "");
@end example
@inindex nonparametric
@inindex distribution-free
@inindex Wilcoxon
@inindex Mann-Whitney-Wilcoxon
@inindex signed rank
@inindex Kolmogorov
@inindex empirical distribution function

@node Statistics utilities,,Nonparametric analyses,Statistics functions
@section Statistics utilities

@noindent
@strong{SPECIFICATION}
@display
@strong{estimate(@var{dataset}, @var{parameters}, @var{definitions}, @var{partvars})}
@var{dataset}, @var{parameters}, @var{definitions}, @var{partvars:} string
@end display
@inindex categ
@inindex estimate
@inindex categorical data analysis
@inindex loglinear models
@inindex logit models

@noindent
@strong{Description}

@samp{Estimate} prints the estimate and standard error for each of
the parameters defined in @var{definitions}, based on the estimates and covariance matrix
provided by the dataset @var{dataset} for the parameters named in the space-separated
list @var{parameters}.
@var{dataset} is typically the @samp{.cov} dataset output by a
function such as @samp{loglin}, @samp{categ}, @samp{linreg}, or @samp{logreg} and
must contain, in addition to the @samp{_type_} variable, variables named
@samp{_param1_}, @samp{_param2_}, and @samp{_cov_}: the first two are string variables
specifying the parameters by which the estimates and covariance matrix are indexed
and the last is the entry in the estimate vector or covariance matrix.
For the value @samp{ESTIMATE} of @samp{_type_}, the variable @samp{_param2_}
specifies the parameter. The value @samp{COVAR} of @samp{_type_} indicates that
the value of @samp{_cov_} is an entry in the covariance matrix.

The string @samp{definitions} is a space-separated list of equations of the form
@var{param} = @var{coefficient_1} @var{param_1} ... @var{coefficient_n} @var{param_n}, in which
@var{param_1} through @var{param_n} are the names of parameters whose
estimates and covariances appear in @var{dataset} or a previous definition
and each @var{coefficient} is a decimal number.
A @samp{+} is optional for positive coefficients.
@var{coefficient_1} may be omitted if it would be a @samp{+1}.

@noindent
@strong{Code fragment(s)}

@emph{Use the user-defined function @samp{expect} to fit and
test a saturated logit model for the 4 by 2 table with 4 rootstocks,
A, I, II, and U, and two levels of disease, 0 and 1.
@samp{param} is an array of 8 independent parameters based on the
identifiability constraints lambda_A + lambda_I + lambda_II + lambda_U = 0,
lambda_d0 + lambda_d1 = 0, and mu_A + mu_I + mu_II + mu_U = 0.
Finally use @samp{estimate} to define the missing parameter
mu_U and test the contrast diff_I_U = mu_I - mu_U:}
@example
double expect(double param[8], double class[2]);
categ("rootdisease", "_cell_ root disease", &expect, param,
      "mu lambda_A lambda_I lambda_II lambda_d0 mu_A mu_I mu_II", "", "");
estimate("rootdisease.cov", "mu_A mu_I mu_II",
       "mu_U = - mu_A - mu_I - mu_II diff_I_U = mu_I - mu_U", "");

@end example

@node Graphics functions, Utilities, Statistics functions, Top

@chapter Graphics functions

@menu
* Histogram:: histogram
* Normal probability plot:: normal
* Scatter plot or line graph:: plot
* Plotting means:: plotmeans
* Regression plots:: plotlinreg and plotlogreg
* Displaying the pictures:: port, land, nport, nland
@end menu

@node Histogram,Normal probability plot,,Graphics functions
@section Histogram

@noindent
@strong{SPECIFICATION}
@display
@strong{histogram(@var{dataset}, @var{variable-list}, @var{partvars}, @var{nbars}, @var{style}, @var{xfunct}, @var{nplots})}
@var{dataset}, @var{variable-list}, @var{partvars}, @var{style:} string
@var{nbars}, @var{nplots:} int
@var{xfunct:} pointer to function returning double
@var{Returns:} array of @samp{pict}
@end display
@inindex histogram
@inindex nport

@display
proc chart [data=@var{dataset-name}];
by @var{variable-list};
vbar @var{variable} / [freq=@var{variable}] [levels=@var{n}]
                  [axis=[@var{min}] @var{max}]
                  [type=freq | percent | pct];
@end display

@inindex chart (SBS proc)

@noindent
@strong{Description}

Constructs an array of @samp{pict} structures for
drawing (@pxref{Displaying the pictures})
separate histograms of the values of the first variable in
@var{variable-list}, weighted by the second variable, if present, in
@var{variable-list}, for each distinct set of values of
@var{partvars}.
The first variable name may be followed by a string, enclosed in back quotes (@samp{`}),
to be used instead of the variable name as the x-axis label.
Each histogram has @var{nbars} bars.
The string @var{style} is either the null string or
contains axis specifications as for @samp{pict_autoaxes} (@pxref{Axes})
and can optionally specify
@samp{EQUAL} or @samp{VARIABLE} width bars, each of which represents either the @samp{COUNT}
(only for equal width bars) or @samp{PERCENT} or @samp{FRACTION} of the observations.
If @var{style} contains the word @samp{MINX}, followed without a space by a number,
then the horizontal minimum point of the histogram(s) is that number. 
If @var{style} contains the word @samp{MAXX}, followed without a space by a number,
then the horizontal maximum point of the histogram(s) is that number. 
If @var{style} contains the word @samp{MAXY}, followed without a space by a number,
then the vertical maximum point of the histogram(s) is that number. 
If @var{style} contains the word @samp{ROUND},
then the right and left ends of the histogram are expanded,
if necessary, to make the width of the bars rounded to 1 digit.
The function pointed to by @var{xfunct} applies to the x-axis as in the description of
@samp{pict_autoaxes}.
The default is equal width bars of counts.
The integer @var{nplots}
must be at least as large as the number of parts created by
@var{partvars}.
The function @samp{histogram}
allocates an array of @samp{picts} for the histograms and axes, in which the
picts for all the plots come first, followed by an equal number of @samp{pict}s for the
corresponding axes, and returns the starting address of that array.

@noindent
@strong{Code fragment(s)}

@emph{Display a histogram, in portrait orientation with a surrounding
box, of 10 variable-width bars that show counts of
the values of @samp{height} in the dataset @file{people}:}
@example
nport(histogram("people", "height", "",
                          10, "VARIABLE ==", NULL, 1), 1, 1);
@end example

@emph{Display a histogram for each of 58 counties, on 58 pages in portrait orientation
with axes at (0, 0), of 25 equal-width bars extending from 0 to 84 that show counts of
the values of @samp{height} in the dataset @file{people}:}
@example
nport(histogram("people", "height", "county",
                          25, "MIN0 MAX84", NULL, 58), 58, 1);
@end example

@emph{Display a histogram for each of 58 counties, on 58 pages in portrait orientation
with axes at (0, 0), of 25 equal-width bars that show percentages of
the values of @samp{height} in the dataset @file{people}:}
@example
nport(histogram("people", "height", "county",
                          25, "PERCENT", NULL, 58), 58, 1);
@end example

@node Normal probability plot,Scatter plot or line graph,Histogram,Graphics functions
@section Normal probability plot

@noindent
@strong{SPECIFICATION}
@display
@strong{normal(@var{dataset}, @var{variable}, @var{partvars}, @var{nplots})}
@var{dataset}, @var{variable}, @var{partvars:} string
@var{nplots:} int
@var{Returns:} array of @samp{pict}
@end display
@inindex normal
@inindex normal probability plot
@inindex Shapiro-Wilk
@inindex q-q plot
@inindex nport

@noindent
@strong{Description}

If @var{nplots} is greater than 0, constructs an array of @samp{pict} structures for
drawing (@pxref{Displaying the pictures})
a q-q plot of the values of @var{variable}
for each part of @var{dataset} defined by the values of @var{partvars}.
If the number of values is at least 3 but no more than 2000, performs a Shapiro-Wilk test
for normality, the results of which are reported in the lst file and, if
@var{nplots} is greater than 0, in the caption of the @samp{pict}s.
Each q-q plot is prepared for display on a separate page.
The integer @var{nplots}
must be at least as large as the number of parts created by @var{partvars}.
The function @samp{normal}
allocates an array of @var{picts} for the plots and axes, in which all
the plots come first, and returns the address of that array.

@noindent
@strong{Code fragment(s)}

@emph{For each distinct value of @samp{block}, display a q-q plot
of the values of @samp{yield} and apply the
Shapiro-Wilk test for normality:}
@example
nport(normal("wheat", "yield", "block", 4), 4, 1);
@end example

@node Scatter plot or line graph,Plotting means,Normal probability plot,Graphics functions
@section Scatter plot or line graph

@noindent
@strong{SPECIFICATION}
@display
@strong{plot(@var{dataset}, @var{xyvar}, @var{partvars}, @var{style}, @var{xfunct}, @var{yfunct}, @var{nplots})}
@var{dataset}, @var{xyvar}, @var{partvars}, @var{style:} string
@var{xfunct}, @var{yfunct:} pointer to function returning double
@var{nplots:} int
@var{Returns:} array of @samp{pict}
@end display

@display
proc plot [data=@var{dataset-name}];
by @var{variable-list};
plot @var{y-variable} * @var{xvariable} [/ [box]];
[...
plot @var{y-variable} * @var{xvariable} [/ [box]];]
@end display

@inindex plot (SBS proc)
@inindex plot
@inindex scatter plot
@inindex line graph
@inindex nport

@noindent
@strong{Description}

For @var{dataset},
constructs an array of @samp{pict} structures for
plotting (@pxref{Displaying the pictures})
the points whose coordinates are in the two variables listed in @var{xyvar}.
Each of those variable names may be followed by a string, enclosed in back quotes,
to be used instead of the variable name as the axis label.
Points are plotted in the order that they appear in the dataset and therefore must be sorted
for a line graph.
The default type of graph is a scatter plot with circles marking the points.
To get a line graph, you must set the value of the @samp{pict_type}
field of the @samp{pict} to the string @samp{LINE};
see the description of the @samp{pict} structure.
If the first character of @var{style} is @samp{o}
and is not followed by an integer,
then the plots for the different values of the @var{partvars}
are all prepared to be displayed on the same pair of axes on the same page.
If the first character of @var{style} is @samp{o}
and is followed by an integer @var{n},
then the plots are overlayed in consecutive groups of size @var{n}.
Otherwise those plots are prepared to be displayed on different pages.
The remaining characters of @var{style}
and the functions @var{xfunct} and @var{yfunct}
are axis specifications as for @samp{pict_autoaxes} (@pxref{Axes}).
The integer @var{nplots}
must be at least as large as the number of groups created by
@var{partvars}.
The function
@samp{plot} allocates an array of @samp{pict}s for the plots and axes, in which all
the plots come first, and returns the address of that array.

@noindent
@strong{Code fragment(s)}

@emph{Display a scatter plot in portrait orientation
with @samp{height} on the horizontal
axis and @samp{weight} on the vertical axis:}
@example
nport(plot("people", "height weight", "", "", NULL, NULL, 1), 1, 1);
@end example

@emph{Overlay 4 scatter plots, one for each distinct value
of @samp{plot}, on one page in portrait orientation,
with @samp{fert} on the horizontal
axis and @samp{yield} on the vertical axis, and make the symbols
be open circles, filled-in circles, open squares, and filled-in
squares, respectively:}
@example
pict *p;

p = plot("wheat", "fert yield", "plot", "o", NULL, NULL, 4);
strcpy(p[0].pict_type, "CIRC");
strcpy(p[1].pict_type, "CIRC");
p[1].pict_fgray = 0.0;
strcpy(p[2].pict_type, "SQUA");
strcpy(p[3].pict_type, "SQUA");
p[3].pict_fgray = 0.0;
nport(p, 4, 4);
@end example

@emph{Display one boxed line graph per page in portrait orientation
for each of the 2 distinct values of @samp{species}
with @samp{time} on the horizontal
axis and @samp{logpop} on the vertical axis, with
the @samp{exp} function applied to the vertical coordinate labels:}
@example
pict *p;

p = plot("bacteria", "time logpop", "species",
                                     "==", NULL, &exp, 2);
strcpy(p[0].pict_type, "LINE");
strcpy(p[1].pict_type, "LINE");
nport(p, 2, 1);
@end example

@emph{Overlay 6 boxed scatter plots, one for each distinct value
of @samp{plot}, 3 per page on 2 pages in portrait orientation,
with @samp{fert} on the horizontal
axis and @samp{yield} on the vertical axis, and make the symbols
be open circles, open triangles, and open squares,
respectively, on each of the 2 pages:}
@example
pict *p;

p = plot("wheat", "fert yield", "plot variety",
                                     "o3 ==", NULL, NULL, 6);
strcpy(p[0].pict_type, "CIRC");
strcpy(p[1].pict_type, "TRIA");
strcpy(p[2].pict_type, "SQUA");
strcpy(p[3].pict_type, "CIRC");
strcpy(p[4].pict_type, "TRIA");
strcpy(p[5].pict_type, "SQUA");
nport(p, 6, 3);
@end example

@node Plotting means,Regression plots,Scatter plot or line graph,Graphics functions
@section Plotting means
@inindex mean
@inindex error bar
@inindex standard deviation
@inindex standard error
@inindex plot

@noindent
@strong{SPECIFICATION}
@display
@strong{plotmeans(@var{dataset}, @var{y-variable}, @var{x-variable}, @var{errorbars}, @var{style}, @var{partvars}, @var{noverlay})}
@var{dataset}, @var{y-variable}, @var{x-variable}, @var{errorbars}, @var{style}, @var{partvars:} string
@var{noverlay:} int
@var{Returns:} array of @samp{pict}
@end display
@inindex means
@inindex plotmeans
@inindex nport

@noindent
@strong{Description}

Constructs an array of @samp{pict} structures for
plotting (@pxref{Displaying the pictures})
the mean, with an error bar, of @var{y-variable} for each value of @var{x-variable}.
Both variables must be of type double and either or both may be followed by
a string, enclosed in back quotes,
to be used instead of the variable name as the axis label.
The height of the error bar above and below the mean
can be specified to be any statistic available for the @samp{means} function,
optionally multiplied by a scale factor, which follows the statistic name and
a space in @var{errorbars}.
The string @var{style} is as in @var{plot}, except that overlaying is controlled
by @var{plotmeans} and must not be specified in @var{style}.
If @var{partvars} is null (""), then the array of @samp{pict}s has two elements, the first for
the error bars and the second for the means.
If @var{partvars} is not null but @var{noverlay} is 1,
then the array of @samp{pict}s has those same two elements
for each part of the dataset and each plot is on a separate page.
If @var{partvars} is not null and @var{noverlay} is greater than 1,
then the array of @samp{pict}s has those same two elements
for each part of the dataset but the elements are linked so that @var{noverlay}
pictures appear on the same set of axes.
NOTE: this function creates the following datasets or overwrites them if they exist:
@var{dataset}.mns, @var{dataset}.err, and @var{dataset}.err.srt.

@noindent
@strong{Code fragment(s)}

@emph{For each distinct value of @samp{thickness}, compute
the mean and standard deviation of the values of @samp{strength}
and display on a single page in portrait orientation
the means with error bars extending the standard
deviation above and below the mean:}
@example
nport(plotmeans("wires", "strength", "thickness", "SD",
                                                 "", 0), 2, 2);
@end example

@emph{For each distinct value of @samp{thickness}, compute
the mean and standard error of the mean of the values of @samp{strength}
and display on a single page in portrait orientation
the means with error bars extending 1.96 times the standard
error of the mean above and below the mean:}
@example
nport(plotmeans("wires", "strength", "thickness", "SEM 1.96",
                                                 "", 0), 2, 2);
@end example

@emph{For each of 3 distinct values of @samp{metal} display
a separate page on which appears, for
each distinct value of @samp{thickness},
the means of @samp{strength} with error bars extending the standard
deviation above and below the mean:}
@example
nport(plotmeans("wires", "strength", "thickness", "SD",
                                                 "metal", 1), 6, 2);
@end example

@emph{For each of 3 distinct values of @samp{metal}, display
overlayed on a single page the means of @samp{strength}
for each distinct value of @samp{thickness},
with error bars extending the standard
deviation above and below the mean:}
@example
nport(plotmeans("wires", "strength", "thickness", "SD",
                                                 "metal", 3), 6, 6);
@end example

@node Regression plots,Displaying the pictures,Plotting means,Graphics functions
@section Regression plots

@noindent
@strong{SPECIFICATION}
@display
@strong{plotlinreg(@var{dataset}, @var{y-variable}, @var{x-variable}, @var{style}, @var{partvars}, @var{nparts}, @var{level})}
@var{dataset}, @var{y-variable}, @var{x-variable}, @var{style}, @var{partvars:} string
@var{nparts:} int
@var{level:} double
@var{Returns:} array of @samp{pict}
@end display
@inindex linear regression
@inindex regression, linear
@inindex plot

@noindent
@strong{Description}

Runs @var{linreg} on @var{dataset},
allocates an array of @samp{pict}s for the plots and axes for the plots
of the observed data the regression line, and the curves enclosing a
@var{level} confidence region for the predicted mean of
@var{y-variable}, and returns the address of the array of @samp{pict}s,
to be displayed
as @var{nparts} page(s) of 4 overlayed pictures each (@pxref{Displaying the pictures}).
Both @var{x-variable} and @var{y-variable} must be single variables and each
may be followed by an axis label enclosed in pairs of @samp{`}.
@var{dataset} must be partitioned by @var{partvars} into exactly @var{nparts} parts.
@var{style} may contain axis specifications as for @samp{pict_autoaxes}
(@pxref{Axes}).
NOTE: This function creates the following datasets or overwrites them if they exist:
@var{dataset}.mns, @var{dataset}.reg, and @var{dataset}.reg.srt.

@noindent
@strong{Code fragment(s)}

@emph{Display on one page a scatter plot of the data,
with @samp{thickness} on the horizontal
axis, which will be labeled @samp{Thickness},
and @samp{strength} on the vertical axis,
while will be labeled @samp{Strength}, and the regression line
and the curves defining a 95% confidence region for the predicted
means:}
@example
nport(plotlinreg("wires", "stren`Strength`", "thick`Thickness`",
                 "==", "", 1, 0.95), 4, 4);
@end example

@emph{For each of the 4 values of the variable @samp{plot},
display on a separate page a scatter plot of the data,
with @samp{salin} on the horizontal
axis and @samp{yield} on the vertical axis, the regression line,
and the curves defining a 95% confidence region for the predicted
means:}
@example
nport(plotlinreg("pist", "yld", "sal", "==", "plot", 4, 0.95), 16, 4);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{plotlogreg(@var{dataset}, @var{y-spec}, @var{x-variable}, @var{style}, @var{ngroups}, @var{partvars}, @var{nparts}, @var{level})}
@var{dataset}, @var{y-spec}, @var{x-variable}, @var{style}, @var{partvars:} string
@var{ngroups}, @var{nparts:} int
@var{level:} double
@var{Returns:} array of @samp{pict}
@end display
@inindex logistic regression
@inindex regression, logistic
@inindex plot

@noindent
@strong{Description}

Runs @var{logreg} on @var{dataset},
allocates an array of @samp{pict}s for the plots and axes for
plots the logistic regression curve and the curves enclosing a
@var{level} confidence region for the predicted expectation of
the response variable in
@var{y-spec}, and returns the starting address of the array of @samp{pict}s,
to be displayed
as @var{nparts} page(s) of 4 overlayed pictures each (@pxref{Displaying the pictures}).
Also plots the mean of the response variable in @var{y-spec} for the
@var{ngroups} groups of the observations.
The list @var{x-variable} must contain only one variable;
@var{y-spec} is as in @var{logreg}.
The response variable in @var{y-spec} and the variable in @var{x-variable}
may be followed by axis labels enclosed in @samp{`}.
@var{dataset} must be partitioned by @var{partvars} into exactly @var{nparts} parts.
@var{style} may contain axis specifications as for @samp{pict_autoaxes}
(@pxref{Axes}).
NOTE: This function creates the following datasets or overwrites them if
they exist: @var{dataset}.trl, @var{dataset}.trl.grp,
@var{dataset}.trl.grp.srt, @var{dataset}.trl.grp.srt.mns, @var{dataset}.mns,
@var{dataset}.lgr, and @var{dataset}.lgr.srt.

@noindent
@strong{Code fragment(s)}

@emph{Display on one page the mean success rate for each
of 5 consecutive groups of the data, ordered by @samp{lab},
and the logistic regression line,
and the curves defining a 95% confidence region for the predicted
fraction of success:}
@example
nport(plotlogreg("can", "rem`Remissions` / 1", "lab`Labeling index`",
                 "==", 5, "", 1, 0.95), 4, 4);
@end example

@emph{Display on one page the mean fraction of @samp{rem} per
@samp{case} for each
of 5 consecutive groups of the data, ordered by @samp{lab},
and the logistic regression line,
and the curves defining a 95% confidence region for the predicted
fraction of @samp{rem} per @samp{case}:}
@example
nport(plotlogreg("can", "rem/case", "lab", "==", 5, "", 1, 0.95),
      4, 4);
@end example

@emph{For each of the 3 values of the variable @samp{hosp},
display on a separate page the mean fraction of @samp{rem} per
@samp{case} for each
of 5 consecutive groups of the data, ordered by @samp{lab},
and the logistic regression line,
and the curves defining a 95% confidence region for the predicted
fraction of @samp{rem} per @samp{case}:}
@example
nport(plotlogreg("can", "rem/case", "lab", "==", 5, "hosp", 3, 0.95),
      12, 4);
@end example

@node Displaying the pictures,,Regression plots,Graphics functions
@section Displaying the pictures

@noindent
@strong{SPECIFICATION}
@display
@strong{nport(@var{p}, @var{nplots}, @var{nperpage})}
@strong{nland(@var{p}, @var{nplots}, @var{nperpage})}
@var{p:} array of @samp{pict}
@var{nplots}, @var{nperpage:} int
@end display

@inindex nport
@inindex nland

@noindent
@strong{Description}

Generates an @var{nplots} / @var{nperpage} page graphics output file,
in portrait or landscape orientation, from the @samp{pict} array pointed to by
@var{p} with a total of @var{nplots} plots, @var{nperpage} per page.
As shown above, the first argument of a call to @samp{nport} or
@samp{nland} is usually provided directly by the value returned
from a call to a graphics function such as @samp{plotlogreg}.

@noindent
@strong{Code fragment(s)}

@emph{Display the 8 @samp{pict}s of the array @samp{p} on
4 pages in portrait orientation, with 2 @samp{pict}s per page:}
@example
pict *p;

...
nport(p, 8, 2);
@end example

@emph{Display @samp{pict}s from @samp{plotlogreg} in portrait orientation:}
@example
nport(plotlogreg("can", "nrem/ncase", "lab", "==", 5, "", 1, 0.95),
      4, 4);
@end example

@emph{Display @samp{pict}s from @samp{plotlogreg} in landscape orientation:}
@example
nland(plotlogreg("can", "nrem/ncase", "lab", "==", 5, "", 1, 0.95),
      4, 4);
@end example
@inindex portrait
@inindex landscape
@inindex graphics
@inindex output, graphics
@inindex display

@node Utilities,Picture functions,Graphics functions,Top
@chapter Utilities: probability and miscellaneous functions

@menu
* Chi-squared distribution:: probchisq and chisqpoint
* F distribution:: probf and fpoint
* Normal distribution:: probz, zpoint, and varnorm
* t distribution:: probt and tpoint
* Uniform distribution:: varunif
* Miscellaneous functions::
@end menu

@node Chi-squared distribution,F distribution,,Utilities
@section Chi-squared distribution
@inindex chi-squared

@noindent
@strong{SPECIFICATION}
@display
@strong{probchisq(@var{c}, @var{df})}
@var{c:} double
@var{df:} int
@var{Returns:} double
@end display

@noindent
@strong{Description}

Returns the probability that a variable distributed as chi-squared with
@var{df} degrees of freedom has a value greater than @var{c}.

@noindent
@strong{Code fragment(s)}

@emph{Assign to @samp{p} the probability that a Chi-squared variable with 2
degrees of freedom will have a value exceeding 3.7:}
@example
double p;
p = probchisq(3.7, 2);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{chisqpoint(@var{p}, @var{df})}
@var{p:} double
@var{df:} int
@var{Returns:} double
@end display

@noindent
@strong{Description}

Returns the value that a variable that is distributed as chi-squared with
@var{df} degrees of freedom exceeds with probability @var{p}.

@noindent
@strong{Code fragment(s)}

@emph{Assign to @samp{c} the point that
a Chi-squared variable with 3 degrees of freedom
exceeds with probability 0.05:}
@example
double c;
c = chisqpoint(0.05, 3);
@end example

@node F distribution,Normal distribution,Chi-squared distribution,Utilities
@section F distribution
@inindex F distribution

@noindent
@strong{SPECIFICATION}
@display
@strong{probf(@var{f}, @var{numer-df}, @var{denom-df})}
@var{f:} double
@var{numer-df}, @var{denom-df:} int
@var{Returns:} double
@end display

@noindent
@strong{Description}

Returns the probability that a variable distributed as F with
@var{numer-df} and @var{denom-df} degrees of freedom has a value greater than @var{f}.

@noindent
@strong{Code fragment(s)}

@emph{Assign to @samp{p} the probability that an F variable with 4 and 2
degrees of freedom will have a value exceeding 5.8:}
@example
double p;
p = prob(5.8, 4, 2);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{fpoint(@var{p}, @var{numer-df}, @var{denom-df})}
@var{p:} double
@var{numer-df}, @var{denom-df:} int
@var{Returns:} double
@end display

@noindent
@strong{Description}

Returns the value that a variable that is distributed as F with
@var{numer-df} and @var{denom-df} degrees of freedom exceeds with probability @var{p}.

@noindent
@strong{Code fragment(s)}

@emph{Assign to @samp{f} the point
that an F variable with 4 and 2 degrees of freedom
exceeds with probability 0.05:}
@example
double f;
f = fpoint(0.05, 4, 2);
@end example

@node Normal distribution,t distribution,F distribution,Utilities
@section Normal distribution
@inindex normal
@inindex random

@noindent
@strong{SPECIFICATION}
@display
@strong{varnorm()}
@var{Returns:} double
@end display

@noindent
@strong{Description}

Repeated calls return values (pseudo) independently
sampled from a standard normal distribution.

@noindent
@strong{Code fragment(s)}

@emph{Assign to @samp{z} a value sampled from a standard normal distribution:}
@example
double z;
z = varnorm();
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{probz(@var{z})}
@var{z:} double
@var{Returns:} double
@end display

@noindent
@strong{Description}

Returns the probability that a standard normal variable
has a value no greater than @var{z}.

@noindent
@strong{Code fragment(s)}

@emph{Assign to @samp{p} the probability that a standard normal variable
will have a value not exceeding 1.645:}
@example
double p;
p = probz(1.645);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{zpoint(@var{p})}
@var{p:} double
@var{Returns:} double
@end display

@noindent
@strong{Description}

Returns the value that a standard normal variable
exceeds with probability @var{p}.

@noindent
@strong{Code fragment(s)}

@emph{Assign to @samp{z} the
that a standard normal variable
exceeds with probability 0.05:}
@example
double z;
z = zpoint(0.05);
@end example

@node t distribution,Uniform distribution,Normal distribution,Utilities
@section t distribution
@inindex t distribution
@inindex Student's t

@noindent
@strong{SPECIFICATION}
@display
@strong{probt(@var{t}, @var{df})}
@var{t:} double
@var{df:} int
@var{Returns:} double
@end display

@noindent
@strong{Description}

Returns the probability that a variable distributed as Student's t with
@var{df} degrees of freedom has a value greater than @var{t}.

@noindent
@strong{Code fragment(s)}

@emph{Assign to @samp{p} the probability that a t variable with 3
degrees of freedom will have a value exceeding 2.3:}
@example
double p;
p = probt(2.3, 3);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{tpoint(@var{p}, @var{df})}
@var{p:} double
@var{df:} int
@var{Returns:} double
@end display

@noindent
@strong{Description}

Returns the value that a variable that is distributed as Student's t with
@var{df} degrees of freedom exceeds with probability @var{p}.

@noindent
@strong{Code fragment(s)}

@emph{Assign to @samp{t} the point
that a t variable with 4 degrees of freedom
exceeds with probability 0.05:}
@example
double t;
t = tpoint(0.05, 4);
@end example

@node Uniform distribution,Miscellaneous functions,t distribution,Utilities
@section Uniform distribution
@inindex uniform distribution
@inindex random

@noindent
@strong{SPECIFICATION}
@display
@strong{varunif()}
@var{Returns:} double
@end display

@noindent
@strong{Description}

Repeated calls return values (pseudo) independently
sampled from a uniform [0, 1] distribution.

@noindent
@strong{Code fragment(s)}

@emph{Assign to @samp{u} a value sampled from a uniform [0, 1] distribution:}
@example
double u;
u = varunif();
@end example

@node Miscellaneous functions,,Uniform distribution,Utilities
@section Miscellaneous functions

@noindent
@strong{SPECIFICATION}
@display
@strong{dap_bincoeff(@var{n}, @var{r})}
@var{n}, @var{r:} double
@var{Returns:} double
@end display
@inindex binomial coefficient
@inindex combinations
@inindex choose

@noindent
@strong{Description}

Returns the binomial coefficient n C r.

@noindent
@strong{SPECIFICATION}
@display
@strong{dap_maximize(@var{f}, @var{nx}, @var{x}, @var{step}, @var{tol}, @var{trace})}
@var{f:} pointer to function returning double
@var{nx:} int
@var{x}, @var{step}, @var{tol:} double
@var{trace:} string
@var{Returns:} double
@end display
@inindex minimize
@inindex maximize
@inindex extreme value

@noindent
@strong{Description}

Maximizes (or attempts to maximize) the function @var{f}
of @var{nx} variables, starting with the input point @var{x}.
The function
@samp{dap_maximize} uses a simple hill-climbing algorithm, with
numerically approximated partial derivatives, starting with step-size
@var{step} and halving the step-size as necessary until it is less than
@var{tol}.
The string @var{trace} is either the null string (not @samp{NULL}) for no tracing,
or @samp{TRACE}, for continuous tracing, or
@samp{PAUSE}, for tracing and waiting for the user to press @key{Enter}
at each iteration.
Either @samp{TRACE} or @samp{PAUSE} may be followed, with no spaces, by a number
to specify how many steps should be taken before each trace or pause.
If convergence is not obtained in @samp{DAP_MAXITER}
steps @ref{Appendix I}, that failure is
reported before returning.

@noindent
@strong{Code fragment(s)}

@emph{Assign to @samp{max} the maximum value attained by the function
of 2 variables @samp{fun}, starting with the values stored in @samp{x},
with a step size of 0.01 and a tolerance in the independent variables
of 0.001:}
@example
double fun(double x[2]);
double max;
double x[2];

max = dap_maximize(&fun, 2, x, 0.01, 0.001, "");
@end example

@emph{Assign to @samp{max} the maximum value attained by the function
of 2 variables @samp{fun}, starting with the values stored in @samp{x},
with a step size of 0.01 and a tolerance in the independent variables
of 0.001 and display a trace of the iterations:}
@example
double fun(double x[2]);
double max;
double x[2];

max = dap_maximize(&fun, 2, x, 0.01, 0.001, "TRACE");
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{dap_numdate(@var{date})}
@var{date:} string
@var{Returns:} int
@end display
@inindex date

@noindent
@strong{Description}

With @var{date} a date on or after January 1, 1752,
in the form @samp{MMDDYYYY} or @samp{MM/DD/YYYY},
in which the @samp{MM} and the @samp{DD} in the latter form can consist
of a single digit,
returns the number of days since December 31, 1751, otherwise
returns -1.

@noindent
@strong{Code fragment(s)}

@emph{Assign to @samp{d} the number 72143,
i.e., the number of days that
July 9, 1949 is later than December 31, 1751:}
@example
int d;
d = dap_numdate("07091949");
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{dap_datenum(@var{n}, @var{date})}
@var{n:} int
@var{date:} string
@end display
@inindex date

@noindent
@strong{Description}

With @var{n} the number of days since December 31, 1751,
fills @var{date} with the date in the form @samp{MMDDYYYY}.
If @var{n} is not positive or is too large, @var{date} is
set to "?".

@noindent
@strong{Code fragment(s)}

@emph{Assign to @samp{date} the string "07021761",
i.e., the date 3471 days after December 31, 1751:}
@example
char date[9];
dap_datenum(3471, date);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{dap_invert(@var{matrix}, @var{rowscols})}
@var{matrix:} pointer to pointer to double
@var{rowscols:} int
@var{Returns:} int
@end display
@inindex matrix
@inindex invert

@noindent
@strong{Description}

Inverts the matrix, returns 1 if non-singular, 0 otherwise.
The parameter @var{matrix} is an array of pointers to double, each double pointed
to being the first element of an array of double.

@noindent
@strong{Code fragment(s)}

@example
double **mat;
int nonsing;
nonsing = dap_invert(mat, 3);
@end example

@node Picture functions,Examples,Utilities,Top
@chapter Picture functions

The most common use of the information in this chapter is to modify one or more
fields in the @samp{pict} structure, which is described in the first section
of this chapter, returned by a dap graphics function.
In addition, this chapter describes low-level picture functions.
Although these picture functions are not needed in most dap programs,
they are useful for constructing custom graphics.
The functions that add elements, shapes, or text to a picture must be followed
by a call to @samp{pict_show} to include those objects in the graphics output file.
Complex pictures with, for example, different fonts
for different pieces of text or different sized circles, may be constructed
in one of two ways: either link the parts of the picture
and call @samp{pict_show} once, on the head of the list, or call
@samp{pict_show} repeatedly, after assembling each of the parts of
the picture.

@menu
* Pict structure:: pict structure, pict_initpict, and pict_clearpict
* Axes:: pict_axes, pict_autoaxes, pict_maketick
* Elements:: pict_point, pict_line
* Shapes:: pict_circle, pict_rectangle, pict_hrect, pict_bhrect, pict_curve
* Text:: pict_text
* Transformations:: pict_translate, pict_rotate, pict_scale
* Graphics output file:: pict_port, pict_land, pict_init, pict_page, pict_show, pict_end
* Picture datasets:: pict_save, pict_rest
@end menu

@node Pict structure,Axes,,Picture functions
@section Pict structure and pict_init

Dap graphics functions return arrays of @samp{pict}.
@inindex pict structure
@inindex structure, pict
The @samp{pict} structure
contains the following fields that may be modified directly to change a picture.
Numerical values are in points (1/72 inch).

@noindent
@strong{pict_type:} string (4 letters)
@inindex type, picture
@inindex picture

This field must be one of the following strings:

@strong{LINE}
@quotation
Draw lines connecting successive points.
@end quotation
@inindex line graph

@strong{SEGM}
@quotation
Draw a separate segment for each successive pair of points.
@end quotation
@inindex segments
@inindex line segments

@strong{IBEA}
@quotation
Draw an I-beam for each successive pair of points.
If the horizontal coordinates of the pair of points are equal,
draw a vertical I-beam; if the vertical coordinates of the pair of points are equal,
draw a horizontal I-beam; otherwise, report the error and exit.
@end quotation
@inindex I-beam

@strong{CIRC}
@quotation
Draw each point as a circle.
@end quotation
@inindex scatter plot
@inindex points

@strong{SQUA}
@quotation
Draw each point as a square.
@end quotation
@inindex squares

@strong{TRIA}
@quotation
Draw each point as a triangle.
@end quotation
@inindex triangles

@strong{UTRI}
@quotation
Draw each point as a upside-down triangle.
@end quotation
@inindex triangles

@strong{DIAM}
@quotation
Draw each point as a diamond.
@end quotation
@inindex diamonds

@strong{PATT}
@quotation
At the position of each point, display the pattern pointed to by @var{pict_patt}.
@end quotation
@inindex patterns

@noindent
@strong{pict_dash:} double

The dash
@inindex dashing
@inindex broken lines
length for lines if @var{pict_dash} > 0.0;
the lines are not dashed if @var{pict_dash} = 0.0.
The default is 0.0.

@noindent
@strong{pict_font:} string (up to 63 letters)

A string specifying the font
@inindex font
for displayed text, if any.
The default is @samp{Helvetica-Bold}.

@noindent
@strong{pict_fs:} double

The font size
@inindex font size
@inindex size, font
for displayed text, if any.
The default is 12.0.

@noindent
@strong{pict_lw:} double

The width for lines.
@inindex line width
@inindex thickness, lines
@inindex width, lines
The default is 0.4.

@noindent
@strong{pict_r:} double
@inindex radius
@inindex size

The radius for circles and size for squares, triangles, upside-down triangles, and
diamonds.

@noindent
@strong{pict_lgray:} double

The gray level
@inindex gray level
@inindex darkness
@inindex line, darkness
for lines: 0.0 is completely black, 1.0 is completely white.
The default is 0.0.

@noindent
@strong{pict_fgray:} double
@inindex gray level
@inindex darkness
@inindex fill, darkness
@inindex solid areas, darkness

The gray level for fill:  if @var{pict_fgray} @math{<} 0.0, then don't fill areas;
if @var{pict_fgray} @math{\ge} 0.0, then fill areas, then draw the boundary lines.
The default is @math{-1.0}.

@noindent
@strong{pict_patt:} pointer to @samp{pict}
@inindex pattern

This field allows you to place a picture at each point: set
@var{pict_patt} to the address of the @samp{pict} to be displayed.

@noindent
@strong{pict_next:} pointer to @samp{pict}
@inindex pattern

This field allows you to link pictures to be displayed on the same page.

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_initpict(@var{prev}, @var{p})}
@var{prev}, @var{p:} pointer to @samp{pict}
@end display
@inindex pict, initialize
@inindex pict, link
@inindex initialize
@inindex link

@noindent
@strong{Description}

Initialize the @samp{pict} pointed to by @var{p},
linking the @samp{pict} pointed to by @var{prev} to it.
If @var{prev} is @samp{NULL}, then no @samp{pict} is linked to
@var{p}.

@noindent
@strong{Code fragment(s)}

@emph{Initialize the picture structures @samp{p[0]}
and @samp{p[1]} and link @samp{p[0]} to @samp{p[1]}:}
@example
pict p[2];

pict_initpict(NULL, p);
pict_initpict(p, p + 1);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_clearpict(@var{p})}
@var{p:} pointer to @samp{pict}
@end display
@inindex pict, clear

@noindent
@strong{Description}

Frees up internal memory space used by @var{p}: use
before calling @samp{pict_initpict} on @var{p} after
it has been used.
Does not free @var{p} itself.

@noindent
@strong{Code fragment(s)}

@emph{Free the internal memory space used by @samp{p}:}
@example
pict p;

pict_clearpict(&p);
@end example

@node Axes,Elements,Pict structure,Picture functions
@section Axes

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_axes(@var{p}, @var{minx}, @var{maxx}, @var{xticks}, @var{nxticks}, @var{miny}, @var{maxy}, @var{yticks}, @var{nyticks}, @var{axspec}, @var{bpos}, @var{lpos}, @var{tpos}, @var{rpos})}
@var{p:} pointer to @samp{pict}
@var{xticks}, @var{yticks:} array of @samp{tick}
@var{nxticks}, @var{nyticks:} int
@var{axspec:} string
@var{bpos}, @var{lpos}, @var{tpos}, @var{rpos:} double
@end display
@inindex axes
@inindex ticks

@noindent
@strong{Description}

Create axes in the @samp{pict} pointed to by @var{p}
with ticks along the x-axis specified by the array @var{xtick} of
@var{nxticks} @samp{tick}s
and ticks along the y-axis specified by the array @var{yticks} of
@var{nyticks} @samp{tick}s.
The ticks must be in order.
The last tick is used to label the axis and the numbers of ticks,
@var{nxticks} and @var{nyticks} do not include this last tick.
The string @var{axspec} is as for @var{pict_autoaxes}.
The doubles @var{bpos}, @var{lpos}, @var{tpos}, and @var{rpos}
are the positions of the bottom or only x-axis, the left or only y-axis,
the top x-axis (if any), and the right y-axis (if any).
The variables @var{minx}, @var{maxx}, @var{miny}, and @var{maxy}
give the endpoints of the axes.

@noindent
@strong{Code fragment(s)}

@emph{Creat axes in @samp{p} with 11 ticks on each of the
x- and y-axes as a box whose lower and upper edges are at
0.0 and 100.0, respectively, and whose left and right edges are at
-10.0 and 10.0, respectively, with ticks and numbers on all sides:}
@example
pict p;
tick xt[12], yt[12];

pict_axes(&p, xt, 12, yt, 12, "BB", 0.0, 100.0, -10.0, 10.0);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_autoaxes(@var{p}, @var{xlabel}, @var{ylabel}, @var{axspec}, @var{xfunct}, @var{yfunct}, @var{caption}, @var{autopos})}
@var{p:} array of @samp{pict}
@var{xlabel}, @var{ylabel}, @var{axspec}, @var{caption:} string
@var{xfunct}, @var{yfunct:} pointer to function returning double
@var{autopos:} int
@end display
@inindex axes
@inindex ticks
@inindex caption
@inindex title
@inindex autoaxes

@noindent
@strong{Description}

Create axes, as specified below, by
@var{axspec} for the linked list of @samp{pict}s whose head
is pointed to by @var{p} and whose tail is the @samp{pict} to contain the axes.
Unless otherwise specified,
the axes extend to the maximum and minimum values of
x and y in the entire linked list of @samp{pict}s (except the tail @samp{pict}),
but always include the origin.
Unless otherwise specified,
the function @var{pict_autoaxes} chooses an appropriate spacing for the ticks on both axes.
The x- and y-axes are labeled @var{xlabel} and @var{ylabel},
respectively, and the entire picture is captioned by @var{caption}.
The first part of the
string @var{axspec} consists of 0, 1, or 2 characters according to whether the default
is used for both axes, just the y-axis, or the axes are specified
as follows, respectively.
An axis specification is one of the characters
@samp{-}, @samp{+}, @samp{0}, @samp{n}, @samp{=},  or @samp{#},
which indicate that the axis should be placed: on the negative end of the other
axis; the positive end; at 0; not at all; or at both ends,
without or with markings on the positive end.
The default is @samp{0}.
The endpoints of the graph and the number of ticks in each direction may be specified
in @var{axspec} after the first part of the string
(and at least one space) as follows:
to set the minimum point on the x-axis to a number, say @samp{-3.6}, use
@samp{MINX-3.6} (no spaces). The maximum point on the x-axis and the minimum
and maximum points on the y-axis can be specified using @samp{MAXX},
@samp{MINY}, and @samp{MAXY} in the same way. To set the number of tick marks
on the x-axis to a number, say 14, use @samp{NXTICKS14} (no spaces).
The number of ticks on the y-axis can be set using @samp{NYTICKS} in the
same way.
The number of significant figures used for the labels on the ticks can
be specified using @samp{NXDIGITS} and @samp{NYDIGITS}, as in
@samp{NXDIGITS4}; the default is 3 digits.

The functions @var{xfunct} and @var{yfunct}
are applied to the true tick values to create the tick labels.
Either one or both may be @samp{NULL} to specify that the tick labels equal the tick values.
If @var{autopos} is @samp{PORTRAIT} or @samp{LANDSCAPE} (integer
values, not strings, defined in the header file), then
@var{apict_utoaxes} automatically scales and positions the plot appropriately.
No scaling and positioning is done if
@var{autopos} is 0.

@noindent
@strong{Code fragment(s)}

@emph{Create axes in the last @samp{pict} in the linked array
given by @samp{p} with the horizontal axis labeled "time",
the vertical axis labeled "CFU", the horizontal axis at the most
negative point the @samp{pict}s of @samp{p},
the vertical axis at @samp{time} = 0, the function
@samp{exp} used to display numerical tick values on the vertical axis,
the caption "CFU per cm^2^ surface area" (with the @samp{2} as a
superscript), scaled and placed appropriately on a page in portrait orientation:}
@example
pict *p;

pict_autoaxes(p, "time", "CFU", "-0", NULL, &exp,
                            "CFU per cm^2^ surface area", PORTRAIT);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_maketick(@var{thetick}, @var{position}, @var{label}, @var{length})}
@var{tick:} pointer to @samp{tick}
@var{position}, @var{length:} double
@var{label:} string
@end display
@inindex tick
@inindex axes

@noindent
@strong{Description}

Make the @samp{tick} pointed to by @var{thetick} be at coordinate @var{position}
with label @var{label} and of length @var{length}.

@noindent
@strong{Code fragment(s)}

@emph{Create in @samp{t} a tick with position 5.0, label "25.0", and length
3.0 points:}
@example
tick t;

pict_maketick(&t, 5.0, "25.0", 3.0);
@end example

@node Elements,Shapes,Axes,Picture functions
@section Elements

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_point(@var{p}, @var{x}, @var{y})}
@var{p:} pointer to @samp{pict}
@var{x}, @var{y:} double
@end display

@noindent
@strong{Description}

Add a point at (@var{x}, @var{y}) to the @samp{pict} pointed to by @var{p}.
Points added to the same @samp{pict} appear in the order in which they are added.

@noindent
@strong{Code fragment(s)}

@emph{Add a point at (7.2, -4.3) to @samp{p}:}
@example
pict p;

pict_point(&p, 7.2, -4.3);
@end example
@inindex point

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_line(@var{p}, @var{x1}, @var{y1}, @var{x2}, @var{y2})}
@var{p:} pointer to @samp{pict}
@var{x1}, @var{y1}, @var{x2}, @var{y2:} double
@end display
@inindex line

@noindent
@strong{Description}

Add a line from (@var{x1}, @var{y1}) to (@var{x2}, @var{y2})
to the @samp{pict} pointed to by @var{p}.
Lines added to the same @samp{pict} appear in the order in which they are added.

@noindent
@strong{Code fragment(s)}

@emph{Add a line from (7.2, -4.3) to (9.1, 2.6) to @samp{p}:}
@example
pict p;

pict_line(&p, 7.2, -4.3, 9.1, 2.6);
@end example

@node Shapes,Text,Elements,Picture functions
@section Shapes

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_circle(@var{p}, @var{x}, @var{y}, @var{r})}
@var{p:} pointer to @samp{pict}
@var{x}, @var{y}, @var{r:} double
@end display
@inindex circle

@noindent
@strong{Description}

Make the @samp{pict} pointed to by @var{p} a circle of radius
@var{r}, centered at (@var{x}, @var{y}).
NOTE: If a picture is to contain more than one circle,
then those circles must
be created in separate @samp{pict}s that are linked together.

@noindent
@strong{Code fragment(s)}

@emph{Add a circle with center (7.2, -4.3) and radius 3.0 to @samp{p}:}
@example
pict p;

pict_circle(&p, 7.2, -4.3, 3.0);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_rectangle(@var{p}, @var{x}, @var{y}, @var{xside}, @var{yside})}
@var{p:} pointer to @samp{pict}
@var{x}, @var{y}, @var{xside}, @var{yside:} double
@end display
@inindex rectangle
@inindex square

@noindent
@strong{Description}

Add a rectangle whose lower left corner is a (@var{x}, @var{y})
and has horizontal sides of length
@var{xside} and vertical sides of length @var{yside}
to the @samp{pict} pointed to by @var{p}.
NOTE: If a picture is to contain more than one rectangle but those
rectangles are not to be connected, then those rectangles must
be created in separate @samp{pict}s that are linked together.

@noindent
@strong{Code fragment(s)}

@emph{Add a rectangle with lower left corner (7.2, -4.3),
width 4.0, and height 4.5 to @samp{p}:}
@example
pict p;

pict_rectangle(&p, 7.2, -4.3, 4.0, 4.5)
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_hrect(@var{p}, @var{spacing}, @var{x}, @var{y}, @var{xside}, @var{yside})}
@strong{pict_bhrect(@var{p}, @var{spacing}, @var{x}, @var{y}, @var{xside}, @var{yside})}
@var{p:} pointer to @samp{pict}
@var{spacing}, @var{x}, @var{y}, @var{xside}, @var{yside:} double
@end display
@inindex rectangle
@inindex hash

@noindent
@strong{Description}

Add a forward-hashed (respectively, backward-hashed) rectangle whose lower left corner is at
(@var{x}, @var{y}) and has horizontal sides of length
@var{xside} and vertical sides of length @var{yside}
to the @samp{pict} pointed to by @var{p}.
The horizontal space between hash lines is @var{spacing}.
NOTE: If a picture is to contain more than one rectangle but those
rectangles are not to be connected, then those rectangles must
be created in separate @samp{pict}s that are linked together.

@noindent
@strong{Code fragment(s)}

@emph{Add a rectangle with lower left corner (3.5, 29.0),
width 1.0, height 5.0, and with hashes sloping upwards at a
spacing of 2.0 points to @samp{p}:}
@example
pict p;

pict_hrect(&p, 2.0, 3.5, 29.0, 1.0, 5.0);
@end example

@emph{Add a rectangle with lower left corner (3.5, 29.0),
width 1.0, height 5.0, and with hashes sloping downwards at a
spacing of 2.0 points to @samp{p}:}
@example
pict p;

pict_bhrect(&p, 2.0, 3.5, 29.0, 1.0, 5.0);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_curve(@var{p}, @var{x}, @var{y}, @var{t0}, @var{t1}, @var{nsegments})}
@var{p:} pointer to @samp{pict}
@var{x}, @var{y:} pointer to function returning double
@var{t0}, @var{t1:} double
@var{nsegments:} int
@end display
@inindex curve
@inindex graph

@noindent
@strong{Description}

Add a curve to the @samp{pict} pointed to by @var{p}.
The curve is parameterized by @var{x} and @var{y},
which point to functions that take a single
argument of type double and return a result of type double.
If @var{x} is @samp{NULL}, then that function is taken to be the identity function.
The parameter varies from @var{t0} to @var{t1}
in @var{nsegments} steps.
Curves (and lines and points) added to the same @samp{pict} are connected in
the order in which they are added.
NOTE: If a picture is to contain more than one curve but those
curves are not to be connected, then those curves must
be created in separate @samp{pict}s that are linked together.

@noindent
@strong{Code fragment(s)}

@emph{Add to @samp{p} a curve parameterized by
@samp{cos} and @samp{sin} with parameter running from
0.0 to 2.0 * 3.14159 in 100 steps:}
@example
pict p;

pict_curve(&p, &cos, &sin, 0.0, 2.0 * 3.14159, 100);
@end example

@emph{Add to @samp{p} a graph of @samp{exp}
running from 0.0 to 3.0 in the horizontal direction in 100 steps:}
@example
pict p;

pict_curve(&p, NULL, &exp, 0.0, 3.0, 100);
@end example

@node Text,Transformations,Shapes,Picture functions
@section Text

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_text(@var{p}, @var{text}, @var{x}, @var{y}, @var{angle}, @var{pos})}
@var{p:} pointer to @samp{pict}
@var{text}, @var{pos:} string
@var{x}, @var{y}, @var{angle:} double
@end display
@inindex text
@inindex words
@inindex font

@noindent
@strong{Description}

Add text @var{text} to the @samp{pict} pointed to by @var{p}.
The string @var{text} may contain substrings enclosed between pairs of
@samp{^} for superscripts and between pairs of @samp{|} for subscripts.
The string @var{text} may also contain newline characters (@samp{\n})
for multi-line text.
The string @var{pos} consists of either two or three letters that
specify the position of the point with coordinates
@var{x} and @var{y}
relative to the text, as follows.
The first character of @var{pos} is either @samp{l}, @samp{c}, or @samp{r},
for left, center, or right, respectively, and the
second letter is either @samp{t}, @samp{m}, or @samp{b},
for top, middle, or bottom, respectively.
If the optional third character of @var{pos}
is a space, then a blank rectangle is formed to hold the text.
The double @var{angle} is counter-clockwise rotation in degrees to be applied to text.

@noindent
@strong{Code fragment(s)}

@emph{Add to @samp{p} the text "cm^3^ of H|2|O" (with the
@samp{3} as a superscript and the @samp{2} as a subscript) placed
horizontally with its bottom center at the point
(306.0, 72.0):}
@example
pict p;

pict_text(&p, "cm^3^ of H|2|O", 306.0, 72.0, 0.0, "cb");
@end example

@node Transformations,Graphics output file,Text,Picture functions
@section Transformations

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_translate(@var{p}, @var{x}, @var{y})}
@var{p:} pointer to @samp{pict}
@var{x}, @var{y:} double
@end display
@inindex transform
@inindex translate
@inindex move
@inindex shift
@inindex raise
@inindex lower

@noindent
@strong{Description}

Translate (i.e., shift)
the @samp{pict} pointed to by @var{p} by @var{x} in the x-direction and
@var{y} in the y-direction.
If the @samp{pict} is linked to another @samp{pict}, then that @samp{pict} is translated the same
way, and so on until there are no more links.

@noindent
@strong{Code fragment(s)}

@emph{Translate all 4 pictures in the linked array
@samp{p} 306.0 points to the right and 72.0 points up:}
@example
pict p[4];

pict_translate(p, 306.0, 72.0);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_scale(@var{p}, @var{x}, @var{y}, @var{sx}, @var{sy})}
@var{p:} pointer to @samp{pict}
@var{x}, @var{y}, @var{sx}, @var{sy:} double
@end display
@inindex transform
@inindex scale
@inindex size
@inindex stretch
@inindex shrink
@inindex compress
@inindex expand

@noindent
@strong{Description}

Scale the @samp{pict} pointed to by @var{p} by @var{sx} in the x-direction and
@var{sy} in the y-direction, leaving the point at
(@var{x}, @var{y}) fixed.
If the @samp{pict} is linked to another @samp{pict}, then that @samp{pict} is scaled the same
way, and so on until there are no more links.

@noindent
@strong{Code fragment(s)}

@emph{Scale all 4 pictures in the linked array
@samp{p} by 1.5 in the horizontal direction
and 2.0 in the vertical direction,
relative to the fixed point (306.0, 72.0):}
@example
pict p[4];

pict_scale(p, 306.0, 72.0, 1.5, 2.0);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_rotate(@var{p}, @var{x}, @var{y}, @var{degrees})}
@var{p:} pointer to @samp{pict}
@var{x}, @var{y}, @var{degrees:} double
@end display
@inindex transform
@inindex rotate
@inindex turn

@noindent
@strong{Description}

Rotate the @samp{pict} pointed to by @var{p} counter-clockwise by
@var{degrees} around the point at (@var{x}, @var{y}).
If the @samp{pict} is linked to another @samp{pict}, then that @samp{pict} is rotated the same
way, and so on until there are no more links.

@noindent
@strong{Code fragment(s)}

@emph{Rotate all 4 pictures in the linked array
@samp{p} by 45.0 degrees counterclockwise
around the fixed point (306.0, 400.0):}
@example
pict p[4];

pict_rotate(p, 306.0, 400.0, 45.0);
@end example

@node Graphics output file,Picture datasets,Transformations,Picture functions
@section Graphics output file

A graphics output file must be started with a call to @samp{pict_init}
(or a function, such as @samp{pict_port}, that calls @samp{pict_init})
and ended with a call to @samp{pict_end}.

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_port(@var{npages})}
@strong{pict_land(@var{npages})}
@var{npages:} int
@end display
@inindex portrait
@inindex landscape
@inindex picture
@inindex orientation
@inindex graphics
@inindex output, graphics

@noindent
@strong{Description}

Calls @samp{pict_init} to set up @var{npages} portrait or landscape pages.

@noindent
@strong{Code fragment(s)}

@emph{Initialize a graphics output file for 3 pages in landscape orientation:}
@example
pict_land(3);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_init(@var{orient}, @var{bboxxl}, @var{bboxyb}, @var{bboxxr}, @var{bboxyt}, @var{npages})}
@var{orient}, @var{bboxxl}, @var{bboxyb}, @var{bboxxr}, @var{bboxyt}, @var{npages:} int
@end display
@inindex portrait
@inindex landscape
@inindex picture
@inindex orientation
@inindex graphics
@inindex output, graphics

@noindent
@strong{Description}

Initialize the graphics output file.
The character (not string)
@var{orient} is either @samp{l}, for landscape or @samp{p} for portrait.
The bounding box is specified by the @var{bbox}
parameters and the number of pages by @var{npages}.
@samp{pict_init} is called by @samp{pict_portrait} and @samp{pict_landscape}.

@noindent
@strong{Code fragment(s)}

@emph{Initialize a graphics output file for 4 pages in portrait orientation with
a bounding box with lower left corner (0, 0) and upper right corner
(612, 792):}
@example
pict_init(@samp{p}, 0, 0, 612, 792, 4);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_page()}
@end display
@inindex page

@noindent
@strong{Description}

Begin new page.

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_show(@var{p})}
@var{p:} pointer to @samp{pict}
@end display
@inindex show
@inindex display
@inindex picture

@noindent
@strong{Description}

Write the picture commands to display the @samp{pict} pointed to by
@var{p} into the graphics output file.
If @var{p}
is linked to another @samp{pict}, then show writes out the commands for that
pict and so on until there are no more links.

@noindent
@strong{Code fragment(s)}

@emph{Display the 4 @samp{pict}s in the linked array @samp{p}:}
@example
pict p[4];

pict_show(p);
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_end()}
@end display
@noindent
@inindex output, graphics
@inindex graphics

@noindent
@strong{Description}

Terminate the graphics output file.

@node Picture datasets,,Graphics output file,Picture functions
@section Picture datasets

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_save(@var{p}, @var{npicts}, @var{dataset})}
@var{p:} pointer to @samp{pict}
@var{npicts:} integer
@var{dataset:} string
@end display

@noindent
@strong{Description}

This function is useful for saving picture information generated
by graphics functions, such as @samp{plotlogreg}, that may require
lengthy execution times to generate pictures.
Saved picture datasets can be restored quickly by calling @samp{pict_rest}.

The function @samp{pict_save} saves the picture information
in the array of @samp{pict}s @var{p} to
the datasets @var{dataset}.picXXXX, @var{dataset}.ptsXXXX, and
@var{dataset}.txtXXXX, where @samp{XXXX} is the index of the @samp{pict}
in the array.
If @var{npicts} is 0, then @samp{pict_save} only saves the elements
of @samp{p} that are linked together, starting at the first element.
Otherwise, @samp{pict_save} saves @var{npicts} @samp{pict}s in the array.
NOTE: graphics functions, such as @samp{plot}, link an extra @samp{pict}
for each page or overlayed @samp{pict}s for the axes.

The following details are not needed for saving
@samp{pict} arrays generated by @samp{dap} graphics functions.
@samp{Pict_save} calls itself to save patterns,
if any, referenced in elements of @var{p}
using @var{dataset}.patXXXX as the @var{dataset} argument.
Patterns must be either single @samp{pict}s or linked arrays.
A link in the array @var{p} must always be to an element with an index
larger than the element linking to it. (This condition is always satisfied
by the @samp{pict} arrays generated by graphics functions.)

@noindent
@strong{Code fragment(s)}

@emph{Save the 4 @samp{pict}s in the linked array @samp{p} in a picture
datasets with base name @samp{picture}:}
@example
pict p[4];

pict_save(p, 0, "picture");
@end example

@emph{Save the 4 @samp{pict}s in the unlinked array @samp{p} in a picture
datasets with base name @samp{picture}:}
@example
pict p[4];

pict_save(p, 4, "picture");
@end example

@emph{Save the 10 @samp{pict}s created by @samp{plotlogreg} in a picture
datasets with base name @samp{grad}:}
@example
pict_save(plotlogreg("grad", "grad/1", "GPA", "==", 5, "year", 2, 0.95),
          10, "grad");
@end example

@noindent
@strong{SPECIFICATION}
@display
@strong{pict_rest( @var{dataset})}
@var{dataset:} string
@var{Returns:} pointer to @samp{pict}
@end display

@noindent
@strong{Description}

Allocates an array of @samp{pict}s and
restores into that array a picture saved
to @var{dataset} by @samp{pict_save}.

@noindent
@strong{Code fragment(s)}

@emph{Restore a picture from picture datasets with base
name @samp{picture} into the array array @samp{p}:}
@example
pict *p;

p = pict_rest("picture");
@end example

@emph{Restore and display a picture with 2 pages, created
by @samp{plotlogreg}, from picture datasets
with base name @samp{grad}:}
@example
nport(pict_rest("grad"), 8, 4);
@end example

@node Examples,Appendix I,Picture functions,Top
@chapter Examples

This chapter contains examples to illustrate the use
of dap. Data files, programs, and output for the examples
are provided in a directory named @file{examples}.

@menu
* Analysis of variance examples::
* Linear regression examples::
* Categorical data analysis examples::
* Logistic regression examples::
* Standard graphical output::
* Custom graphics::
@end menu

@node Analysis of variance examples,Linear regression examples,,Examples
@section Analysis of variance
@inindex analysis of variance
@inindex ANOVA

These examples are from:

@itemize
@item
AMD: Milliken, G.A. and Johnson, D.E. 1984.
Analysis of Messy Data.  Van Nostrand Reinhold: New York. 473pp.

@item
ED: Cochran, W.G. and Cox, G.M. 1957.
Experimental Designs.  John Wiley & Sons: New York. 611pp.

@end itemize

@example

/* AMD pp. 128 - 134: unbalanced layout using SBS  */

data;
 infile "amd128.dat" firstobs=2; /* space separated, skip 1 header line */
 length treat $ 6 block $ 6;
 input treat block y;

proc glm;
 class treat block;
 model y = treat block treat*block;
 lsmeans treat block / tukey;

@end example

@example
/* AMD pp. 249 - 251: using SBS
 * Two factors crossed, another nested within
 * levels of one crossed factor
 */

data; 
 infile "amd249.dat" firstobs=2;
 length a $ 1 b $ 1 c $ 1;
 input b c a y1 y2; /* two values per cell */
 y = y1;
 output;
 y = y2;
 output;

proc glm;
 class a b c;
 model y = a b a*b c*b a*c*b;
 test h=a e=a*b;
 test h=b e=a*b b*c a*b*c;
 test h=a*b e=a*b*c;
 test h=c*b e=a*c*b;

@end example

@example

/* AMD pp. 265 - 273 using SBS
 * Random model, unbalanced
 */

data;
 infile "amd265.dat" firstobs=2;
 length plant $ 1 site $ 1 worker $ 1;
 input plant worker site efficiency;

proc glm;
 class plant site worker;
 model efficiency = plant plant*worker plant*site plant*site*worker;
 test h=site*plant e=site*worker*plant;

proc glm;
 class plant site worker;
 model efficiency = plant plant*worker site*worker*plant;
 test h=worker*plant e=site*worker*plant;
 test h=plant e=worker*plant site*worker*plant;


@end example

@example

/* AMD pp. 285 - 289 using SBS
 * Mixed model, balanced
 */

data;
 infile "amd285.dat" firstobs=2;
 length machine $ 1 person $ 1;
 input machine person prod1 prod2 prod3; /* 3 observations per cell */
 productivity = prod1;
 output;
 productivity = prod2;
 output;
 productivity = prod3;
 output;

proc glm;
 class machine person;
 model productivity = machine person machine*person;
 test h=person e=machine*person;
 lsmeans machine / e=machine*person lsd;


@end example

@example

/* AMD pp. 290 - 295 using SBS
 * Mixed model, unbalanced
 */

data;
 infile "amd290.dat" firstobs=2;
 length machine $ 1 person $ 1;
 input machine person productivity;

proc glm;
 class machine person;
 model productivity = machine person machine*person;
 test h=person e=machine*person;
 lsmeans machine / e=machine*person lsd;


@end example

@example

/* AMD pp. 297 - 308 using SBS
 * Split plot
 */

data;
 infile "amd297.dat" firstobs=2;
 length fertilizer $ 1 block $ 1 variety $ 1;
 input block variety fertilizer yield;

proc glm;
 title "Whole plot (block, fertilizer) analysis";
 class fertilizer block variety;
 model yield = fertilizer block;
 lsmeans fertilizer / e=fertilizer*block LSD;

proc glm;
 title "Subplot (variety) analysis";
 class fertilizer block variety;
 model yield = fertilizer block variety
               fertilizer*block fertilizer*variety;


@end example

@example

/* ED pp. 122 - 125 using SBS
 * Latin square
 */

data;
 infile "ed122.dat" firstobs=2;
 length sampler $ 1 area $ 1 order $ 1;
 input order area sampler error;
  
proc glm;
 class sampler area order;
 model error = sampler area order;
 lsmeans sampler / lsd;

@end example

@example

/* ED pp. 176 using SBS and proc dap
 * Without covariate, with contrasts
 */

data muscle;
 infile "sas976.dat" dlm="\t" firstobs=3;
 length rep $ 1 time $ 1 current $ 1 number $ 1;
 input rep time current number y;

proc glm;
 class rep current time number;
 model y=rep current time number current*time current*number
         time*number current*time*number;
 contrast "curr 1 vs curr 2" current 1 -1;

/* To construct the constrast for testing "time in current 3",
 * we have to modify the muscle.srt.mns.con file produced by glm.
 */
proc dap;
@{ /* start with brace to enclose everything */
  inset("muscle.srt.mns.con")
   @{
     char rep[2], current[2], time[2];
     double y;
     char _type_[9]; /* N, MEAN, VAR, ERROR, CONTR, LSMEAN */
     int _term_; /* specifies term to which contrast applies */
     int more; /* to control stepping through dataset */
     double c1[4], c2[4], c3[4]; /* contrast with 3 df */
     outset("muscle.con", ""); /* datast for the F-test */
     /* set up the contrast coefficients */
     c1[0] = 1; c1[1] = 0; c1[2] = 0; c1[3] = -1;
     c2[0] = 0; c2[1] = 1; c2[2] = 0; c2[3] = -1;
     c3[0] = 0; c3[1] = 0; c3[2] = 1; c3[3] = -1;
     for (more = step(); more; )
      @{
        output(); /* N, MEAN, VAR */
        step();
        output();
        step();
        output();
        for (step(); strcmp(_type_, "CONTR"); step()) /* get to CONTR lines */
          output();
        _term_ = 4; /* bits: 1 is rep, 2 is current, 4 is time */
        if (!strcmp(current, "3")) /* only in current 3 */
         @{
           y = c1[time[0] - '1']; /* convert time to index */
           output();
           y = c2[time[0] - '1'];
           output();
           y = c3[time[0] - '1'];
           output();
         @}
        else
         @{
           y = 0.0;
           output();
           output();
           output();
         @}
        while (more && !strcmp(_type_, "CONTR")) /* look for the ones we want */
           more = step();
        while (more && !strcmp(_type_, "LSMEAN")) /* get to next cell or end */
         @{
           output();
           more = step();
         @}
      @}
   @}
  /* muscle.con only has time in numerator so don't need to specify it */
  ftest("muscle.con", "y rep current time number", "", "", "");
@}

@end example

@example

/* AMD pp. 173 - 177:
 * missing treatment combinations
 */

data amd173;
 infile "amd173.dat" firstobs=2;
 length treat $ 2 block $ 2;
 input treat block y;

proc sort data=amd173;
 by treat block;

proc means data=amd173 N MEAN VAR noprint;
 var y;
 by treat block;
 output out=amd173.mns;

/* Now we have to create "by hand" the .con files for
 * the custom F-tests for the contrasts that are meaningful
 * in the presence of empty cells.
 */
/* The first F-test (p. 175-76) is the interaction:
 * m11 - m13 - m21 + m23 = 0 and m21 - m22 - m31 + m32 = 0
 */
proc dap;
@{ /* start with a brace to enclose everything here */
  inset("amd173.mns") /* file from model statement */
   @{
     char treat[3], block[3]; /* we're in C here! */
     double y;
     char _type_[9]; /* set this to CONTR */
     int _term_;     /* bits specify the effect */
     double c1[7], c2[7]; /* coeffs of the contrasts */
     int c; /* cell number */
     outset("amd173.mns.con", "treat block y _term_");
     /* cells, in sort order, are:
     /*   11       13       21       22      23       31      32 */
     c1[0]=1;c1[1]=-1;c1[2]=-1;c1[3]= 0;c1[4]=1;c1[5]= 0;c1[6]=0;
     c2[0]=0;c2[1]= 0;c2[2]= 1;c2[3]=-1;c2[4]=0;c2[5]=-1;c2[6]=1;
     _term_ = 3; /* bit 1 for treat, bit 2 for block */
     for (c = 0; step(); c++) /* while there's another cell */
      @{
        output(); /* N, MEAN, VAR */
        step();
        output();
        step();
        output();
        strcpy(_type_, "CONTR");
        y = c1[c];
        output();
        y = c2[c];
        output();
      @}
   @}
  ftest("amd173.mns.con", "y treat block", "treat*block", "", "");

/* The second F-test (p. 176-77) is the treat effect:
 * m11 + m13 - m21 - m23 = 0 and m21 + m22 - m31 - m32 = 0
 */
  inset("amd173.mns") /* file from model statement */
   @{
     char treat[3], block[3]; /* we're in C here! */
     double y;
     char _type_[9]; /* set this to CONTR */
     int _term_;     /* bits specify the effect */
     double c1[7], c2[7]; /* coeffs of the contrasts */
     int c; /* cell number */
     outset("amd173.mns.con", "treat block y _term_");
     /* cells, in sort order, are:
     /*   11      13       21      22       23       31      32 */
     c1[0]=1;c1[1]=1;c1[2]=-1;c1[3]=0;c1[4]=-1;c1[5]= 0;c1[6]= 0;
     c2[0]=0;c2[1]=0;c2[2]= 1;c2[3]=1;c2[4]= 0;c2[5]=-1;c2[6]=-1;
     _term_ = 1; /* bit 1 for treat */
     for (c = 0; step(); c++) /* while there's another cell */
      @{
        output(); /* N, MEAN, VAR */
        step();
        output();
        step();
        output();
        strcpy(_type_, "CONTR");
        y = c1[c];
        output();
        y = c2[c];
        output();
      @}
   @}
  ftest("amd173.mns.con", "y treat block", "treat", "", "");
@}

@end example


@node Linear regression examples,Categorical data analysis examples,Analysis of variance examples,Examples
@section Linear regression
@inindex linear regression
@inindex regression, linear

@example
/* Bickel, P.J. and Doksum, K.A. 1977
 * Mathematical Statistics:
 * Basic Ideas and Selected Topics
 * Holden-Day: Oakland. 493.pp.
 * Example pp. 95 - 97.
 */

data;
  infile "ms95.dat" firstobs=2;
  input soilphos plantphos;

proc reg;
 model plantphos = soilphos;
 plot phantphos * soilphos;


@end example

@example
/* Rao, C.R. and Toutenberg, H. 1995 using SBS
 * Linear Models: Least Squares and Alternatives
 * Springer-Verlag: New York. 352 pp.
 * Example pp. 50 - 60.
 */

data;
  infile "lm50.dat" firstobs=2;
  input y x1 x2 x3 x4;

proc corr;
 var x1 x2 x3 x4 y;
 title "Correlations";

proc reg;
 model y = x4;
 title "Model building";

proc reg;
 model y = x4;
 add x1;

proc reg;
 model y = x4 x1;
 add x3;

proc reg;
 model y = x4 x1 x3;
 add x2;

@end example

@node Categorical data analysis examples,Logistic regression examples,Linear regression examples,Examples
@section Categorical data analysis
@inindex contingency table
@inindex cross classification
@inindex cross tabulation
@inindex chi-squared
@inindex Cochran-Mantel-Haenszel
@inindex ordinal
@inindex categorical data
@inindex binary

These examples are from CDA: Agresti, A.  1990.  Categorical Data Analysis.
John Wiley & Sons: New York.  558pp.

@example
/* CDA pp. 49 - 50 using SBS */

data;
 infile "cda50.dat" firstobs=2;
 length income $ 5 jobsat $ 10;
 input income jobsat count;

proc freq;
 tables income * jobsat / measures chisq expected
                          norow nocol nopercent;
 weight count;

@end example

@example
/* CDA pp. 232 - 233 using SBS */

data;
 infile "cda233.dat" firstobs=2;
 length penicillin $ 5 delay $ 4 response $ 5;
 input penicillin delay response count;

proc freq;
 tables penicillin * delay * response / norow nocol nopercent cmh;
 weight count;


@end example

@example
/* CDA pp. 135 - 138, 171 - 174, 176 - 177
 * Here we fit loglinear models in table 6.3 on p. 172
 */
#include <dap.h>

void main()
@{
  infile("cda171.dat", " ")
    @{
      char defendant[6], victim[6], penalty[4];
      double n;
      input("defendant victim penalty n");
      outset("cda171", "");
      skip(2);
      while (step())
        output();
    @}

  sort("cda171", "defendant victim penalty", "");

  title("(DV, P) vs (D, V, P)");
  loglin("cda171.srt", "n defendant victim penalty",
         "victim penalty defendant", "defendant*victim penalty", "");

  sort("cda171.srt.llm", "defendant victim _type_ penalty", "");
  table("cda171.srt.llm.srt", "defendant victim", "_type_ penalty n",
        "s6.2 30", "");
    
  title("(DV, VP) vs (DV, P)");
  loglin("cda171.srt", "n defendant victim penalty",
         "defendant*victim penalty",
         "defendant*victim victim*penalty", "");
  sort("cda171.srt.llm", "defendant victim _type_ penalty", "");
  table("cda171.srt.llm.srt", "defendant victim", "_type_ penalty n",
        "s6.2 30", "");
  
  title("(DV, DP, VP) vs (DV, VP)");
  loglin("cda171.srt", "n defendant victim penalty",
         "defendant*victim victim*penalty",
         "defendant*victim defendant*penalty victim*penalty", "");
  sort("cda171.srt.llm", "defendant victim _type_ penalty", "");
  table("cda171.srt.llm.srt", "defendant victim", "_type_ penalty n",
        "s6.2 30", "");
@}

@end example

@example

/* CDA pp. 261 - 269
 * Here we fit the logit model for linear-by-linear association
 * to Table 8.2 on page 268.
 */
#include <dap.h>

double expect(double param[8], double class[2]);

void main()
@{
  infile("cda262.dat", " ")
    @{
      char Income[6], JobSat[10];
      double income, jobsat, count;
      input("Income JobSat count");
      outset("cda262", "");
      skip(1);
      while (step()) 
        @{
          /* we have to convert to double for categ */
          if (!strcmp(Income, "<6"))
            income = 0.0;
          else if (!strcmp(Income, "6-15"))
            income = 1.0;
          else if (!strcmp(Income, "15-25"))
            income = 2.0;
          else if (!strcmp(Income, ">25"))
            income = 3.0;
          if (!strcmp(JobSat, "VeryDis"))
            jobsat = 0.0;
          else if (!strcmp(JobSat, "LittleDis"))
            jobsat = 1.0;
          else if (!strcmp(JobSat, "ModSat"))
            jobsat = 2.0;
          else if (!strcmp(JobSat, "VerySat"))
            jobsat = 3.0;
          output();
        @}
    @}

  @{
    double param[8];
    int p;

    param[0] = 1.0;
    for (p = 1; p < 8; p++)
      param[p] = 0.0;
    categ("cda262", "count income jobsat", &expect, param,
          "mu <6 6-15 15-25 VD LD MS ?Inc*Sat", "", "");
    sort("cda262.cat", "income _type_ jobsat", "");
    table("cda262.cat.srt", "income", "_type_ jobsat count", "6.2", "");
  @}
@}

/* We use an independent subset of the parameters in order to
 * incorporate the zero-sum constraints. Thus, if class[0] == 3,
 * for example, then we use the fact that lambda^@{income@}_@{>25@} is
 * minus the sum of the other lambda^@{income@} parameters.
 */
double expect(double param[8], double class[2])
@{
  double lx, ly;

  if (class[0] < 3.0)
    lx = param[1 + (int) class[0]];
  else
    lx = -(param[1] + param[2] + param[3]);
  if (class[1] < 3.0)
    ly = param[4 + (int) class[1]];
  else
    ly = -(param[4] + param[5] + param[6]);
  return exp(param[0] + lx + ly + param[7] * class[0] * class[1]);
@}

@end example

@node Logistic regression examples,Standard graphical output,Categorical data analysis examples,Examples
@section Logistic regression
@inindex logistic regression
@inindex regression, logistic

@example
/* Agresti, A.  1990.  Categorical Data Analysis.
 * John Wiley & Sons: New York.  558pp.
 * Example pp. 87 - 89 using SBS with proc dap
 */
data cda88;
  infile "cda88.dat" firstobs=2;
  input labind ncases nremiss;

proc dap;
nport(plotlogreg("cda88", "nremiss/ncases", "labind",
                 "== MAXX40 NXTICKS5 MAXY1 NYTICKS6 NYDIGITS2 NXDIGITS1",
                 5, "", 1, 0.95), 4, 4);


@end example

@node Standard graphical output,Custom graphics,Logistic regression examples,Examples
@section Standard graphical output

@example
/* Using plotmeans to plot means, both as symbols
 * and joined by lines, and 95% confidence intervals
 * of two groups of data together.
 */
#include <dap.h>

void main()
@{
infile("standard.dat", " ")
  @{
    int part;
    double x, y;

    input("x y part");
    outset("mtest", "");
    while (step())
      output();
  @}

title("Means of y. Error bars are 95% confidence for means");
  @{
    pict *p;

    sort("mtest", "part x", "");
    p = plotmeans("mtest.srt", "y", "x", "SEM 1.96", "part", 2);
/* p[0] and p[1] are error bars and means as points for group 1 */
    strcpy(p[1].pict_type, "TRIA");
/* p[2] and p[3] are error bars and means as points for group 2 */
    strcpy(p[3].pict_type, "SQUA");

    nport(p, 4, 4);
  @}
@}
@end example

@node Custom graphics,,Standard graphical output,Examples
@section Custom graphics

@example
/* This example illustrates the construction
 * of custom graphics.  We create two distributions
 * and display them as a split histogram: the bars
 * of one distribution extend horizontally to the
 * left and the bars of the other extend
 * horizontally to the right and are shaded.
 */
#include <dap.h>

#define NBARS 10

void main()
@{
 /* these variables are not in the datasets */
double min, max;  /* extremes of both
                   * distributions together
                   */
double width;     /* width of the bars */

infile("custom.dat", " ")
  @{
    double x;
    int part;
 
    input("x part");
    outset("split", "");
    while (step())
      output();
  @}

means("split", "x", "MIN MAX", ""); /* find min, max */
inset("split.mns")
  @{
    double x;
    int n;
    char _type_[9];

    for (n = 0; n < 2; n++)
      @{
        step();             /* and store them */
        if (!strcmp(_type_, "MIN"))
          min = x;
        else
          max = x;
      @}
  @}

width = (max - min) / ((double) NBARS);

inset("split")      /* compute class for each x */
  @{
    double x;
    int class;

    outset("class", "x class part");
    while (step())
      @{
        class = (int) floor((x - min) / width);
        if (class < 0)
          class = 0;
        else if (class > NBARS - 1)
          class = NBARS - 1;
        output();
      @}
  @}

sort("class", "part class", "");
/* compute counts in each class for each distribution */
means("class.srt", "count", "N", "part class");

  @{
  pict p[21];  /* one pict for each class for each part
                * plus one for the axes
                */
  int pn;

  pict_initpict(NULL, p);  /* initialize the pict structs */
  for (pn = 1; pn < 21; pn++)
    pict_initpict(p + pn - 1, p + pn);

  inset("class.srt.mns")
    @{
      int part, class;
      double classmin, count;

      while (step())
        @{
          classmin = min + width * ((double) class);
          /* make a rectangle */
          pict_rectangle(p + NBARS * part + class,
              0.0, classmin, (part ? count : -count), width);
          /* shade the ones on the right */
          if (part)
            p[NBARS * part + class].pict_fgray = 0.8;
        @}
    @}
  /* set up the axes */
  pict_autoaxes(p, "Count", "X", "==", &fabs, NULL,
                          "Split histogram", 1);
  /* and make it all appear */
  pict_port(1);
  pict_page();
  pict_show(p);
  pict_end();
  @}
@}
@end example

@node Appendix I,Appendix II,Examples,Top
@unnumbered Appendix I: Settable parameters

The following list of settable parameters and their
default values is in @file{dap.h}:
@inindex execution
@inindex parameters
@inindex constants
@inindex settable parameters

@example
/* Parameters for variables */
DAP_MAXVAR 256  /* max number of variables in a dataset */
                /* if changed to >= 10,000, change dimstr in dap0.c */
DAP_NAMELEN 15  /* max length of variable names (+1 for null) */
DAP_INTLEN 20  /* max number of char in char representation of int */
DAP_LISTLEN (256 * (16 + 6))
 /* max length of list of variables: dap_maxvar *
  * (max var name length + room for bracketed index)
  * This may not be entirely safe! (but most likely is)
  */
DAP_TOOLONG 10 /* max # times to print "string too long" message */
DAP_STRLEN 63  /* max length of some string values */

/* Parameters for tables */
DAP_MAXROWS 1024  /* max rows for table() */
DAP_MAXCOLS 64  /* max columns for table() */
DAP_MAXCLAB 128  /* max number of column labels */
DAP_MAXROWV 8  /* max number of row variables */
DAP_MAXCOLV 8  /* max number of column variables */
DAP_LABLEN 63  /* max number of non-null char in column label */

/* Parameters for datasets */
DAP_SETDIR "dap_sets"  /* where datasets are stored */
DAP_MAXVAL 32768  /* max number of values for some stat functions*/
DAP_MAXCELL 512  /* max number of cells in some internal tables */
DAP_MAXTREAT 9  /* max number of factors for ANOVA */

/* Parameters for grouping */
DAP_MAXBARS 128  /* max number of bars for histograms, grouping */
DAP_MAXLEV 96  /* max number of levels of a variable */

/* Parameters for I/O */
DAP_LINELEN 2047  /* max number of char for input line (+1 for null) */
DAP_OUTREPORT 100000
   /* report multiples of this number of lines written */

/* Parameters for graphics */
DAP_MAXPTS 16384  /* max number of points in a pict */
DAP_MAXCHAR 65536  /* max number of text chars in all the picts */
DAP_MAXNTXT 128  /* max number of text chars in a pict */
DAP_MAXTXT 127   /* max number of chars in a single string */
DAP_MAXFONT 63   /* max number of chars in a font name */

/* Parameters for numerical algorithms */
DAP_REDTOL 1e-9 /* to tell if row is zero in reduction */
DAP_ORTHTOL 1e-9 /* to tell if row is zero in orthog */
DAP_ZEROTOL 1e-6 /* to tell if row is zero in matrix ops */
DAP_TOL 1e-8    /* for pivoting, etc. in matrix ops */
DAP_CTOL 1e-6   /* for iterative reweighted least sq (logreg) */
DAP_KTOL 1e-6   /* for significance of Kolmogorov statistic */
DAP_PRTOL 1e-6  /* for inverse prob functs: should disappear */
DAP_ADDTOZERO 1e-8  /* for contingency tables */
DAP_MAXITER 500 /* max number of iterations */
DAP_MAXEX1 20  /* max number of values for exact test */
DAP_MAXEX2 20  /* max number of values for exact test */
DAP_CATTOL 0.0000005 /* tolerance for convergence in categ() */

/* Parameters for memory files */
DAP_NRFILES 128  /* number of files stored in memory */
DAP_RFILESIZE 16384  /* max number of bytes in a memory file */
DAP_MAXLINES 2048  /* max number of lines in memory file:
                    * keep at dap_rfilesize / 8
                    */
DAP_MAXMEM 1048576 /* memory buffer size for sorting */
DAP_TMPDIR "dap_tmp" /* directory for temporary files for sorting */

/* Memory allocation tracing */
DAP_MEMTRACE NULL  /* if non-NULL, print trace of malloc and free
                    * and if address = dap_memtrace, then...
                    */
DAP_MABORT 0  /* abort on malloc */
DAP_FABORT 0  /* abort on free */
@end example

@node Appendix II,Appendix III,Appendix I,Top
@unnumbered Appendix II: Essentials of C syntax

This appendix explains the most basic syntax of C needed for using dap.
There are many books to which you can refer for more detailed or
more advanced descriptions of C.
Note that the GNU editor @file{emacs} has special provisions for editing
C programs.

@menu
* Variables and operations::
* Functions::
* Loops and @samp{if}s::
@end menu

@node Variables and operations,Functions,Appendix II,Appendix II
@section Variables and operations

A @dfn{variable} is a box in which one or more numbers or characters,
or even more complicated objects called @dfn{structures}, are stored.
You @emph{must} use a @dfn{declaration}
@inindex variable
@inindex unknown variable
@inindex undeclared
@inindex declaration
to indicate exactly what kind of contents the box will hold and what
name you are going to use to refer to the box before you
use the box to store anything or else the computer won't know
what kind of information is stored in the box and how to use it.
(Names must contain only letters and numbers and @samp{_} and
must not start with a number.)
For example,

@example
int n;
@end example
@noindent
is a declaration that
indicates that the box named @samp{n} will hold an integer
@inindex int
(whole number).
Non-integer numbers, such as @samp{2.718}, are referred to as
@dfn{double precision floating point} numbers, or simply as
@dfn{doubles}.
@inindex double
For example,

@example
double x;
@end example
@noindent
is a declaration that
indicates that the box named @samp{x} will hold a double.
There is a special value called @dfn{NaN},
@inindex NaN
which stands for @dfn{Not-a-Number}, for undefined values
of a double.

Numbers and characters and structures can each be grouped into
ordered collections known as @dfn{arrays};
@inindex array
arrays of characters
are called @dfn{strings}.
@inindex string
For example, the declaration

@example
char employee[21];
@end example
@noindent
indicates that the box named @samp{employee} will hold a
string of 21 characters, say, the employee's name.
The last character of a string of characters is usually used to hold
a special character that marks the end of the string, so that @samp{employee}
will really be limited to 20 ordinary characters.
The character that marks the end of a string is called the
@dfn{null character} and is denoted @samp{\0}.

You can also declare, for example,

@example
double y[3];
@end example
@noindent
to indicate a box that will hold 3 doubles.
Brackets @samp{[} and @samp{]} also allow you to
refer to the individual doubles in the array: the three elements
of @samp{y} are @samp{y[0]}, @samp{y[1]}, and @samp{y[2]}.
(The numbering of array elements always starts at 0.)
Such referencing can be used for arrays of characters, integers, or
structures, too.

The most common kind of structure in dap is the @samp{pict} structure,
which contains graphical information that
is used by graphics functions; @samp{pict}s are
most often collected into arrays.
In some cases you may not know for certain or care how many
@samp{pict} structures are in the array, in which case you can use
a declaration like this:

@example
pict *p;
@end example
@noindent
which indicates that the graphics function that sets up the
array of picts to be stored in
the box named @samp{p} will allow for however
many picts that graphics function needs.
In this case, @samp{p} is usually referred to as a @dfn{pointer}
@inindex pointer
to @samp{pict}, and in that sense, @samp{p}
is interpreted as the location in the computer's memory
of the first @samp{pict} in the array.
Nevertheless, you can still refer to the @samp{pict}s in the
array as @samp{p[0]}, @samp{p[1]}, etc.

The pointer
@inindex pointer
concept, as a location in the computer's memory,
is used in other contexts, too.
One use is to be able to distinguish between
a string that has no interesting characters in it, that is,
a string whose first character is the null character, and
a string that doesn't exist at all.
The former is called a @dfn{null string},
@inindex null string
@inindex string, null
and is denoted @samp{""},
and the latter is called a @dfn{null pointer}, and is
denoted @samp{NULL}.
@inindex NULL
Another use of pointers
involves functions, which are described in the next section.
Functions have locations in the computer's memory and can be referred to by
pointers: if @samp{f} is a function, then @samp{&f} is a pointer
to that function.

There are many operations that can be used on variables, but the most common
operations are copying and arithmetic operations.  For example, the
@dfn{statement}

@example
x = y + z;
@end example
@noindent
computes the sum of the numbers in the boxes named @samp{y} and @samp{z}
and copies that sum into the box named @samp{x}; note that the contents
of @samp{y} and @samp{z} are unchanged.  Note that the paradoxical-looking
statement

@example
x = -x;
@end example
@noindent
says to copy the negation of the contents of @samp{x} back into @samp{x}.
Copying strings is more complicated and is described in the
next section.

Two very common arithmetic
operations that can be used only on @samp{int} variables
are @samp{++}, @samp{--}:  For example, the statement

@example
n++;
@end example
@noindent
increments, i.e., increases by 1, the number stored in @samp{n}.
Similarly,

@example
n--;
@end example
@noindent
decrements, i.e., decreases by 1, the number stored in @samp{n}.

@node Functions,Loops and @samp{if}s,Variables and operations,Appendix II
@section Functions

@dfn{Functions} are program parts that are usually stored in @dfn{libraries}
and can be used from a program.  For example, a dap program could contain
the statement

@example
means("data", "x", "SUM", "");
@end example
@noindent
which @dfn{calls}, i.e., uses,
the function @samp{means}, which is stored in a library
that is supplied with dap, to compute the sum of the values of the
variable @samp{x} in the dataset @samp{data}.  The comma-separated,
quoted strings @samp{"data"}, @samp{"x"}, @samp{"SUM"}, and @samp{""}
are called @dfn{arguments} to the function and they tell the function
what to operate on and how.  This particular function will create
a dataset named @samp{data.mns} that will contain the computed sum.

Two functions that are not supplied with dap but that are available
nonetheless in the standard C library and that are commonly used in dap programs are
@samp{strcpy}
@inindex strcpy
@inindex copying strings
@inindex strings, copying
and @samp{strcmp}.  The first is used for copying strings and
the second is used for comparing strings.
For example, following the declaration

@example
char employee[21];
@end example
@noindent
you could write the statement

@example
strcpy(employee, "Bassein, Susan");
@end example
@noindent
which calls the @samp{strcpy} function
to copy the 14 characters between the quotes into the
string @samp{employee} and follow it with the null character, for a total
of 15 characters.
NOTE: An explicit string of characters must be enclosed in double quotes
@inindex quotes
("..."), not single quotes ('...').
WARNING: Serious program bugs
@inindex bug
can be caused by copying more characters
into a string than are allotted in the declaration!

The @samp{strcmp}
@inindex strcmp
@inindex comparing strings
@inindex strings, comparing
function is typically used in loops and
@samp{if}s and is described in the next section.

Functions can also @dfn{return a value}, which means that the function
can provide a value that can be copied into a variable.
For example, after the declaration

@example
int more;
@end example
@noindent
you could write

@example
more = step();
@end example

This statement calls the function @samp{step},
which attempts to read one line from the input data file or
dataset and then returns the integer 1 or 0, if there was or was not,
respectively, another line to be read from the file or dataset. 
(Note that although @samp{step} does not require any arguments, the
parentheses are still necessary, to identify it as a call to a function.)
Thus, @samp{more} would contain the value 1 if @samp{step} successfully read
another line or the value 0 if the previous call to @samp{step} had read
the last line in the input data file or dataset.

You can also define functions in your program.  In particular, @samp{main}
@inindex main
is a function that must appear in every dap program.  The @dfn{body} of
the definition of a function must always be enclosed between @samp{@{}
and @samp{@}}.
The example program cda262.c (@pxref{Categorical data analysis examples})
illustrates the definition and use of a function required by
the categorical data analysis function @samp{categ}
to compute expected cell frequencies from parameter values.

@node Loops and @samp{if}s, ,Functions,Appendix II
@section Loops and @samp{if}s

@dfn{Loops} allow an action to be repeated, either until some condition
arises or for a fixed number of times.  The most common loop in dap
programs looks like this (with possible enhancements):

@example
while (step())
  output();
@end example
@noindent
This loop repeats reading a line from the input data file or dataset
and writing the data to the output dataset until
there are no more lines to be read.
More specifically, it attempts to read a line and
if there was a line to be read, it writes the data to the output dataset and
attempts to read the next line; otherwise it
@dfn{breaks out of the loop} and continues to the next line of the program.
Note that a value of 1 (or, in fact, any non-zero value) is taken to mean
@dfn{TRUE} and a value of 0 is taken to mean @dfn{FALSE}, so that these lines
can be interpreted as saying, "While (i.e., as long as)
it is TRUE that step has read another
line, output the data from that line".

A @samp{for} loop can be used
to read, say, the first 100 lines of the input data file or dataset:

@example
int n;

for (n = 1; n <= 100; n++)
  @{
    step();
    output();
  @}
@end example
@noindent
The @samp{for} statement has three parts within the parentheses, separated by semi-colons:
the @dfn{initialization}, @samp{n = 1}, which starts the loop; the
@dfn{test}, @samp{n <= 100}, which acts as though it is inside the parentheses
in a @samp{while} statement; and the @dfn{increment}, @samp{n++}, which gets
performed after each repetition of the body of the @samp{for} loop.
(Note that the body of the @samp{for} in this case must be enclosed between
@samp{@{} and @samp{@}} because, unlike the body of the @samp{while} above, it
contains more than one statement.)

The previous example will fail if there are fewer than 100 lines in the input
data file or dataset because @samp{step} will stop your program if you try
to read another line of the input data file or dataset
after a previous call to @samp{step} has returned a 0.
One better alternative would be to use an
@samp{if}:

@example
int n;

for (n = 1; n <= 100; n++)
  @{
    if (step())
      output();
    else
      break;
  @}
@end example
@noindent
In this example, the @samp{break} causes the program to break out of the loop
when @samp{step} returns a 0.

Suppose you wanted to write into the output dataset
all the lines from the input data file
for which the @samp{employee} was named "Bassein, Susan".
You could use the
@dfn{logical negation} operator @samp{!} with the string comparison function
@samp{strcmp}
@inindex strcmp
@inindex comparing strings
@inindex strings, comparing
as follows:

@example
char employee[21];

while (step())
  @{
    if (!strcmp(employee, "Bassein, Susan"))
      output();
  @}
@end example
@noindent
because @samp{strcmp} returns 0 if the strings are the
same and a non-zero number otherwise and @samp{!} turns a 0 into a 1
and a non-zero integer into 0.

The C language provides two operators that allow you to combine conditions
to be tested in @samp{while}, @samp{for}, and @samp{if} statements:
logical @dfn{and}, @samp{&&}, and logical @dfn{or}, @samp{||}.
For example, the previous code could be modified to select only those
records for "Bassein, Susan" that had a value greater than or
equal to 10 for a variable named @samp{hours}:

@example
char employee[21];
double hours;

while (step())
  @{
    if (!strcmp(employee, "Bassein, Susan") && hours >= 10.0)
      output();
  @}
@end example

@node Appendix III,Appendix IV,Appendix II,Top
@unnumbered Appendix III: Troubleshooting
@inindex bug
@inindex troubleshooting

Many things can go wrong with a program.
At the simplest level, there can be an error in @dfn{syntax},
@inindex syntax
which would cause the preprocessor or the compiler to be unable
to interpret what is meant by a statement.
For example, a syntax error commonly made by novices is to
forget to include the semi-colon
@inindex semi-colon
that is required at the end
of every declaration or statement.
Another common error is to have a left brace @samp{@{} without a
matching right brace @samp{@}} (or vice versa);
using appropriate indentation in your program and the features
of your text editor will help you find
unmatched braces.
If your program has a syntax error,
you will get a message indicating the line number
of the statement containing
the error and why the preprocessor or the compiler
couldn't interpret that statement.
(Missing semi-colons often confuse the compiler so badly
that the error message can be hard to interpret.)
In that case, you simply edit your program to correct the error
and compile and run it again.

If your program uses too many variables, lines that are too long, 
variable names or strings that are too long, etc., then you will
get a message that indicates the problem during execution.
You can solve that problem by setting the value of the appropriate
parameter
@inindex settable parameters
as described in @ref{Reading files and datasets}.

More serious bugs will result in the program @dfn{crashing}, which
means that the program will stop before completing
its task, often with no output of any sort.
In that case, the system will produce a file named @file{core}, which
is a snapshot of what point the program reached when it crashed.
If that happens, exit dap and use a @dfn{debugger} to examine the
core file.  For example, to use the GNU debugger @file{gdb} on the
core file produced by a crash in prog.c, you would type

@example
gdb prog.dap core
@end example
@noindent
Then, typing

@example
where
@end example
@noindent
will tell you the number of the line reached by your program,
and the functions that it called, when the program crashed.
A debugger is a powerful and somewhat complicated program; you should
read at least some of its documentation before you use it.

If a program doesn't crash but still doesn't produce output, most probably
it is executing in an @dfn{infinite loop}, that is, a loop whose condition
for terminating is never met.  Such a situation is particularly
dangerous if there is a call to @samp{output} in tha loop, so that
more and more lines are being written to the output dataset, which therefore
runs the risk of completely filling up your disk.
You can terminate
@inindex terminate
@inindex abort
@inindex stop
a program by typing @dfn{control-C} (@emph{twice}, if you are using the
Emacs interface) which means pressing both the
@kbd{Control} (or @kbd{Ctrl}) key and the @kbd{C} key at the same time.

Still more serious bugs will result in the program giving nonsense
results.
Often, you can track down such bugs by inserting calls
to the dap @samp{print} function at strategic points
in your program, and running the program again,
to display intermediate files to see where the program started
to have problems.
If that fails, a debugger is a good tool for tracking down
unintended values of your variables.

The most serious bugs will result in the program giving sensible-looking
but wrong results.
To catch bugs of that sort requires a thorough understanding of
approximately what your results should look like, some experience
with the statistical functions you are using, and a lot of patience.

@node Appendix IV,FAQ,Appendix III,Top
@unnumbered Appendix IV: SBS

@inindex SBS syntax
@inindex dap (SBS proc)
This section contains miscellaneous notes and warnings regarding
the use of SBS.
@strong{WARNING}:
When processing @var{file}.sbs, dap writes (or overwrites)
the file @var{file}.c. Note that because the syntax
and options of SBS and dap graphics procedures are not very compatible,
many dap graphics options are not available in SBS (which is one reason
that I wrote dap in the first place); for complete access
to dap graphics options (or statistical options) from SBS,
use a @samp{proc dap} statement (see below).
In addition, you can define your own functions in a separate @samp{.c} file
that you include on the command line to run dap. (To declare such functions
in the @samp{.sbs} file, use a @samp{proc dap} statement at the beginning
of the file.)
Note that if the program does not use a graphics proc,
compiling will produce a number of warnings about unused variables, all of whose
names begin and end with an underscore @samp{_}; you may ignore them.

One peculiarity that SBS inherits from C through dap
is that character variables that are explicitly
used in a data step always need to appear in a @samp{length} statement,
no matter whether the data step gets its data from a
@samp{set}, a @samp{merge} or an @samp{infile} statement.

Important notes regarding data steps (at least through this version of dap):

@enumerate
@item
Comparison, assignment, and concatenation of strings must be performed
using the C functions @samp{strcmp} (or its variants),
@samp{strcpy} (or its variants), and @samp{strcat} (or its variants);

@item
C-style subscripting (i.e., with @samp{[ ]}) must be used for obtaining
individual characters from a string except that in SBS, array indexes start at
1, not 0 as in C.

@item
Mnemonics are not accepted for relational or logical operators (e.g., @samp{ne}
is not accepted for @samp{^=});

@item
The only statements accepted in the body of a data step, other than numerical
assignment statements, are @samp{if-then}, @samp{if-then-else},
@samp{do}, @samp{do while}, @samp{end}, and @samp{output};

@item
@var{first}.variable is allowed by @samp{by} groups, but not @var{last}.variable.

@item
Syntax errors in the body of a data step may not be caught by the SBS-to-dap
translator, but will subsequently be caught by either the dap preprocessor
or the C compiler. However, the line numbers referred to by those programs will
be the line numbers of the dap program into which your SBS program was translated,
which you can view by opening up file @var{file}.c if you ran dap on @var{file}.sbs.

@end enumerate

@inindex data step (SBS)

@display
data [@var{output-file-name} [(@{drop | keep@}=@var{variable} [... @var{variable}])];
length @var{variable-1} $ @var{length-1} [... @var{variable-n} $ @var{length-n}];
infile "@var{infile-name}" [@{delimiter | dlm@}="@var{delimeter}"]
                       [firstobs=@var{n}];
input @var{variable-1} [@var{start-col-1} [-@var{end-col-1}]]
      [... @var{variable-n} [@var{start-col-n} [-@var{end-col-n}]]];
set @var{dataset-name};
merge @var{dataset-name-1} [(@{drop | keep@}=@var{variable} [... @var{variable}])]
     @var{dataset-name-2} [(@{drop | keep@}=@var{variable} [... @var{variable}])];
by @var{variable-list};
@{drop | keep@} @var{variable-list};

@end display

@quotation
SBS note: for column input, it is not possible to skip columns, i.e.,
@samp{start-col-1} must be 1 and each succeeding @samp{start-col}
must be one more than the preceeding @samp{end-col}.
@end quotation

@display
proc dap;
@var{dap-statement}

@end display

@quotation
SBS note: @var{dap statement} can either be enclosed in braces @samp{@{ @}} or
end with a semi-colon @samp{;}. Attempting to use dap graphics and SBS graphics in the
same program will produce unpredictable and, perhaps, undesirable results. Note
that @var{dap statement} is run as-is by dap and, in particular, indexes of array
subscripts start at 0. The @var{dap statement} cannot use
the @samp{0x} prefix for hexidecimal numbers.
@end quotation

@node FAQ,Index,Appendix IV,Top
@unnumbered Frequently Asked Questions

@menu
* I cannot find a function::
* I want to split a dataset::
* Logistic regression reported a singular matrix::
* How do I add a line to a plot?::
@end menu

@node I cannot find a function,I want to split a dataset,FAQ,FAQ
@section I cannot find a function

@strong{Q:} I cannot find a function to delete spurious zeros from my
dataset without deleting anything else. What do I do?

@strong{A:} You have to write some C code (@pxref{Appendix II}) for that:
@example
while (step())
  @{
    if (yield > 0.0)
      output();
  @}
@end example

@node I want to split a dataset,Logistic regression reported a singular matrix,I cannot find a function,FAQ
@section I want to split a dataset

@strong{Q:} I want to split a dataset based on the value of a
variable. How do I do that?

@strong{A:} Assume that the variable to be used is a
character variable named @samp{part} with 9 characters
(including the terminating null) and that dataset
@file{set} is sorted by @samp{part}.
The following code fragment creates a dataset for each
value of @samp{part} and names it that value.

@example
inset("set")
  @{
    char part[9];
    int partv[1];

    daplist("part", partv, 1);
    if (step())  /* to get started */
      @{
        outset(part, "");
        output();
        while (step())  /* to continue */
          @{
            if (dap_newpart(partv, 1))
              outset(part, "");
            output();
          @}
      @}
  @}
@end example

@node Logistic regression reported a singular matrix,How do I add a line to a plot?,I want to split a dataset,FAQ
@section Logistic regression reported a singular matrix

@strong{Q:} Logistic regression reported a singular matrix, but my data seems OK.
@inindex logistic regression

@strong{A:} You may need to lower the value of DAP_CTOL (@pxref{Appendix I}),
which is used to
zero-out matrix entries that appear to be non-zero only as the result of
round-off errors.

@node How do I add a line to a plot?, ,Logistic regression reported a singular matrix,FAQ

@section How do I add a line to a plot?

@strong{Q:} I plotted a dataset using @samp{plot} and I want to add a line to it.
How do I do that without knowing the scaling and translating used by @samp{plot}?

@strong{A:} In your call to @samp{plot}, specify @samp{MINX}, @samp{MAXX},
@samp{MINY}, and @samp{MAXX}. Don't use @samp{nport} or @samp{nland}; rather use
@samp{pict_port}, @samp{pict_land}, or @samp{pict_init} to start the graphics section
of your program (and don't forget @samp{pict_page}, @samp{pict_show},
and @samp{pict_end}). Then
declare an array of 2 @samp{pict}s and use @samp{pict_initpict} to initialize them
as a list. Then use @samp{pict_line} on the first of these 2 picts and call
@samp{pict_autoaxes} with the same axis specifications (although you can
set @samp{NXTICKS} and @samp{NYTICKS} to 0 if you wish).
You can use the same axis labels, overwrite them, or leave them as null strings.
Finally, call @samp{pict_show}.

Here's an example:

@example

#include <dap.h>

void main()
@{
  infile (NULL, NULL)
    @{
      double x, y;
      int n;
      outset("gtest", "");
      for (n = 0; n < 10; n++)
        @{
          x = varnorm();
          y = varnorm();
          output();
        @}
    @}
  @{
    pict *p, p1[2];

    pict_port(1);
    pict_page();

    p = plot("gtest", "x y", "", "== MINX-4 MAXX4 MINY-4 MAXY4",
             NULL, NULL, 1);
    pict_show(p);

    pict_initpict(NULL, p1);
    pict_initpict(p1, p1 + 1);
    pict_line(p1, -3.0, 2.0, 2.0, -1.0);
    pict_autoaxes(p1, "", "",
                  "== MINX-4 MAXX4 MINY-4 MAXY4 NXTICKS0 NYTICKS0",
                  NULL, NULL, "", 1);
    pict_show(p1);

    pict_end();
  @}
@}

@end example

@node Index, ,FAQ,Top
@unnumbered Index

@printindex in

@contents

@bye
