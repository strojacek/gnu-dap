This is dap, produced by makeinfo version 4.5 from dap.texi.

INFO-DIR-SECTION Dap statistics and graphics package
START-INFO-DIR-ENTRY
* Dap: (dap).                The Dap statistics package
END-INFO-DIR-ENTRY


File: dap,  Node: Top,  Next: Overview and invocation,  Up: (dir)

Dap
***

   This document describes version 3.5 of the Dap statistics and
graphics package.  Dap is a GNU program.

* Menu:

* Overview and invocation::
* Program structure:: C-style dap programs only
* Datasets:: I/O and management.
* Managing and displaying data:: Processing datasets.
* Statistics functions:: Data analysis.
* Graphics functions:: Presentation.
* Utilities:: Probability and miscellaneous functions.
* Picture functions:: Low level operations on pictures.
* Examples:: Sample programs.
* Appendix I:: Settable parameters
* Appendix II:: Essentials of C syntax
* Appendix III:: Troubleshooting
* Appendix IV:: SBS
* FAQ:: Frequently asked questions
* Index::


File: dap,  Node: Overview and invocation,  Next: Program structure,  Prev: Top,  Up: Top

Overview and invocation
***********************

* Menu:

* Description and example::
* Invoking Dap::


File: dap,  Node: Description and example,  Next: Invoking Dap,  Up: Overview and invocation

Description, an example, and reading this manual
================================================

   Dap is a small statistics and graphics package based on C.  As of
Version 3.0, dap can read SBS programs to perform basic statistical
analyses, thus freeing the user from learning and using C syntax for
straightforward tasks, while retaining access to the C-style graphics
and statistics features provided by the original implementation (*note
Appendix IV::).  Dap provides core methods of data management,
analysis, and graphics commonly used in statistical consulting practice.
Anyone familiar with the basic syntax of C programs can learn to use
the C-style features of dap quickly and easily from this manual and the
examples it provides; advanced features of C are not necessary,
although they are available.  (*Note Appendix II:: provides a brief
description of the C syntax needed to use those features of dap
dependent on it.)  Because dap processes files one line at a time,
rather than reading entire files into memory, it can be used on data
sets that have very large numbers of lines and/or large numbers of
variables.

   Dap consists of: an interactive front end that controls editing,
compiling, execution, and viewing; an optional SBS-to-C-style-dap
translator that can convert an SBS program into a C-style dap program;
a preprocessor that facilitates data input and output by converting a
C-style dap program into an ordinary C program; and a library of
statistics functions and graphics functions.  Typical use of dap
involves the following steps:

  1. Obtain, or use a text editor to create, one or more data files in
     acceptable formats.

  2. Invoke (i.e., run) `dap' to create or view an SBS or C-style dap
     program that will read and process the data file(s) to produce
     tables and/or graphics.  (See *Note Invoking Dap:: to find out how
     to run dap.  If you want to use the C-style features of dap and
     are unfamiliar with C, read *Note Appendix II:: before creating
     your C-style dap program.)

  3. Tell dap to compile (i.e., translate into machine usable form)
     your SBS or C-style dap program and execute (i.e., run) your
     program.

  4. If the previous step was successful, view your tables and/or
     graphics; otherwise, if there are errors in your program, you will
     have to edit your program further and repeat Step 3.

   The following program examples illustrate the basic structure of
simple SBS and C-style dap programs and how functions in the library
are used in dap.

     /* A SIMPLE SBS PROGRAM */
     data;                  /* Begin data step */
      infile "two" delimiter="\t" firstobs=2;
                            /* The infile statement: identifies "two" as
                             * the file to read from, specifies that
                             * the delimiter is a tab, i.e. the numbers
                             * in each line in "two" are separated by a
                             * single tab character, and directs the
                             * program to skip one header line and start
                             * data input on the second line of the file "two".
                             */
      input x y;            /* The first number on each line of "two"
                             * will be held in x and the second number
                             * will be held in y
                             */
     proc plot;             /* Run the plot procedure to display a scatter-plot... */
      plot y * x / box;     /* ...using y for the vertical axis and x for the
                             * horizontal and enclosing the plot in a box
                             */

     /* A SIMPLE C-STYLE DAP PROGRAM */
     #include <dap.h>       /* REQUIRED: includes prototypes of
                             * statistics and graphics functions
                             */
     
     void main()            /* REQUIRED: main runs everything */
     {
     /* This part of the program reads in data from an ordinary file
      * and writes it out to a dataset, which is the kind of file
      * on which the library functions can operate to perform
      * exploratory data analysis, graphical interpretation, and
      * statistical analyses.
      */
     infile("two", "\t")    /* The infile statement: identifies "two" as
                             * the file to read from and specifies that
                             * the delimiter is a tab, i.e. the numbers
                             * in each line in "two" are separated by a
                             * single tab character
                             */
       {                    /* Beginning of infile statement body */
       double x, y;         /* specify that x and y are variables that
                             * hold "double-precision floating point"
                             * numbers, i.e., numbers that are not
                             * necessarily whole numbers
                             */
       input("x y");        /* The first number on each line of "two"
                             * will be held in x and the second number
                             * will be held in y
                             */
       outset("xyset", ""); /* Create a dataset "xyset" and write all
                             * the variables to it
                             */
       skip(1);             /* The data file contains 1 header line;
                             * skip it
                             */
       while (step())       /* Read in the file, one line at a time */
         output();          /* and write it to the dataset "xyset" */
       }                    /* end of infile statement body */
     
     /* This line runs the plot function to get a scatter-plot, then
      * displays the result graphically using the nport function; the
      * various options used are described in the section for the plot
      * and nport functions.
      */
     nport(plot("xyset", "x y", "", "==", NULL, NULL, 1), 1, 1);
     }

   For each C-style dap function, this manual gives:

  1. SPECIFICATION: This is an abstract template for the function that
     indicates the types of the parameters (string, i.e., array of
     char, double, array of double, int, or array of int), and the
     return value, if any; bold face indicates literal text, ITALICS
     indicates parameters for which you choose your own names. The
     corresponding SBS template, if available, is also provided.

  2. Description: A description of the functionality and use of the
     function.  If there is a corresponding SBS proc, notes on its
     usage follow.

  3. Code fragment(s): These are one or more examples of calling the
     function, with made-up values for the parameters; for complete
     examples of use, see the final chapter (*note Examples::) or
     consult the index.

   For the SBS templates, the following should be noted.  Elements
within square brackets `[ ]' are optional and some, although permitted,
may have no effect.  Elements within braces `{ }', separated by a
vertical bar `|' are alternatives.  Keywords may be in upper or lower
case.  Single and double quotes must be used as in C, i.e., use double
quotes for strings (whether or not they are one character long) and use
single quotes only for character values.  Not all statements listed
below the `data' or `proc' statements are required and multiple
statements of some types may be allowed.


File: dap,  Node: Invoking Dap,  Prev: Description and example,  Up: Overview and invocation

Invoking Dap
============

   To run dap, you must type a command which looks like one of the
following (in which the bracketed items are optional and are described
below):

SPECIFICATION

     dap [-k] [-d] FILE1.c [ FILE2.c ... ] [-a ARG1 ...]
     dap [--keep] [--debug] FILE1.c [ FILE2.c ... ] [--args ARG1 ...]
     dap [-k] [-d] FILE1.sbs [ FILE2.c ... ]
     dap [--keep] [--debug] FILE1.sbs [ FILE2.c ... ]

Description

   The following description is based on using the GNU editor Emacs to
interact with dap.  If you don't use Emacs, you can still use dap, but
in the commands specified above, use `daprun' in place of `dap'; in
that case, you will have to open your editor and/or file viewer to edit
your program and view your text output.

   When you type the command to run dap:

  1. The editor Emacs (type the command `info emacs' for the manual) is
     opened for the named SBS or C-style dap file(s).  Each file is
     created, but is empty, if it doesn't exist.  When you are finished
     editing your file(s), save it (them), but do not exit unless you
     are finished running dap.

  2. Emacs will have a buffer called `Async Shell Command'; select that
     buffer and you will be asked whether to compile the named SBS or C
     file(s) and run the resulting executable file (if the compilation
     is successful).  If you answer `y', then dap runs the preprocessor
     on the named SBS or C file(s) to produce FILE1.dap.c [ FILE2.dap.c
     ... ].  If you answer `q', then dap stops running (and you can
     either leave Emacs running for some other purpose or exit it).

  3. If the preprocessing is successful, then dap runs a C compiler on
     the preprocessed file(s), linking library functions as necessary,
     to produce FILE1.dap.

  4. If the compilation is successful, then dap removes the `dap.c'
     file(s) (unless the `-d' or `--debug' option is present) and runs
     the executable FILE1.dap, passing the arguments ARG1, ..., if any,
     and produces FILE1.lst file for tables and FILE1.ps for graphics,
     as requested.  There are Emacs buffers for the `lst' and `log'
     files, but you must use `Revert buffer' in the `File' menu to see
     the most recent results.  A viewer will be opened for the `ps'
     file, if it exists.

  5. Each time a dataset or datafile is read through to the end during
     execution, the number of lines read from the dataset or datafile
     is displayed in your `Async Shell Command' buffer and written to
     the `log' file.  If `dap_outreport' (*note Appendix I::) is
     positive (default: 100000), then dap reports, in your `Async Shell
     Command' buffer, each time that an additional `dap_outreport'
     lines have been written to a dataset; if your program is writing
     to a dataset inside an infinite loop, this helps you abort the
     program to avoid filling up your disk (by holding down the `Ctrl'
     key and pressing the `C' key _twice_).

  6. If there were errors or warnings, they will be written to the
     `err' and you will see them displayed in your `Async Shell
     Command' buffer.

  7. At this point, you can edit (and save!) your SBS or C-style dap
     files again or quit.

   If the `-a' or `--args' option is present (C-style dap programs
only), then all the arguments that follow it on the command are passed
to the `main' in your program as `argv'.  In all cases, the `lst' and
`ps' files are removed before the first execution, but if the `-k' or
`--keep' option is present, then the `lst' file is kept and appended to
from one cycle to the next.  (Keeping the `lst' file from one cycle to
the next can be useful for exploratory data analysis, such as model
building for linear regression or loglinear models, in which it is
useful to have a record of a succession of analyses without running the
cumulative set of analyses repeatedly.)

   NOTE: If your system uses `locale's, then you must set your
environment variable `LC_COLLATE' to `C' in order to obtain correct
sorting.

   The editor invoked is /usr/bin/emacs unless the environment variable
`DAPEDITOR' specifies a different location for Emacs.  Emacs is invoked
with no options unless the environment variable `DAPEDOPTS' is set to a
single string of all the options desired.  The compiler used is
/usr/bin/gcc unless the environment variable `DAPCOMPILER' is set to a
different compiler.  The compiler is invoked with no options unless the
environment variable `DAPCOMPOPTS' is set to a single string of all the
options desired.  The `lst' file is displayed in its entirety in its
buffer unless the environment variable `DAPPAGER' is set to a pager
(such as `more').  That pager is invoked with no options unless the
environment variable `DAPPAGEOPTS' is set to a single string of all the
options desired.  The `ps' file is viewed with /usr/bin/X11/gv unless
the environment variable `DAPVIEWER' is set to a different graphics
viewer.  The viewer is invoked with no options unless the environment
variable `DAPVIEWOPTS' is set to a single string of all the options
desired.

   The executable FILE1.dap can be run, or debugged, on its own.  If
the `-a' or `--args' option was used when the source files were
processed, then arguments (without the `-a' or `--args') are used on
the command line.  If you want to use `gdb' to debug FILE1.dap, include
`-g' as one of your compiler options and use the `-d' or `--debug'
option when you run dap so that the `.dap.c' files will not be removed.

Code fragment(s)

   _Run `dap' on the file `tweedle.c':_
     dap tweedle.c

   _Run `dap' on the file `tweedle.sbs':_
     dap tweedle.sbs

   _Run `dap' on the files `tweedle.c' and `dee.c':_
     dap tweedle.c dee.c

   _Run `dap' on the files `tweedle.sbs' and `dee.c':_
     dap tweedle.sbs dee.c

   _Run `dap' on `tweedle.c'; append to `tweedle.lst' in each cycle:_
     dap -k tweedle.c
     dap --keep tweedle.c

   _Run `dap' on `tweedle.c'; pass arguments `17' and `dum' to `main'
in `tweedle.c':_
     dap tweedle.c -a 17 dum
     dap tweedle.c --args 17 dum

   _Run `dap' on `tweedle.c'; do not remove `tweedle.dap.c' for
debugging:_
     dap -d tweedle.c
     dap --debug tweedle.c


File: dap,  Node: Program structure,  Next: Datasets,  Prev: Overview and invocation,  Up: Top

Program structure
*****************

   This chapter concerns C-style dap programs only.

* Menu:

* Reading files and datasets:: inset and infile.
* Variables::
* Output files:: `err', `log', `lst', and `ps'
* The preprocessor:: dappp


File: dap,  Node: Reading files and datasets,  Next: Variables,  Up: Program structure

Reading files and datasets
==========================

   This section and the next apply only to C-style dap programs.
C-style dap programs are C programs with two additional statement types
and additional library functions to perform statistical and graphical
tasks.  All C-style dap programs must contain a line

     #include <dap.h>

to include the dap header file before the function `main' and any
variable declarations, except that if the program resides in more than
one `C' file, only one of those files must include `dap.h' while the
others must include `dap1.h' instead.  (This is to avoid multiple
definitions of dap parameters.)

   The two additional statement types are `infile' and `inset'
statements, which are used to set up input from files and datasets and
which have the following syntaxes:

SPECIFICATION

     infile(DATAFILE, DELIMITER) { ... }
     DATAFILE, DELIMITER: string
     
     inset(DATASET) { ... }
     DATASET: string

Description

   The body of `infile' and `inset' statements may contain local
variable declarations, an `outset' statement, and statements to process
the input file or dataset.  In addition, the body an `infile' statement
may contain an `input' statement.

   The local variable declarations in the body of `infile' and `inset'
statements are restricted to the following types:

     double name;
     double name[number];
     double name[string];
     int name;
     int name[number];
     int name[string];
     char name[number];
     char name[string];

   When the dimension of the array is given as a string, that string
must appear in a `#define' somewhere in the file before the declaration.

   A program can generate data without reading from a file.  In that
case, an `infile' statement is still required, but both arguments can
be given as `NULL'.

   The delimiter argument to an `infile' statement can be in one of two
forms, one for delimited fields and the other for fixed-width fields.
If the file to be read is simply delimited text, the the delimiter
argument is a string (not a character) consisting of the single
delimiter character.  If the file has fixed-width fields, then the
delimiter argument is an alternating sequence of any non-numerical
character and numbers that specify the field widths, in order and
without spaces (unless the non-numerical character is a space).  For
example:

     infile("data", "x6x5x8")

specifies three data fields of widths 6, 5, and 8, respectively.

   It is inappropriate to call a dap statistics or graphics function
from within the body of an `infile' or `inset' statement; results from
such a call are unpredictable.

   The header file `dap.h' defines parameters that control the
execution of dap.  For example, `dap_maxvar' is the maximum number of
variables allowed in any dataset.  To change any of these parameters,
use a preprocessor `#define' line in your program before the line that
includes `dap.h'.  For example,

     #define DAP_MAXVAR 512
     #include <dap.h>

will set the maximum number of variables to 512 instead of the default
256.  Note that such a `#define' line does _not_ end with a semi-colon.

   It is not necessary to use a `#define' such as the one above if you
do not wish to change the values of the parameters from their defaults.
However, some dap functions have limitations on how many values they
can process at one time and if you have a dataset that is particularly
large, then you may receive a memory allocation error message.  That
message will usually contain a suggestion of which parameter may need
changing.  The parameters available for modification are listed in
Appendix I (*note Appendix I::).

Code fragment(s)

   _Read space-delimited data file `tweedledee' with values for `name',
`wages', and `tips' on each line and write those values to dataset
`tweedledee':_
     infile("tweedledee", " ")
       {
         char name[21];
         double wages, tips;
         input("name wages tips");
         outset("tweedledee", "");
         while (step())
           output();
       }

   _Read from dataset `tweedledee', compute `income' as the sum of
`wages' and `tips', and write to dataset `tweedledum':_
     inset("tweedledee")
       {
         double wages, tips, income;
         outset("tweedledum", "");
         while (step())
           {
             income = wages + tips;
             output();
           }
       }


File: dap,  Node: Variables,  Next: Output files,  Prev: Reading files and datasets,  Up: Program structure

Variables
=========

   This section applies only to C-style dap programs.  The variables
declared in the body of an `infile' or `inset' statement are available
for reading from the specified file or dataset and for writing to the
specified dataset.  It is not necessary to declare all the variables in
an input or output dataset; only those variables that are used
explicitly in a statement in the body of the `infile' or `inset'
statement (i.e., not in a quoted string as an argument to a function
such as `input', `outset', or `dap_list'), must be declared.  Avoid
using variable (or function) names that begin with `dap_' or `pict_' or
end with `dap_'.  WARNING: Within an `inset' statement, if you declare
and set the value of a variable that is already in the dataset
referenced by the `inset' statement, values that your program gives to
that variable will be overwritten on each call to `step'.

   Data management, statistics, graphics, and other C-style dap
functions take lists of variables as arguments.  Such lists must always
be given as strings of variable names (sometimes with other
specifications included), separated by spaces (not commas).  Generally,
the null string ("", not `NULL') is a shorthand for a list of all the
variables in the dataset and `NULL' is a shorthand for none of the
variables in the dataset.

   Arrays of int or double may be referenced, by the array name with no
brackets or indices, in calls to `input' and `outset'.  Individual
array elements, with their bracketed indices, may also be referenced in
calls to those same functions, but not in calls to `dataset' or `merge',
for which arrays of int or double must be referenced by the array name,
with no brackets or indices.  For all other C-style dap functions, each
element of an array of int or double that is to be used must appear
with its bracketed index.


File: dap,  Node: Output files,  Next: The preprocessor,  Prev: Variables,  Up: Program structure

Output: the `err', `log', `lst', and `ps' files
===============================================

   The user's program can write directly to the `lst' and `log' files
using stream functions (`putc', `fputs', `fprintf', etc.)  on `dap_lst'
and `dap_log', respectively.  The following function may be called to
display a section header in the `lst' file:

SPECIFICATION

     dap_head(PARTV, NPARTV)
     PARTV: array of int
     NPARTV: int

Description

   If PARTV is not `NULL', the header includes the values of the
variables defining a part of the file or dataset (*note Partitioning a
dataset::).  NOTE: `dap_head' makes a system call to `time' and calls
the GNU library function `ctime'; consequently, user-defined functions
with those names will interfere with the date displayed by `dap_head'.

Code fragment(s)

   _Write header, with current title, if any, to `lst' file:_
     while (step())
       {
         ...
         dap_head(NULL, 0);
         ...
       }

   _With input dataset sorted by the variables `state', `county', and
`city', write header, with current title, if any, and with current
values of `state', `county', and `city', to `lst' file:_
     int fooparts[3];
     ...
     dap_list("state county city", fooparts, 3);
     while (step())
       {
         ...
         dap_head(fooparts, 3);
         ...
       }

   A title may be specified as part of the section head or as caption
in graphical output by calling:

SPECIFICATION
     title(THE-TITLE)
     THETITLE: string

     title "THE-TITLE";

Description

   The string THE-TITLE may contain newline ('\n') characters for
multi-line titles.  For graphical output captions, subscripts are
specified by enclosing them in vertical bars (`|') and superscripts are
specified by enclosing them in carets (`^').  If a title has been
specified by `title', then a graphics function that produces a separate
page for each part of a partitioned dataset will include in the caption
the value(s) of the variable(s) defining the partition.

Code fragment(s)

   _Set title for `dap_head':_
     title("Analysis of variance\nfor crop yields");
     title("CFU per cm^2^ of surface area");


File: dap,  Node: The preprocessor,  Prev: Output files,  Up: Program structure

The preprocessor: dappp
=======================

   The preprocessor, which is named dappp, reads FILE.c, performs the
following four actions to create FILE.dap.c:

  1. Process simple `#defines' of the form:

          #define STRING N

     in which STRING starts with a letter or with `_' and N is a
     positive integer.

  2. Replace `main' with `dap_main' so that the `main' internal to dap
     can set up variables and the output files before calling
     `dap_main'.

  3. Append a semicolon to each `infile' or `inset' statement header to
     prepare it for the C compiler.

  4. Append calls to `dap_vd', `dap_dl', `dap_il', and `dap_sl' after
     declarations in the body of `infile' and `inset' statements.


   The `dap_vd' function tells the internal dap routines the names and
types of variables so that datasets can be processed appropriately.
The `dap_dl', `dap_il', and `dap_sl' functions create links between the
variables in the user's program and the internal dap storage to allow
input and output.  These functions are appended to the last line of the
user's declarations so that line numbers in C compiler messages for
FILE.dap.c correspond exactly to line numbers in FILE.c.


File: dap,  Node: Datasets,  Next: Managing and displaying data,  Prev: Program structure,  Up: Top

Datasets
********

   Datasets are data files with an additional first line that specifies
the names and types of the variables whose values follow.  The only
other differences between datasets and data files are that (1) integers
and double precision floating point numbers are encoded as text in a
way that loses no precision and which allows sorting to be performed in
the usual alphanumeric order and (2) the delimiter between fields on a
line is always `|'.  (A consequence of this is that string values
cannot contain `|'.)

   Most C-style dap data management, statistics, and graphics functions
have an argument, called PARTVARS in the specifications, that allows
parts of a dataset to be processed separately.  (SBS programs use a
`by' statement.)  To do that, first sort the dataset by the values of an
ordered list of variables: each part is defined as a set of lines for
which the values of all of those variables are constant.  Then the same
variables in the same order must be named in the PARTVARS argument of
the function that is subsequently used to process the sorted dataset.
If no partitioning is desired, then PARTVARS should be the null string
("").

   Dap allows datasets that are not too large to be stored in memory
instead of on disk in order to speed processing.  To specify that a
dataset is to be stored in memory, precede the name of the dataset with
a `<' in the call to `outset' that creates it and in calls to functions
that read it.  Note that a dataset that is stored in memory will not be
retained after the current dap session.

   Only the last section in this chapter, `Manage datasets', has
information relevant to SBS programs.  For input for SBS programs, see
*Note Appendix IV::.

* Menu:

* Input and output:: input, step, skip, outset, output.
* Positioning within a dataset:: dap_mark, dap_rewind.
* Partitioning a dataset:: dap_list, dap_newpart, dap_swap.
* Modifying output:: dap_save, dap_rest.
* Manage datasets:: dataset.


File: dap,  Node: Input and output,  Next: Positioning within a dataset,  Up: Datasets

Input and output
================

SPECIFICATION
     input(VARIABLE-LIST)
     VARIABLE-LIST: string

Description

   The string VARIABLE-LIST is a space-separated list of the names of
the variables, in order, on each line of the data file to be read;
VARIABLE-LIST may contain the names of arrays or individual array
elements.  Do not call `input' for a dataset.

Code fragment(s)

   _Specify that (the beginning of) each line of the input data file
contains two fields whose values are to be read into the variables
`fert' and `yield', in order:_
     input("fert yield");

SPECIFICATION
     step()
     RETURNS: int

Description

   Attempts to read one line of the file or dataset specified by
`infile' or `inset', respectively.  Returns 1 if a line was read, 0 if
EOF was reached before any characters were read; in this latter case,
all input variables retain their values from the previous line.  The
program exits with an error message if `step' is called after an EOF
was reached.  Missing integer data is read in as 0.  Data of type
double that is missing or is `.' is set to NaN(1).

Code fragment(s)

   _Read all the lines of the current input dataset or data file and
write them to the current output dataset:_
     while (step())
       output();

SPECIFICATION
     skip(NLINES)
     NLINES: int

Description

   Skips NLINES lines of the input data file.  This is useful for
skipping header lines in a data file.

Code fragment(s)

   _Skip 3 lines of the input data file:_
     skip(3);

SPECIFICATION
     outset(DATASET, VARIABLE-LIST)
     DATASET, VARIABLE-LIST: string

Description

   The string DATASET is the name of the data set to be written.  The
string VARIABLE-LIST is either a space-separated list of the names of
the variables to be included in the output data set, a `!' followed by
a space-separated list of the names of the variables to be excluded
from the output data set, or a null string (not `NULL'), which
specifies that all variables are to be included in the output data set.
The output data set always includes a variable named `_type_', which is
a string of length 9 (includes terminating null) and which indicates
the type of the observation.  The string VARIABLE-LIST may contain the
names of arrays, without bracketed indices, or individual array
elements, but in either case the entire array is included in or
excluded from the output dataset.

   If the dataset is small and need not be retained after the current
dap session, then DATASET may begin with a `<' to specify that the
dataset is to be stored in memory rather than on disk; this will speed
processing.  The string DATASET must then begin with a `<' in calls to
functions that read it.  If DATASET does not begin with a `<', then
`outset' creates the data set in the subdirectory `dap_sets' of the
current directory.  If `dap_sets' does not exist, `outset' creates it.
A call to `outset' must be preceded by an `infile' or `inset' statement;
if no input file or dataset is desired, you may use `NULL' as the file
specified by `infile' and `NULL' as the delimiter string.

Code fragment(s)

   _Name the output dataset `tweedledee' and specify that it will
contain the values of the variables `alice' and `caterpillar' only:_
     outset("tweedledee", "alice caterpillar");

   _Name the output dataset `tweedledum' and specify that it will
contain the values of all the variables that are either in the input
dataset or are declared in the current `infile' or `inset' statement:_
     outset("tweedledum", "");

   _Name the output dataset `tweedledum' and specify that it will be
stored in memory, not on disk, and that it will contain the values of
all the variables that are either in the input dataset or are declared
in the current `infile' or `inset' statement:_
     outset("<tweedledum", "");

SPECIFICATION
     output()

Description

   Writes one line of data to the output dataset specified by `outset'.

   ---------- Footnotes ----------

   (1) "Not a Number": see the function `finite' in the GNU/Linux
Programmer's Manual.


File: dap,  Node: Positioning within a dataset,  Next: Partitioning a dataset,  Prev: Input and output,  Up: Datasets

Positioning within a dataset
============================

SPECIFICATION
     dap_mark()

Description

   Marks a position in a dataset: a call to `dap_rewind' rewinds the
dataset to that position.

SPECIFICATION
     dap_rewind()

Description

   Rewinds the input dataset to the location saved by the most recent
call to `dap_mark'.


File: dap,  Node: Partitioning a dataset,  Next: Modifying output,  Prev: Positioning within a dataset,  Up: Datasets

Partitioning a dataset
======================

SPECIFICATION
     dap_list(VARIABLE-LIST, PARTV, NPARTV)
     VARIABLE-LIST: string
     PARTV: array of int
     NPARTV: int
     RETURNS: int

Description

   Fills the array PARTV with the indices of the at most NPARTV
variables whose names are in the space-separated list VARIABLE-LIST.
Returns the number of variables actually listed.

Code fragment(s)

   _With the input dataset sorted by the values of the variables
`first' and `last', prepare `namev' for use in `dap_head' or
`dap_newpart':_
     int namev[2];
     dap_list("first last", namev, 2);

   _In the function `foo', prepare `varv' for use in `dap_head' or
`dap_newpart':_
     foo(char *varlist)
       {
         int varv[3];
         int numvars;
     
         numvars = dap_list(varlist, varv, 3);
         ...
       }

SPECIFICATION
     dap_swap()

Description

   Swaps the two most recently read input file or dataset lines so that
the program can complete processing of a part of that file or dataset
after it detects the beginning of a new part.

SPECIFICATION
     dap_newpart(PARTV, NPARTV);
     PARTV: array of int
     NPARTV: int
     RETURNS: int

Description

   Returns 1 if the beginning of a new part, or the end of the file or
the dataset, has been reached, 0 otherwise.

   A collection of variables can be used to define parts of a dataset
for which all the variables in that collection are constant.  For
example, if a dataset `names' has a variable `first' that gives a
person's first name and a variable `last' that gives a person's last
name, then sorting the dataset by `last' and `first' will define parts,
each of which contains all the records for one person (assuming no two
people in the dataset have the same first and last name).  The
following example program fragment counts how many records belong to
each person; it is assumed that the dataset has previously been sorted
by `last' and `first'.  (This example is for illustrative purposes
only: the same task can be done in one line with the `means' function.)

Code fragment(s)

     inset("names")
       {
         int nrecords;   /* count of records */
         int partv[2];   /* array of numerical ids for variables */
         int more;       /* flag: is there more input? */
     
         dap_list("last first", partv, 2);  /* sets up numerical ids */
         for (nrecords = 0, more = 1; more; nrecords++)
           {
             more = step();             /* read 1 line or end of dataset */
             if (dap_newpart(partv, 2)) /* test if beginning of part
                                         * defined by last and first
                                         */
               {
                 dap_swap();      /* back to last line in previous part */
                 dap_head(partv, 2);  /* display header for that part */
                 fprintf(dap_lst, "%d records\n", nrecords);
                                      /* display the number of records */
                 dap_swap();          /* back to beginning of new part
                                       * or end of dataset
                                       */
                 nrecords = 0;        /* re-initialize n for new part */
               }
           }
       }


File: dap,  Node: Modifying output,  Next: Manage datasets,  Prev: Partitioning a dataset,  Up: Datasets

Modifying output
================

SPECIFICATION
     dap_save()

Description

   Saves the most recently read input file or dataset line so that the
values of the variables can be modified for an additional output.

SPECIFICATION
     dap_rest()

Description

   Restores the most recently read input file or dataset line that was
saved by `dap_save'.


File: dap,  Node: Manage datasets,  Prev: Modifying output,  Up: Datasets

Manage datasets
===============

SPECIFICATION
     dataset(OLDNAME, NEWNAME, ACTION)
     OLDNAME, NEWNAME, ACTION: string

     proc datasets;
     append {base | out}=NEWNAME [{data | new}=OLDNAME];
     change OLDNAME-1=NEWNAME-1 [... OLDNAME-N=NEWNAME-N];
     delete FILENAME-1 ... FILENAME-N;

Description

   Performs the specified action on the datasets OLDNAME and, if the
action is not `REMOVE', NEWNAME.  The string ACTION must contain one of
the words `APPEND', `RENAME', `COPY', `FILL', or `REMOVE'.

   `APPEND' appends the dataset OLDNAME at the end of NEWNAME. For
`APPEND', only those variables existing in NEWNAME are retained from
OLDNAME and if a variable in NEWNAME does not appear in OLDNAME, the
value of that variable is set to the null string if of type string or 0
if of type int or double.

   `RENAME' changes the name of the dataset from OLDNAME to NEWNAME.

   `COPY' may be followed by a space-separated list of variable
specifications, each of which has the form VARIABLE-NAME or
VARIABLE-NAME > NEW-VARIABLE-NAME. In either case, only the variables
listed will be retained in the copy of the dataset and in the second
case, those variables will be renamed as indicated. If VARIABLE-NAME
refers to an array, then no index may be specified and the entire array
is retained and, if indicated, renamed.

   `FILL' makes a copy, named NEWNAME, of the dataset OLDNAME with the
values in missing cells filled by 0.0 for variables of type double, 0
for variables of type int, and the null-string `""' for variables of
type string.  `FILL' must be followed by two space-separated lists
which are separated by a `:'. The first list names the variables whose
values are to be filled and the second list names the variables that
classify the cells in the dataset.  The dataset must be sorted by the
classification variables in that order.

   `REMOVE' deletes the dataset OLDNAME.

Code fragment(s)

   _Append the contents of the dataset `tweedledee' to the dataset
`tweedledum':_
     dataset("tweedledee", "tweedledum", "APPEND");

   _Change the name of the dataset `tweedledee' to `tweedledum':_
     dataset("tweedledee", "tweedledum", "RENAME");

   _Make a copy of the dataset `tweedledee' and name the new dataset
`tweedledum':_
     dataset("tweedledee", "tweedledum", "COPY");

   _Make a copy of the dataset `tweedledee' but retain the values of
`alice' and `mushroom' only, and name the new dataset `tweedledum':_
     dataset("tweedledee", "tweedledum", "COPY alice mushroom");

   _Make a copy of the dataset `tweedledee', retain the values of
`alice' and `mushroom' only, name the new dataset `tweedledum', and
change the name of `alice' to `tall' in the new dataset:_
     dataset("tweedledee", "tweedledum", "COPY alice>tall mushroom");

   _Make a copy, named `tweedledum', of the dataset `tweedledee', which
is sorted by `SES', `race', and `gender', with the missing cells filled
with 0.0 for the variable `count':_
     dataset("tweedledee", "tweedledum", "FILL count : SES race gender");

   _Remove the dataset `tweedledee':_
     dataset("tweedledee", "", "REMOVE");


File: dap,  Node: Managing and displaying data,  Next: Statistics functions,  Prev: Datasets,  Up: Top

Managing and displaying data
****************************

   These functions manipulate or display the data within a dataset (not
a data file).

* Menu:

* Sorting a dataset:: sort
* Merging datasets:: merge
* Displaying a dataset:: print and table
* Splitting and joining lines:: split and join
* Grouping lines in a dataset:: group
* Trimming extreme values:: trim


File: dap,  Node: Sorting a dataset,  Next: Merging datasets,  Up: Managing and displaying data

Sorting a dataset
=================

SPECIFICATION
     sort(DATASET, VARIABLE-LIST, MODIFIERS)
     DATASET, VARIABLE-LIST, MODIFIERS: string

     proc sort [data=DATASET-NAME] [out=DATASET-NAME] [nodupkey];
     by [descending] VARIABLE-1 [... [descending] VARIABLE-N]

Description

   Writes to DATASET.srt the result of sorting DATASET in the order
specified by the space-separated, ordered list of variables
VARIABLE-LIST, according to MODIFIERS.  The original dataset is left
unchanged.  If MODIFIERS is the null string, then all variables are
sorted in increasing order and all sorted lines are kept.  Otherwise,
MODIFIERS is a space separated list of `u' and/or an ordered string of
`i' and `d' (no spaces) whose length equals the number of variables in
VARIABLE-LIST: `u' means retain only one record in a group of lines for
which all the values of all the variables in VARIABLE-LIST are
identical; `i' indicates that the corresponding variable will be sorted
in increasing order and `d' indicates decreasing order.  NOTE: sort
allocates enough memory for sorting small to moderately large disk files
efficiently; for very large files, consider setting DAP_MAXMEM (*note
Appendix I::).

Code fragment(s)

   _Create a copy of the dataset `people' sorted by `height' in
ascending order and by `weight' in ascending order within groups with
equal `height' and name the new dataset `people.srt':_
     sort("people", "height weight", "");

   _Create a copy of the dataset `people' sorted by `height' in
descending order and by `weight' in ascending order within each group
of lines with constant `height' and name the new dataset `people.srt':_
     sort("people", "height weight", "di");

   _Create a copy of the dataset `people' sorted by `last' in ascending
order and by `weight' in ascending order within each group of lines
with constant `height', but retain only one line from each group of
lines with the constant `last' and `first', and name the new dataset
`people.srt':_
     sort("people", "last first", "u");

   _Create a copy of the dataset `people' sorted by `last' in
descending order and by `weight' in descending order within each group
of lines with constant `height', but retain only one line from each
group of lines with the constant `last' and `first', and name the new
dataset `people.srt':_
     sort("people", "last first", "u dd");


File: dap,  Node: Merging datasets,  Next: Displaying a dataset,  Prev: Sorting a dataset,  Up: Managing and displaying data

Merging datasets
================

SPECIFICATION
     merge(DATASET1, VARIABLE-LIST1, DATASET2, VARIABLE-LIST2, PARTVARS, OUTPUTSET)
     DATASET1, VARIABLE-LIST1, DATASET2, VARIABLE-LIST2, PARTVARS, OUTPUTSET: string

Description

   Performs a many-to-one or one-to-one merge of DATASET1 and DATASET2
and writes the result to OUTPUTSET.  (For usage in an SBS `data' step,
see *Note Appendix IV::.)  A variable is renamed in the output dataset
if the variable name is followed by `> NEWNAME'.  Only the variables in
VARIABLE-LIST1, renamed if requested, are included from DATASET1 and
only the variables in VARIABLE-LIST2, renamed if requested, are
included from DATASET2; these two variable lists must be disjoint.
Individual array elements may not be referenced in the variable lists;
array names must appear without bracketed indices.  If either variable
list is a `NULL' pointer, then no variables are included from that
dataset; this can be used to select observations from a dataset.  If
either variable list is the null string ("", not `NULL'), then all
variables from that dataset are included.  If either variable list
contains the character `!' before the first variable name, then the
named variables are excluded from, not included in, the output dataset.
If PARTVARS is not the null string or `NULL', then matching is based on
the variables in PARTVARS: for each part of the datasets DATASET1 and
DATASET2 specified by the variables in PARTVARS, the first observation
in DATASET2 is matched with all observations from DATASET1; both
datasets must be sorted by PARTVARS before merging.  Otherwise,
observations in the two datasets are matched one-to-one until one or
both datasets are exhausted.

Code fragment(s)

   _Merge datasets `pretreat' and `posttreat' into a new dataset
`changes' by matching lines with corresponding values of `name'; retain
the values of `name' and `preweight' from `pretreat' and the values of
`postweight' from `posttreat':_
     merge("pretreat", "name preweight",
           "posttreat", "postweight", "name", "changes");

   _Merge datasets `pretreat' and `posttreat' into a new dataset
`changes' by matching lines with corresponding values of `name'; retain
the values of `name' and `weight' from `pretreat' and the values of
`weight' from `posttreat', but change the name of `weight' from
`pretreat' to `preweight' and the name of `weight' from `posttreat' to
`postweight' in the dataset `changes':_
     merge("pretreat", "name weight>preweight",
           "posttreat", "weight>postweight", "name", "changes");


File: dap,  Node: Displaying a dataset,  Next: Splitting and joining lines,  Prev: Merging datasets,  Up: Managing and displaying data

Displaying a dataset
====================

SPECIFICATION
     print(DATASET, VARIABLE-LIST)
     DATASET, VARIABLE-LIST: string

     proc print [data=DATASET-NAME];
     var VARIABLE-LIST;

Description

   Displays the values of variables in DATASET.  If VARIABLE-LIST is
NULL or the null string or a string containing only tabs or only
commas, the values of all variables are printed, otherwise just those
of the named variables are printed.  If the variables in VARIABLE-LIST
are separated by spaces, then output contains value of the `_type_'
variable and the observation number.  Otherwise, the variables must be
separated by tabs or commas and the value of the `_type_' variable and
the observation number are omitted.  No special handling is performed
for strings containing tabs or commas.

Code fragment(s)

   _Display the values of all the variables of the dataset `names':_
     print("names", "");

   _Display the values, separated by tabs, of all the variables of the
dataset `names':_
     print("names", "\t");

   _Display the values of `first' and `last' of the dataset `names':_
     print("names", "first last");

   _Display the values, separated by commas, of `first', `middle', and
`last' of the dataset `names':_
     print("names", "first, middle,last");

SPECIFICATION
     table(DATASET, ROW-VARS, COL-VARS, FORMAT, PARTVARS)
     DATASET, ROW-VARS, COL-VARS, FORMAT, PARTVARS: string

     proc tabulate [data=DATASET-NAME] [format=WIDTH.PLACES];
     [class CLASS-VARIABLE-LIST;]
     [var ANALYSIS-VARIABLE;]
     table ROW-VARIABLE-1 [... ROW-VARIABLE-N],
           COLUMN-VARIABLE-1 [... COLUMN-VARIABLE-N] * ANALYSIS-VARIABLE
           [/ {rtspace | rts}=NUMBER];
     by VARIABLE-LIST;

Description

   Displays values from DATASET in tabular form.  The values of the
variables in ROW-VARS label the rows hierarchically and the values of
the variables in COL-VARS label the columns hierarchically except that
the last variable in COL-VARS is the variable of type double whose
values are displayed in the cells of the table.  The string FORMAT is
of either of the two forms, WIDTH.PRECISION or WIDTH.  The first
specifies that WIDTH characters should be allotted for each cell and
PRECISION digits should be displayed to the right of the decimal point.
The second only specifies the number of characters to be allotted for
each cell and lets the program choose the "best" allocation of decimals.
The `table' function does not sort the data except that it sorts the
columns if an `s' appears before the WIDTH.PRECISION specification;
thus, the data must be sorted by the PARTVARS (if any), ROW-VARS, and
COL-VARS before calling `table'.  The WIDTH.PRECISION can also be
followed by a number indicating how many columns to allocate for the
combined row labels, including column dividers.  `Table' does not
process the data and expects at most one value of the numerical
variable for each distinct combination of the row and column variables;
see function `split' (*note Splitting and joining lines::) for datasets
with multiple numerical values to display.

   SBS note: In `proc tabulate', the `class' and `var' statements have
no effect and may be omitted.

Code fragment(s)

   _Display a table, with cells 6 characters long and values displayed
to 1 decimal place, of the values of `height' with the rows labeled by
`last' and `first' and the columns labeled by `county':_
     table("names", "last first", "county height", "6.1", "");

   _Display tables, one for each `state', with cells 6 characters long
and values displayed to 1 decimal place, of the values of `height' with
the rows labeled by `last' and `first' and the columns labeled by
`county':_
     table("names", "last first", "county height", "6.1", "state");

   _Display a table, with cells 6 characters long and values displayed
to 1 decimal place, of the values of `height' with the rows labeled by
`last' and `first' and the columns labeled by `county', with `county'
sorted in ascending order:_
     table("names", "last first", "county height", "s6.1", "");

