\documentclass{book}
\usepackage{imakeidx}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage[gen]{eurosym}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{etoolbox}
\usepackage{enumitem}
\usepackage{titleps}
\usepackage{float}
% use hidelinks to remove boxes around links to be similar to Texinfo TeX
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}

\makeatletter
\newcommand{\Texinfosettitle}{Dap}%

% no index headers or page break
\indexsetup{level=\relax,toclevel=section,noclearpage}%
\makeindex[name=in,title=]%

% style command for kbd in 'cmd_text' formatting context
\newcommand\Texinfocommandstyletextkbd[1]{{\ttfamily\textsl{#1}}}%

% style command for var in 'cmd_text' formatting context
\newcommand\Texinfocommandstyletextvar[1]{{\normalfont{}\textsl{#1}}}%

% redefine the \mainmatter command such that it does not clear page
% as if in double page
\renewcommand\mainmatter{\clearpage\@mainmattertrue\pagenumbering{arabic}}
\newenvironment{Texinfopreformatted}{%
  \par\GNUTobeylines\obeyspaces\frenchspacing\parskip=\z@\parindent=\z@}{}
{\catcode`\^^M=13 \gdef\GNUTobeylines{\catcode`\^^M=13 \def^^M{\null\par}}}
\newenvironment{Texinfoindented}{\begin{list}{}{}\item\relax}{\end{list}}


% set defaults for lists that match Texinfo TeX formatting
\setlist[itemize]{label=\textbullet}
\setlist[enumerate]{label=\arabic*.}

% used for substitutions in commands
\newcommand{\Texinfoplaceholder}[1]{}

\newpagestyle{double}{\sethead[\thepage{}][][\Texinfosettitle]
                              {\chaptername{} \thechapter{} \chaptertitle{}}{}{\thepage}}

% allow line breaking at underscore
\let\Texinfounderscore\_
\renewcommand{\_}{\Texinfounderscore\discretionary{}{}{}}
\makeatother
% set default for @setchapternewpage
\makeatletter
\patchcmd{\chapter}{\if@openright\cleardoublepage\else\clearpage\fi}{\Texinfoplaceholder{setchapternewpage placeholder}\clearpage}{}{}
\makeatother

% no headings before titlepage
\pagestyle{empty}%




\makeatletter
\patchcmd{\chapter}{\Texinfoplaceholder{setchapternewpage placeholder}\clearpage}{\if@openright\cleardoublepage\else\clearpage\fi}{}{}
\makeatother


\begin{document}

\frontmatter
\begin{titlepage}
\begingroup
\newskip\titlepagetopglue \titlepagetopglue = 1.5in
\newskip\titlepagebottomglue \titlepagebottomglue = 2pc
\setlength{\parindent}{0pt}
% Leave some space at the very top of the page.
    \vglue\titlepagetopglue
{\raggedright {\huge \bfseries Gnu Dap}}
\vskip 4pt \hrule height 4pt width \hsize \vskip 4pt
\rightline{Data analysis \& presentation}

\vskip 0pt plus 1filll
\leftline{\Large \bfseries Gnu Dap Contributors}%

\vskip4pt \hrule height 2pt width \hsize
  \vskip\titlepagebottomglue
\endgroup
\newpage{}%
\phantom{blabla}%
\vskip 0pt plus 1filll
Copyright \copyright{} 2001, 2002, 2003, 2004,2014
Free Software Foundation, Inc.

Published by the Free Software Foundation \leavevmode{}\\
59 Temple Place Suite 330 \leavevmode{}\\
Boston, MA 02111-1307 \leavevmode{}\\
USA \leavevmode{}\\

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Free Software Foundation.
\end{titlepage}
\pagestyle{double}%
\mainmatter
\tableofcontents\newpage
\label{anchor:Top}%
\chapter{{Overview and invocation}}
\label{anchor:Overview-and-invocation}%


\section{{Description, an example, and reading this manual}}
\label{anchor:Description-and-example}%

Dap is a small statistics and graphics package based on C.
As of Version 3.0, dap can read SAS programs to perform basic statistical
analyses, thus freeing the user from learning and using C syntax
for straightforward tasks,
while retaining access to the C-style graphics and statistics
features provided by the original implementation (see \hyperref[anchor:Appendix-IV]{\chaptername~\ref*{anchor:Appendix-IV} [Appendix IV], page~\pageref*{anchor:Appendix-IV}}).
Dap provides core methods of data management,
analysis, and graphics commonly used in statistical
consulting practice.
Anyone familiar with the basic syntax of C
\index[in]{C@C}%
\index[in]{syntax@syntax}%
programs can learn to use the C-style features of
dap quickly and easily from this manual and the examples it provides;
advanced features of C are not necessary,
although they are available.
(\hyperref[anchor:Appendix-II]{\chaptername~\ref*{anchor:Appendix-II} [Appendix II], page~\pageref*{anchor:Appendix-II}} provides a brief description of the C syntax needed to use
those features of dap dependent on it.)
Because dap processes files one line at a time, rather than reading entire files
into memory, it can be used on data sets that have very large numbers of lines
and/or large numbers of variables.

Dap consists of: an interactive front end that
controls editing, compiling, execution, and viewing;
an optional SAS-to-C-style-dap translator that can convert an SAS program into
a C-style dap program;
a preprocessor that facilitates data input and output by
converting a C-style dap program into an ordinary C program; and a library of
statistics functions and graphics functions.
Typical use of dap involves the following steps:

\begin{enumerate}[start=1]
\item Obtain, or use a text editor to create, one or more data files in acceptable
formats.
\item Invoke (i.e., run) `\texttt{dap}' to create or view an SAS or C-style
dap program that will read and process the data file(s) to
produce tables and/or graphics.
(See \hyperref[anchor:Invoking-Dap]{Section~\ref*{anchor:Invoking-Dap} [Invoking Dap], page~\pageref*{anchor:Invoking-Dap}} to find out how to run dap.
If you want to use the C-style features of dap and
are unfamiliar with C, read \hyperref[anchor:Appendix-II]{\chaptername~\ref*{anchor:Appendix-II} [Appendix II], page~\pageref*{anchor:Appendix-II}} before creating
your C-style dap program.)
\item Tell dap to compile (i.e., translate into machine usable form) your SAS
or C-style dap program and execute (i.e., run) your program.
\item If the previous step was successful, view your tables and/or
graphics; otherwise, if there are errors in your program, you will have to edit your program
further and repeat Step 3.
\end{enumerate}

The following program examples illustrate the basic structure
of simple SAS and C-style dap programs and how functions in the library are used in dap.

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily /* A SIMPLE SAS PROGRAM */
data;\                  /* Begin data step */
\ infile "two" delimiter="\textbackslash{}t" firstobs=2;
\                       /* The infile statement:\ identifies "two" as
\                        * the file to read from,\ specifies that
\                        * the delimiter is a tab,\ i.e.\ the numbers
\                        * in each line in "two" are separated by a
\                        * single tab character,\ and directs the
\                        * program to skip one header line and start
\                        * data input on the second line of the file "two".
\                        */
\ input x y;\            /* The first number on each line of "two"
\                        * will be held in x and the second number
\                        * will be held in y
\                        */
proc plot;\             /* Run the plot procedure to display a scatter-plot...\ */
\ plot y * x / box;\     /* ...using y for the vertical axis and x for the
\                        * horizontal and enclosing the plot in a box
\                        */

\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily /* A SIMPLE C-STYLE DAP PROGRAM */
\#include <dap.h>       /* REQUIRED:\ includes prototypes of
\                        * statistics and graphics functions
\                        */

void main()            /* REQUIRED:\ main runs everything */
\{
/* This part of the program reads in data from an ordinary file
\ * and writes it out to a dataset,\ which is the kind of file
\ * on which the library functions can operate to perform
\ * exploratory data analysis,\ graphical interpretation,\ and
\ * statistical analyses.
\ */
infile("two",\ "\textbackslash{}t")    /* The infile statement:\ identifies "two" as
\                        * the file to read from and specifies that
\                        * the delimiter is a tab,\ i.e.\ the numbers
\                        * in each line in "two" are separated by a
\                        * single tab character
\                        */
\  \{\                    /* Beginning of infile statement body */
\  double x,\ y;\         /* specify that x and y are variables that
\                        * hold \textsl{double-precision floating point}
\                        * numbers,\ i.e.,\ numbers that are not
\                        * necessarily whole numbers
\                        */
\  input("x y");\        /* The first number on each line of "two"
\                        * will be held in x and the second number
\                        * will be held in y
\                        */
\  outset("xyset",\ "");\ /* Create a dataset "xyset" and write all
\                        * the variables to it
\                        */
\  skip(1);\             /* The data file contains 1 header line;
\                        * skip it
\                        */
\  while (step())       /* Read in the file,\ one line at a time */
\    output();\          /* and write it to the dataset "xyset" */
\  \}\                    /* end of infile statement body */

/* This line runs the plot function to get a scatter-plot,\ then
\ * displays the result graphically using the nport function;\ the
\ * various options used are described in the section for the plot
\ * and nport functions.\  
\ */
nport(plot("xyset",\ "x y",\ "",\ "==",\ NULL,\ NULL,\ 1),\ 1,\ 1);
\}
\end{Texinfopreformatted}
\end{Texinfoindented}

For each C-style dap function, this manual
\index[in]{manual@manual}%
\index[in]{reading this manual@reading this manual}%
gives:

\begin{enumerate}[start=1]
\item \textbf{SPECIFICATION}: This is an abstract template for the function that indicates the
types of the parameters (string,
\index[in]{string@string}%
\index[in]{array of char@array of char}%
\index[in]{char, array@char, array}%
i.e., array of char, double, array of double, int,
or array of int), and the return value, if any; \textbf{bold face} indicates
literal text, \Texinfocommandstyletextvar{italics} indicates parameters for which you choose your own
names. The corresponding SAS template, if available, is also provided.

\item \textbf{Description}: A description of the functionality and use of the function.
If there is a corresponding SAS proc, notes on its usage follow.

\item \textbf{Code fragment(s)}: These are one or more examples of calling the function, with made-up values
for the parameters; for complete examples of use, see the final chapter
(see \hyperref[anchor:Examples]{\chaptername~\ref*{anchor:Examples} [Examples], page~\pageref*{anchor:Examples}}) or consult the index.  
\end{enumerate}

\index[in]{SAS syntax@SAS syntax}%
For the SAS templates, the following should be noted.
Elements within square brackets `\texttt{[ ]}' are optional and
some, although permitted, may have no effect.
Elements within braces `\texttt{\{\ \}}', separated by a vertical bar `\texttt{|}' are
alternatives.
Keywords may be in upper or lower case.
Single and double quotes must be used as in C, i.e., use double quotes
for strings (whether or not they are one character long) and
use single quotes only for character values.
Not all statements listed below the `\texttt{data}' or `\texttt{proc}'
statements are required and multiple statements of some types may be allowed.

\section{{Invoking Dap}}
\label{anchor:Invoking-Dap}%
\index[in]{running Dap@running Dap}%
\index[in]{invoking Dap@invoking Dap}%

To run dap, you must type a command which looks like one of the following
(in which the bracketed items are optional and are described below):

\noindent{}\textbf{SPECIFICATION}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dap [-k] [-d] \Texinfocommandstyletextvar{file1}.c [ \Texinfocommandstyletextvar{file2}.c ... ] [-a \Texinfocommandstyletextvar{arg1} ...]}
\textbf{dap [--keep] [--debug] \Texinfocommandstyletextvar{file1}.c [ \Texinfocommandstyletextvar{file2}.c ... ] [--args \Texinfocommandstyletextvar{arg1} ...]}
\textbf{dap [-k] [-d] \Texinfocommandstyletextvar{file1}.sbs [ \Texinfocommandstyletextvar{file2}.c ... ]}
\textbf{dap [--keep] [--debug] \Texinfocommandstyletextvar{file1}.sbs [ \Texinfocommandstyletextvar{file2}.c ... ]}
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

The following description is based on using the GNU editor Emacs to
interact with dap.
If you don't use Emacs, you can still use dap, but in the commands
specified above, use `\texttt{daprun}' in place of `\texttt{dap}'; in that case,
you will have to open your editor and/or file viewer to edit your program
and view your text output.

When you type the command to run dap:

\begin{enumerate}[start=1]
\item The editor Emacs (type the command \texttt{info emacs}
for the manual) is opened for the named SAS or C-style dap file(s).
Each file is created, but is empty, if it doesn't exist.
When you are finished editing your file(s), save it (them), but do not
exit unless you are finished running dap.
\item Emacs will have a buffer called `\texttt{Async Shell Command}'; select that buffer
and you will be
asked whether to compile the named SAS or C file(s) and run the resulting
executable file (if the compilation is successful).
If you answer `\texttt{y}', then dap
runs the preprocessor on the named SAS or C file(s) to produce
\Texinfocommandstyletextvar{file1}.dap.c [ \Texinfocommandstyletextvar{file2}.dap.c ... ].
If you answer `\texttt{q}', then dap stops running (and you can either leave Emacs
running for some other purpose or exit it).

\item If the preprocessing is successful, 
then dap runs a C compiler on the preprocessed file(s), linking
library functions as necessary, to produce \Texinfocommandstyletextvar{file1}.dap.
\item If the compilation is successful, then dap removes the \texttt{dap.c} file(s)
(unless the `\texttt{-d}' or `\texttt{{-}{-}debug}' option is present) and
runs the executable \Texinfocommandstyletextvar{file1}.dap, passing the arguments
\Texinfocommandstyletextvar{arg1}, ..., if any, and produces \Texinfocommandstyletextvar{file1}.lst file for tables
\index[in]{tables@tables}%
\index[in]{lst file@lst file}%
and \Texinfocommandstyletextvar{file1}.ps for graphics, as requested.
\index[in]{graphics@graphics}%
\index[in]{ps file@ps file}%
There are Emacs buffers for
the \texttt{lst} and \texttt{log} files, but you must use
`\texttt{Revert buffer}'
\index[in]{lst file@lst file}%
in the `\texttt{File}' menu to see the most recent results.
A viewer will be opened for the \texttt{ps} file,
if it exists.

\item Each time a dataset or datafile is read through to the end
during execution, the number
of lines read from the dataset or datafile is displayed in your
`\texttt{Async Shell Command}' buffer and written to the \texttt{log} file.
If `\texttt{dap\_outreport}' (see \hyperref[anchor:Appendix-I]{\chaptername~\ref*{anchor:Appendix-I} [Appendix I], page~\pageref*{anchor:Appendix-I}}) is positive
(default: 100000), then dap reports, in your `\texttt{Async Shell Command}' buffer,
each time that an additional `\texttt{dap\_outreport}'
lines have been written to a dataset;
if your program is writing to a dataset inside an infinite loop,
this helps you abort the program to avoid filling up your disk
(by holding down the `\texttt{Ctrl}' key and pressing the `\texttt{C}' key \emph{twice}).
\index[in]{abort@abort}%

\item If there were errors or warnings, they will be written
to the \texttt{err} and you will see them displayed in your
`\texttt{Async Shell Command}' buffer.

\item At this point, you can edit (and save!) your SAS or C-style dap files again or quit.
\end{enumerate}

If the `\texttt{-a}' or `\texttt{{-}{-}args}'
\index[in]{arguments@arguments}%
\index[in]{command line arguments@command line arguments}%
option is present (C-style dap programs only),
then all the arguments that follow it on the command
are passed to the `\texttt{main}' in your program as `\texttt{argv}'.
In all cases, the \texttt{lst} and \texttt{ps} files
\index[in]{lst file@lst file}%
\index[in]{ps file@ps file}%
are removed before the
first execution, but if the `\texttt{-k}' or `\texttt{{-}{-}keep}' option is present, then the \texttt{lst}
file is kept
\index[in]{keep lst file@keep \texttt{lst} file}%
and appended to from one cycle to the next.  
(Keeping the \texttt{lst} file from one cycle to the next can be useful for
exploratory data analysis,
\index[in]{exploratory data analysis@exploratory data analysis}%
\index[in]{keep lst file@keep \texttt{lst} file}%
such as model building for linear regression
or loglinear models, in which it is useful to have a record of a
succession of analyses without running the cumulative set of analyses
repeatedly.)

\textbf{NOTE:} If your system uses `\texttt{locale}'s, then you must set
your environment variable `\texttt{LC\_COLLATE}' to `\texttt{C}' in order to
obtain correct sorting.

The editor
\index[in]{editor@editor}%
invoked is /usr/bin/emacs unless the environment variable `\texttt{DAPEDITOR}'
specifies a different location for Emacs.
Emacs is invoked with no options unless the environment variable
`\texttt{DAPEDOPTS}' is set to a single string of all the options desired.  
The compiler
\index[in]{compiler@compiler}%
used is /usr/bin/gcc unless the environment variable `\texttt{DAPCOMPILER}'
is set to a different compiler.
The compiler is invoked with no options unless the environment variable
`\texttt{DAPCOMPOPTS}' is set to a single string of all the options desired.  
The \texttt{lst} file is displayed in its entirety in its buffer
unless the environment variable `\texttt{DAPPAGER}' is set to a pager
(such as \texttt{more}).
That pager is invoked with no options unless the environment variable
`\texttt{DAPPAGEOPTS}' is set to a single string of all the options desired.  
The \texttt{ps} file is viewed
\index[in]{viewer@viewer}%
with /usr/bin/X11/gv unless the environment variable `\texttt{DAPVIEWER}'
is set to a different graphics viewer.
The viewer is invoked with no options unless the environment variable
`\texttt{DAPVIEWOPTS}' is set to a single string of all the options desired.  

The executable \Texinfocommandstyletextvar{file1}.dap can be run, or debugged,
\index[in]{debugging@debugging}%
on its own.
If the `\texttt{-a}' or `\texttt{{-}{-}args}'
\index[in]{arguments@arguments}%
\index[in]{command line arguments@command line arguments}%
option was used when the source files were processed, then arguments
\index[in]{arguments@arguments}%
(without the `\texttt{-a}' or `\texttt{{-}{-}args}') are used on the command line.
If you want to use `\texttt{gdb}'
to debug \Texinfocommandstyletextvar{file1}.dap, include `\texttt{-g}' as one
of your compiler options and use the `\texttt{-d}' or `\texttt{{-}{-}debug}' option when you run
dap so that the \texttt{.dap.c} files will not be removed.

\noindent{}\textbf{Code fragment(s)}

\emph{Run \texttt{dap} on the file \texttt{tweedle.c}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily dap tweedle.c
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Run \texttt{dap} on the file \texttt{tweedle.sbs}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily dap tweedle.sbs
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Run \texttt{dap} on the files \texttt{tweedle.c} and \texttt{dee.c}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily dap tweedle.c dee.c
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Run \texttt{dap} on the files \texttt{tweedle.sbs} and \texttt{dee.c}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily dap tweedle.sbs dee.c
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Run \texttt{dap} on \texttt{tweedle.c}; append to \texttt{tweedle.lst} in each cycle:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily dap -k tweedle.c
dap {-}{-}keep tweedle.c
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Run \texttt{dap} on \texttt{tweedle.c}; pass arguments `\texttt{17}'
and `\texttt{dum}' to `\texttt{main}' in \texttt{tweedle.c}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily dap tweedle.c -a 17 dum
dap tweedle.c {-}{-}args 17 dum
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Run \texttt{dap} on \texttt{tweedle.c}; do not remove \texttt{tweedle.dap.c} for debugging:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily dap -d tweedle.c
dap {-}{-}debug tweedle.c
\end{Texinfopreformatted}
\end{Texinfoindented}

\chapter{{Program structure}}
\label{anchor:Program-structure}%

This chapter concerns C-style dap programs only.


\section{{Reading files and datasets}}
\label{anchor:Reading-files-and-datasets}%

\index[in]{preprocessor@preprocessor}%
\index[in]{dappp@dappp}%
This section and the next apply only to C-style dap programs.
C-style dap programs are C programs with two additional statement types
and additional library functions to perform statistical and graphical tasks.
All C-style dap programs must contain a line

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily \#include <dap.h>
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}to include the dap header file
\index[in]{header file@header file}%
\index[in]{dap.h@dap.h}%
before the function `\texttt{main}' and any variable declarations, except that
if the program resides in more than one \texttt{C} file, only one of those
files must include \texttt{dap.h} while the others must include \texttt{dap1.h} instead.
\index[in]{dap1.h@dap1.h}%
(This is to avoid multiple definitions
\index[in]{multiple definition error@multiple definition error}%
of dap parameters.)

The two additional statement types are `\texttt{infile}' and `\texttt{inset}'
\index[in]{infile@infile}%
\index[in]{inset@inset}%
statements, which
are used to set up input from files and datasets and which
have the following syntaxes:

\noindent{}\textbf{SPECIFICATION}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{infile(\Texinfocommandstyletextvar{datafile}, \Texinfocommandstyletextvar{delimiter}) \{ \dots{}\@ \}}
\Texinfocommandstyletextvar{datafile}, \Texinfocommandstyletextvar{delimiter:} string

\textbf{inset(\Texinfocommandstyletextvar{dataset}) \{ \dots{}\@ \}}
\Texinfocommandstyletextvar{dataset:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

The body of `\texttt{infile}' and `\texttt{inset}' statements
may contain local variable declarations, an `\texttt{outset}'
statement, and statements to process the input file or dataset.
In addition, the body an `\texttt{infile}' statement may contain an
`\texttt{input}' statement.

The local variable declarations
\index[in]{local variable@local variable}%
\index[in]{declaration@declaration}%
in the body of `\texttt{infile}' and `\texttt{inset}' statements
are restricted to the following types:

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double name;
double name[number];
double name[string];
int name;
int name[number];
int name[string];
char name[number];
char name[string];
\end{Texinfopreformatted}
\end{Texinfoindented}

When the dimension
\index[in]{dimension@dimension}%
of the array
\index[in]{array@array}%
is given as a string, that string must
appear in a `\texttt{\#define}' somewhere in the file before the declaration.

A program can generate data without reading from
a file.  In that case, an `\texttt{infile}' statement
\index[in]{infile@infile}%
is still required, but both
arguments can be given as `\texttt{NULL}'.  

The delimiter
\index[in]{delimiter@delimiter}%
argument to an `\texttt{infile}'
\index[in]{infile@infile}%
statement can be in one of two forms, one for
delimited fields and the other for fixed-width
\index[in]{fixed-width@fixed-width}%
fields.
If the file to be read is simply delimited text, the
the delimiter argument is a string (not a character) consisting
of the single delimiter character.  If the file has fixed-width fields, then
the delimiter argument is an alternating sequence of any non-numerical
character and numbers that specify the field widths, in order and
without spaces (unless the non-numerical character is a space).  For
example:

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily infile("data",\ "x6x5x8")
or for sbs
PROC IMPORT  out = data datafile =  "Pres2007Clustered.csv"  dbms  = csv //support tab and dlm
delimiter = ',' replace ;\  //support getnames=yes/no;
run ;
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}specifies three data fields of widths 6, 5, and 8, respectively.

It is inappropriate to call a dap statistics or graphics function from
within the body of an `\texttt{infile}' or `\texttt{inset}' statement; results from such a
call are unpredictable.

The header file \texttt{dap.h} defines parameters
\index[in]{header file@header file}%
\index[in]{dap.h@dap.h}%
\index[in]{execution@execution}%
\index[in]{parameters@parameters}%
\index[in]{constants@constants}%
\index[in]{settable parameters@settable parameters}%
that control the execution of dap.  For example, `\texttt{dap\_maxvar}' is the maximum
number of variables allowed in any dataset.
To change any of these parameters, use a preprocessor `\texttt{\#define}' line
in your program \textbf{before} the line that includes `\texttt{dap.h}'.
For example,

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily \#define DAP\_MAXVAR 512
\#include <dap.h>
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}will set the maximum number of variables to 512 instead of the default 256.
Note that such a `\texttt{\#define}' line does \emph{not} end with a semi-colon.

It is not necessary to use a `\texttt{\#define}' such as the one above
if you do not wish to change the values of the parameters from their defaults.
However, some dap functions have limitations
\index[in]{memory allocation@memory allocation}%
\index[in]{insufficient memory@insufficient memory}%
on how many values
they can process at one time and if you have a dataset that is particularly large,
then you may receive a memory allocation error message.
That message will usually contain a suggestion of which parameter
may need changing.  The parameters available for modification are listed
in Appendix I (see \hyperref[anchor:Appendix-I]{\chaptername~\ref*{anchor:Appendix-I} [Appendix I], page~\pageref*{anchor:Appendix-I}}).

\noindent{}\textbf{Code fragment(s)}

\emph{Read space-delimited data file \texttt{tweedledee} with
values for `\texttt{name}', `\texttt{wages}', and `\texttt{tips}' on each line and
write those values to dataset \texttt{tweedledee}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily infile("tweedledee",\ " ")
\  \{
\    char name[21];
\    double wages,\ tips;
\    input("name wages tips");
\    outset("tweedledee",\ "");
\    while (step())
\      output();
\  \}
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Read from dataset \texttt{tweedledee}, compute `\texttt{income}'
as the sum of `\texttt{wages}' and `\texttt{tips}',
and write to dataset \texttt{tweedledum}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily inset("tweedledee")
\  \{
\    double wages,\ tips,\ income;
\    outset("tweedledum",\ "");
\    while (step())
\      \{
\        income = wages + tips;
\        output();
\      \}
\  \}
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Variables}}
\label{anchor:Variables}%

This section applies only to C-style dap programs.
The variables declared in the body of an `\texttt{infile}'
\index[in]{infile@infile}%
or `\texttt{inset}'
\index[in]{inset@inset}%
statement
are available for reading from the specified file or dataset and for
writing to the specified dataset.  It is not necessary to
declare
\index[in]{declaration@declaration}%
all the variables in an input or output dataset; only those variables
that are used explicitly in a statement in the body of the `\texttt{infile}' or `\texttt{inset}'
statement
(i.e., not in a quoted string as an argument to
a function such as `\texttt{input}', `\texttt{outset}', or `\texttt{dap\_list}'),
must be declared.
\index[in]{unknown variable@unknown variable}%
\index[in]{undeclared@undeclared}%
\index[in]{variable@variable}%
\index[in]{declaration@declaration}%
Avoid using variable (or function) names
\index[in]{variable names@variable names}%
that begin with
`\texttt{dap\_}' or `\texttt{pict\_}' or end with `\texttt{dap\_}'.
WARNING: Within an `\texttt{inset}' statement, if you declare and set the value
of a variable that is already in the dataset
referenced by the `\texttt{inset}' statement, values that your program gives to
that variable will be overwritten on each call to `\texttt{step}'.
\index[in]{bug@bug}%

Data management, statistics, graphics, and other C-style dap functions take lists of variables
as arguments.  Such lists must always be given as strings
\index[in]{variables as arguments@variables as arguments}%
\index[in]{variable lists@variable lists}%
of variable names (sometimes with other specifications included), separated by
spaces (not commas).
\index[in]{commas, not@commas, not}%
Generally, the null string ("", not `\texttt{NULL}')
\index[in]{null string@null string}%
is a shorthand
for a list of all the variables in the dataset and `\texttt{NULL}'
\index[in]{NULL@NULL}%
is a shorthand
for none of the variables in the dataset.

Arrays
\index[in]{array@array}%
of int or double may be referenced, by the array name with no brackets or indices,
in calls to `\texttt{input}' and
\index[in]{input@input}%
`\texttt{outset}'.
\index[in]{outset@outset}%
Individual array elements, with their bracketed indices,
may also be referenced in calls to those same functions, but not in calls to
`\texttt{dataset}'
\index[in]{dataset@dataset}%
or `\texttt{merge}',
\index[in]{merge@merge}%
for which arrays of int or double must be referenced by the array name,
with no brackets or indices.
For all other C-style dap functions, each element of an array of
int or double that is to be used must appear with its bracketed index.  

\section{{Output: the \texttt{err}, \texttt{log}, \texttt{lst}, and \texttt{ps} files}}
\label{anchor:Output-files}%

The user's program can write directly to the \texttt{lst} and \texttt{log} files using
stream functions (`\texttt{putc}', `\texttt{fputs}', `\texttt{fprintf}', etc.)
on `\texttt{dap\_lst}' and `\texttt{dap\_log}', respectively.
The following function may be called to display
a section header in the \texttt{lst} file:
\index[in]{dap\_head@dap\_head}%
\index[in]{header@header}%
\index[in]{lst file@lst file}%
\index[in]{log file@log file}%

\noindent{}\textbf{SPECIFICATION}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dap\_head(\Texinfocommandstyletextvar{partv}, \Texinfocommandstyletextvar{npartv})}
\Texinfocommandstyletextvar{partv:} array of int
\Texinfocommandstyletextvar{npartv:} int
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

If \Texinfocommandstyletextvar{partv} is not `\texttt{NULL}', the header includes
the values of the variables defining a part of the file
or dataset (see \hyperref[anchor:Partitioning-a-dataset]{Section~\ref*{anchor:Partitioning-a-dataset} [Partitioning a dataset], page~\pageref*{anchor:Partitioning-a-dataset}}).
NOTE: `\texttt{dap\_head}' makes a system call to `\texttt{time}'
and calls the GNU library function `\texttt{ctime}'; consequently,
user-defined functions with those names will interfere with
the date displayed by `\texttt{dap\_head}'.

\noindent{}\textbf{Code fragment(s)}

\emph{Write header, with current title, if any, to \texttt{lst} file:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily while (step())
\  \{
\    ...
\    dap\_head(NULL,\ 0);
\    ...
\  \}
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{With input dataset sorted by
the variables `\texttt{state}', `\texttt{county}', and `\texttt{city}',
write header, with current title, if any, and with current values of
`\texttt{state}', `\texttt{county}', and `\texttt{city}',
to \texttt{lst} file:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily int fooparts[3];
...
dap\_list("state county city",\ fooparts,\ 3);
while (step())
\  \{
\    ...
\    dap\_head(fooparts,\ 3);
\    ...
\  \}
\end{Texinfopreformatted}
\end{Texinfoindented}

A title may be specified as part of the section head or as caption
in graphical output by calling:

\index[in]{title@title}%
\index[in]{caption@caption}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{title(\Texinfocommandstyletextvar{the-title})}
\Texinfocommandstyletextvar{thetitle:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
title "\Texinfocommandstyletextvar{the-title}";
\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{title (SAS statement)@title (SAS statement)}%

\noindent{}\textbf{Description}

The string \Texinfocommandstyletextvar{the-title} may contain newline ('\textbackslash{}n') characters for multi-line titles.
For graphical output captions, subscripts
\index[in]{subscripts@subscripts}%
are specified by enclosing them
in vertical bars (`\texttt{|}') and superscripts
\index[in]{superscripts@superscripts}%
are specified by enclosing them in
carets (`\texttt{\^{}}').
If a title has been specified by `\texttt{title}',
then a graphics function that produces a separate page for each part of a
partitioned dataset will include in the caption the value(s) of the variable(s)
defining the partition.

\noindent{}\textbf{Code fragment(s)}

\emph{Set title for `\texttt{dap\_head}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily title("Analysis of variance\textbackslash{}nfor crop yields");
title("CFU per cm\^{}2\^{} of surface area");
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{The preprocessor: dappp}}
\label{anchor:The-preprocessor}%

The preprocessor, which is named dappp, reads \Texinfocommandstyletextvar{file}.c,
performs the following four actions to create \Texinfocommandstyletextvar{file}.dap.c:  

\begin{enumerate}[start=1]
\item Process simple `\texttt{\#defines}' of the form:
\index[in]{\#define@\#define}%
\index[in]{define@define}%

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily \#define \Texinfocommandstyletextvar{string}\ \Texinfocommandstyletextvar{n}
\end{Texinfopreformatted}
\end{Texinfoindented}

in which \Texinfocommandstyletextvar{string} starts with a letter or with `\texttt{\_}' and
\Texinfocommandstyletextvar{n} is a positive integer.  

\item Replace `\texttt{main}' with `\texttt{dap\_main}'
\index[in]{dap\_main@dap\_main}%
\index[in]{main@main}%
so that the `\texttt{main}' internal to dap can
set up variables and the output files before calling `\texttt{dap\_main}'.

\item Append a semicolon to each `\texttt{infile}' or `\texttt{inset}' statement header to prepare
it for the C compiler.  

\item Append calls to `\texttt{dap\_vd}', `\texttt{dap\_dl}', `\texttt{dap\_il}', and `\texttt{dap\_sl}'
\index[in]{dap\_vd@dap\_vd}%
\index[in]{dap\_dl@dap\_dl}%
\index[in]{dap\_il@dap\_il}%
\index[in]{dap\_sl@dap\_sl}%
after declarations in the body of `\texttt{infile}' and `\texttt{inset}' statements.  

\end{enumerate}

The `\texttt{dap\_vd}'
\index[in]{dap\_vd@dap\_vd}%
function tells the internal dap routines
the names and types of variables so that datasets can be processed
appropriately.  The `\texttt{dap\_dl}', `\texttt{dap\_il}', and `\texttt{dap\_sl}'
\index[in]{dap\_dl@dap\_dl}%
\index[in]{dap\_il@dap\_il}%
\index[in]{dap\_sl@dap\_sl}%
functions create links
between the variables in the user's program and the internal dap storage
to allow input and output.
These functions are appended to the last line of the user's declarations
so that line numbers in C compiler messages for \Texinfocommandstyletextvar{file}.dap.c correspond
exactly to line numbers in \Texinfocommandstyletextvar{file}.c.  

\chapter{{Datasets}}
\label{anchor:Datasets}%

Datasets
\index[in]{dataset@dataset}%
are data files with an additional first line that
specifies the names and types of the variables whose values follow.
The only other differences between datasets and data files are that
(1) integers and double precision floating point numbers are encoded
as text in a way that loses no precision and which allows sorting
to be performed in the usual alphanumeric order and (2) the delimiter
between fields on a line is always `\texttt{|}'.  (A consequence of this
is that string values
\index[in]{string values@string values}%
\index[in]{delimiter@delimiter}%
cannot contain `\texttt{|}'.)

\index[in]{partitioning a dataset@partitioning a dataset}%
\index[in]{dataset, partitioning@dataset, partitioning}%
\index[in]{partvars@partvars}%
Most C-style dap data management, statistics, and graphics functions
have an argument, called \Texinfocommandstyletextvar{partvars} in the specifications,
that allows parts of a dataset to be processed separately.
(SAS programs use a `\texttt{by}' statement.)
To do that, first sort the dataset by the values of an
ordered list of variables: each part is defined as a set of lines
for which the values of all of those variables are constant.
Then the same variables in the same order must be named in the \Texinfocommandstyletextvar{partvars} argument 
of the function that is subsequently used to process the sorted dataset. 
If no partitioning is desired, then \Texinfocommandstyletextvar{partvars} should be the null string ("").

Dap allows datasets
\index[in]{dataset in memory@dataset in memory}%
\index[in]{dataset, small@dataset, small}%
\index[in]{dataset on disk@dataset on disk}%
that are not too large to be stored in memory instead of on disk in order
to speed processing.
To specify that a dataset is to be stored in memory,
precede the name of the dataset with a `\texttt{<}'
in the call to `\texttt{outset}' that creates it and in calls to functions that read it.
Note that a dataset that is stored in memory will not be retained after the
current dap session.

Only the last section in this chapter, `\texttt{Manage datasets}', has information
relevant to SAS programs.
For input for SAS programs, see See \hyperref[anchor:Appendix-IV]{\chaptername~\ref*{anchor:Appendix-IV} [Appendix IV], page~\pageref*{anchor:Appendix-IV}}.


\section{{Input and output}}
\label{anchor:Input-and-output}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{input(\Texinfocommandstyletextvar{variable-list})}
\Texinfocommandstyletextvar{variable-list:} string
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{input@input}%

\noindent{}\textbf{Description}

The string \Texinfocommandstyletextvar{variable-list}
is a space-separated list of the names of the variables,
in order, on each line of the data file to be read;
\Texinfocommandstyletextvar{variable-list}
may contain the names of arrays or individual array elements.
Do not call `\texttt{input}' for a dataset.

\noindent{}\textbf{Code fragment(s)}

\emph{Specify that (the beginning of) each line of the
input data file contains two fields whose values are to
be read into the variables `\texttt{fert}' and `\texttt{yield}',
in order:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily input("fert yield");
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{step()}
\Texinfocommandstyletextvar{Returns:} int
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{read a line@read a line}%
\index[in]{input@input}%

\noindent{}\textbf{Description}

Attempts to read one line of the file or dataset specified by `\texttt{infile}'
or `\texttt{inset}', respectively.
Returns 1 if a line was read, 0 if EOF
\index[in]{EOF@EOF}%
\index[in]{end of file@end of file}%
was reached before any characters
were read; in this latter case, all input variables retain their
values from the previous line.
The program exits with an error message if
`\texttt{step}' is called after an EOF was reached.
Missing integer
\index[in]{missing data@missing data}%
data is read in as 0.
Data of type double that is missing or is `\texttt{.}' is set to
NaN\footnote{"Not a Number": see the function `\texttt{finite}'
in the GNU/Linux Programmer's Manual.}.
\index[in]{NaN@NaN}%

\noindent{}\textbf{Code fragment(s)}

\emph{Read all the lines of the current input dataset or data
file and write them to the current output dataset:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily while (step())
\  output();
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{skip(\Texinfocommandstyletextvar{nlines})}
\Texinfocommandstyletextvar{nlines:} int
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{read a line@read a line}%
\index[in]{skip lines@skip lines}%
\index[in]{input@input}%
\index[in]{invalid data@invalid data}%
\index[in]{header lines@header lines}%

\noindent{}\textbf{Description}

Skips \Texinfocommandstyletextvar{nlines} lines of the input data file.
This is useful for skipping header lines in a data file.

\noindent{}\textbf{Code fragment(s)}

\emph{Skip 3 lines of the input data file:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily skip(3);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{outset(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list:} string
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{dataset, output@dataset, output}%
\index[in]{output dataset@output dataset}%
\index[in]{outset@outset}%

\noindent{}\textbf{Description}

The string \Texinfocommandstyletextvar{dataset} is the name of the data set to be written.
The string \Texinfocommandstyletextvar{variable-list}
is either a space-separated list of the names of the variables
to be included in the output data set,
a `\texttt{!}' followed by a space-separated list of the names of the variables
to be excluded from the output data set,
or a null string (not `\texttt{NULL}'), which
specifies that all variables are to be included in the output data set.
The output data set always includes a variable named `\texttt{\_type\_}', which
is a string of length 9 (includes terminating null) and
\index[in]{\_type\_@\_type\_}%
\index[in]{type@type}%
which indicates the type of the observation.
The string \Texinfocommandstyletextvar{variable-list} may contain the names of arrays, without bracketed indices,
or individual array elements, but in either case the entire array is included
in or excluded from the output dataset.

If the dataset
\index[in]{dataset in memory@dataset in memory}%
\index[in]{dataset, small@dataset, small}%
\index[in]{dataset on disk@dataset on disk}%
is small and need not be retained after the current dap session,
then \Texinfocommandstyletextvar{dataset} may begin with a `\texttt{<}' to specify that the dataset is
to be stored in memory rather than on disk; this will speed processing.
The string \Texinfocommandstyletextvar{dataset} must then begin with a `\texttt{<}' in calls to functions that
read it.
If \Texinfocommandstyletextvar{dataset} does not begin with a `\texttt{<}', then
`\texttt{outset}' creates the data set in the subdirectory
`\texttt{dap\_sets}'
\index[in]{dataset@dataset}%
\index[in]{dap\_sets@dap\_sets}%
of the current directory.  If
`\texttt{dap\_sets}' does not exist, `\texttt{outset}' creates it.
A call to `\texttt{outset}' must be preceded by an
`\texttt{infile}' or `\texttt{inset}' statement;
if no input file or dataset is desired, you may use
`\texttt{NULL}' as the file specified by `\texttt{infile}' and `\texttt{NULL}' as the delimiter string.

\noindent{}\textbf{Code fragment(s)}

\emph{Name the output dataset `\texttt{tweedledee}' and
specify that it will contain the values of the variables
`\texttt{alice}' and `\texttt{caterpillar}' only:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily outset("tweedledee",\ "alice caterpillar");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Name the output dataset `\texttt{tweedledum}' and
specify that it will contain the values of all the variables
that are either in the input dataset or are declared in
the current `\texttt{infile}' or `\texttt{inset}' statement:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily outset("tweedledum",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Name the output dataset `\texttt{tweedledum}' and
specify that it will be stored in memory, not on disk, and
that it will contain the values of all the variables
that are either in the input dataset or are declared in
the current `\texttt{infile}' or `\texttt{inset}' statement:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily outset("<tweedledum",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{output()}
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{output@output}%

\noindent{}\textbf{Description}

Writes one line of data to the output dataset specified by `\texttt{outset}'.

\section{{Positioning within a dataset}}
\label{anchor:Positioning-within-a-dataset}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dap\_mark()}
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{mark@mark}%
\index[in]{position@position}%
\index[in]{dap\_mark@dap\_mark}%

\noindent{}\textbf{Description}

Marks a position in a dataset: a call to `\texttt{dap\_rewind}' rewinds the dataset
to that position.

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dap\_rewind()}
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{dap\_rewind@dap\_rewind}%
\index[in]{rewind@rewind}%
\index[in]{dataset@dataset}%

\noindent{}\textbf{Description}

Rewinds the input dataset to the location saved by the most recent call to
`\texttt{dap\_mark}'.
\index[in]{dap\_mark@dap\_mark}%

\section{{Partitioning a dataset}}
\label{anchor:Partitioning-a-dataset}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dap\_list(\Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{partv}, \Texinfocommandstyletextvar{npartv})}
\Texinfocommandstyletextvar{variable-list:} string
\Texinfocommandstyletextvar{partv:} array of int
\Texinfocommandstyletextvar{npartv:} int
\Texinfocommandstyletextvar{Returns:} int
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{dap\_list@dap\_list}%

\noindent{}\textbf{Description}

Fills the array \Texinfocommandstyletextvar{partv}
\index[in]{partv@partv}%
with the indices of the at most
\Texinfocommandstyletextvar{npartv} variables whose names are in the space-separated list
\Texinfocommandstyletextvar{variable-list}.
Returns the number of variables actually listed.

\noindent{}\textbf{Code fragment(s)}

\emph{With the input dataset sorted by the values of the variables
`\texttt{first}' and `\texttt{last}', prepare `\texttt{namev}' for use in
`\texttt{dap\_head}' or `\texttt{dap\_newpart}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily int namev[2];
dap\_list("first last",\ namev,\ 2);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{In the function `\texttt{foo}', prepare `\texttt{varv}' for use in
`\texttt{dap\_head}' or `\texttt{dap\_newpart}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily foo(char *varlist)
\  \{
\    int varv[3];
\    int numvars;

\    numvars = dap\_list(varlist,\ varv,\ 3);
\    ...
\  \}
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dap\_swap()}
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{swap@swap}%
\index[in]{dap\_swap@dap\_swap}%

\noindent{}\textbf{Description}

Swaps the two most recently read input file or dataset lines so that
the program can complete processing of a part of that file or dataset after it detects
the beginning of a new part.

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dap\_newpart(\Texinfocommandstyletextvar{partv}, \Texinfocommandstyletextvar{npartv});}
\Texinfocommandstyletextvar{partv:} array of int
\Texinfocommandstyletextvar{npartv:} int
\Texinfocommandstyletextvar{Returns:} int
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{dap\_newpart@dap\_newpart}%
\index[in]{new part@new part}%
\index[in]{dataset, partitioning@dataset, partitioning}%
\index[in]{partitioning@partitioning}%

\noindent{}\textbf{Description}

Returns 1 if the beginning of a new part, or the end of the file or the
dataset, has been reached, 0 otherwise.

A collection of variables can be used to define parts of a dataset for which
all the variables in that collection are constant.  For example, if a dataset
`\texttt{names}' has a variable `\texttt{first}' that gives a person's first name and a
variable `\texttt{last}' that gives a person's last
name, then sorting the dataset by `\texttt{last}' and `\texttt{first}' will define parts, each of
which contains all the records for one person (assuming no two people in the
dataset have the same first and last name).  
The following example program fragment counts how many records belong to each
person; it is assumed that the dataset has previously been
sorted by `\texttt{last}' and `\texttt{first}'.  
(This example is for illustrative purposes only: the same task can be done
in one line with the `\texttt{means}' function.)

\noindent{}\textbf{Code fragment(s)}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily inset("names")
\  \{
\    int nrecords;\   /* count of records */
\    int partv[2];\   /* array of numerical ids for variables */
\    int more;\       /* flag:\ is there more input?\ */

\    dap\_list("last first",\ partv,\ 2);\  /* sets up numerical ids */
\    for (nrecords = 0,\ more = 1;\ more;\ nrecords++)
\      \{
\        more = step();\             /* read 1 line or end of dataset */
\        if (dap\_newpart(partv,\ 2)) /* test if beginning of part
\                                    * defined by last and first
\                                    */
\          \{
\            dap\_swap();\      /* back to last line in previous part */
\            dap\_head(partv,\ 2);\  /* display header for that part */
\            fprintf(dap\_lst,\ "\%d records\textbackslash{}n",\ nrecords);
\                                 /* display the number of records */
\            dap\_swap();\          /* back to beginning of new part
\                                  * or end of dataset
\                                  */
\            nrecords = 0;\        /* re-initialize n for new part */
\          \}
\      \}
\  \}
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Modifying output}}
\label{anchor:Modifying-output}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dap\_save()}
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{dap\_save@dap\_save}%

\noindent{}\textbf{Description}

Saves the most recently read input file or dataset line so that
the values of the variables can be modified for an additional output.

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dap\_rest()}
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{dap\_rest@dap\_rest}%

\noindent{}\textbf{Description}

Restores the most recently read input file or dataset line that was
saved by `\texttt{dap\_save}'.

\section{{Manage datasets}}
\label{anchor:Manage-datasets}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dataset(\Texinfocommandstyletextvar{oldname}, \Texinfocommandstyletextvar{newname}, \Texinfocommandstyletextvar{action})}
\Texinfocommandstyletextvar{oldname}, \Texinfocommandstyletextvar{newname}, \Texinfocommandstyletextvar{action:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc datasets;
append \{base | out\}=\Texinfocommandstyletextvar{newname} [\{data | new\}=\Texinfocommandstyletextvar{oldname}];
change \Texinfocommandstyletextvar{oldname-1}=\Texinfocommandstyletextvar{newname-1} [... \Texinfocommandstyletextvar{oldname-n}=\Texinfocommandstyletextvar{newname-n}];
delete \Texinfocommandstyletextvar{filename-1} ... \Texinfocommandstyletextvar{filename-n};
\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{dataset@dataset}%
\index[in]{copy@copy}%
\index[in]{rename@rename}%
\index[in]{append@append}%
\index[in]{remove@remove}%
\index[in]{fill@fill}%
\index[in]{missing cells@missing cells}%
\index[in]{datasets (SAS proc)@datasets (SAS proc)}%

\noindent{}\textbf{Description}

Performs the specified action on the datasets \Texinfocommandstyletextvar{oldname} and, if the action is not
`\texttt{REMOVE}', \Texinfocommandstyletextvar{newname}.
The string \Texinfocommandstyletextvar{action} must contain one of the words
`\texttt{APPEND}', `\texttt{RENAME}', `\texttt{COPY}', `\texttt{FILL}', or `\texttt{REMOVE}'.

`\texttt{APPEND}' appends
the dataset \Texinfocommandstyletextvar{oldname} at the end of \Texinfocommandstyletextvar{newname}. For `\texttt{APPEND}',
only those variables existing
in \Texinfocommandstyletextvar{newname} are retained from \Texinfocommandstyletextvar{oldname} and if a variable
in \Texinfocommandstyletextvar{newname} does not appear in
\Texinfocommandstyletextvar{oldname}, the value of that variable is set to the null string if of type string or
0 if of type int or double.

`\texttt{RENAME}' changes the name of the dataset from \Texinfocommandstyletextvar{oldname} to \Texinfocommandstyletextvar{newname}.

`\texttt{COPY}' may be followed by a space-separated list
of variable specifications, each of
which has the form \Texinfocommandstyletextvar{variable-name} or \Texinfocommandstyletextvar{variable-name}
> \Texinfocommandstyletextvar{new-variable-name}. In either case, only the variables listed will be retained in
the copy of the dataset and in the second case, those variables will be renamed as
indicated. If \Texinfocommandstyletextvar{variable-name} refers to an array, then no index may be specified and
the entire array is retained and, if indicated, renamed.

`\texttt{FILL}' makes a copy, named \Texinfocommandstyletextvar{newname}, of the dataset \Texinfocommandstyletextvar{oldname}
with the values in missing cells filled by 0.0 for variables of type double,
0 for variables of type int, and the null-string `\texttt{""}'
for variables of type string.
`\texttt{FILL}' must be followed by two space-separated lists which are separated by a
`\texttt{:}'. The first list names the variables whose values are to be filled and
the second list names the variables that classify the cells in the dataset.
The dataset must be sorted by the classification variables in that order.

`\texttt{REMOVE}' deletes the dataset \Texinfocommandstyletextvar{oldname}.

\noindent{}\textbf{Code fragment(s)}

\emph{Append the contents of the dataset \texttt{tweedledee} to
the dataset \texttt{tweedledum}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily dataset("tweedledee",\ "tweedledum",\ "APPEND");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Change the name of the dataset \texttt{tweedledee} to
\texttt{tweedledum}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily dataset("tweedledee",\ "tweedledum",\ "RENAME");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Make a copy of the dataset \texttt{tweedledee} and name the new
dataset \texttt{tweedledum}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily dataset("tweedledee",\ "tweedledum",\ "COPY");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Make a copy of the dataset \texttt{tweedledee} but retain
the values of `\texttt{alice}' and `\texttt{mushroom}' only, and name the
new dataset \texttt{tweedledum}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily dataset("tweedledee",\ "tweedledum",\ "COPY alice mushroom");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Make a copy of the dataset \texttt{tweedledee}, retain
the values of `\texttt{alice}' and `\texttt{mushroom}' only, name the
new dataset \texttt{tweedledum}, and change the name of `\texttt{alice}'
to `\texttt{tall}' in the new dataset:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily dataset("tweedledee",\ "tweedledum",\ "COPY alice>tall mushroom");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Make a copy, named \texttt{tweedledum}, of the dataset \texttt{tweedledee},
which is sorted by `\texttt{SES}', `\texttt{race}', and `\texttt{gender}', with the missing
cells filled with 0.0 for the variable `\texttt{count}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily dataset("tweedledee",\ "tweedledum",\ "FILL count :\ SES race gender");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Remove the dataset \texttt{tweedledee}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily dataset("tweedledee",\ "",\ "REMOVE");
\end{Texinfopreformatted}
\end{Texinfoindented}

\chapter{{Managing and displaying data}}
\label{anchor:Managing-and-displaying-data}%

These functions manipulate or display the data within a dataset (not a data file).


\section{{Sorting a dataset}}
\label{anchor:Sorting-a-dataset}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{sort(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{modifiers})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{modifiers:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc sort [data=\Texinfocommandstyletextvar{dataset-name}] [out=\Texinfocommandstyletextvar{dataset-name}] [nodupkey];
by [descending] \Texinfocommandstyletextvar{variable-1} [... [descending] \Texinfocommandstyletextvar{variable-n}]
\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{sort@sort}%
\index[in]{sort (SAS proc)@sort (SAS proc)}%

\noindent{}\textbf{Description}

Writes to \Texinfocommandstyletextvar{dataset}.srt the result of sorting
\Texinfocommandstyletextvar{dataset} in the order specified by the space-separated,
ordered list of variables \Texinfocommandstyletextvar{variable-list},
according to \Texinfocommandstyletextvar{modifiers}.
The original dataset is left unchanged.
If \Texinfocommandstyletextvar{modifiers}
is the null string, then all variables are sorted in increasing order
\index[in]{order, sort@order, sort}%
and all sorted lines are kept.
Otherwise, \Texinfocommandstyletextvar{modifiers} is a space separated list of
`\texttt{u}' and/or an ordered string of `\texttt{i}' and `\texttt{d}'
(no spaces) whose length equals the number of variables in
\Texinfocommandstyletextvar{variable-list:} `\texttt{u}' means retain only one record in a group of lines for which
all the values of all the variables in \Texinfocommandstyletextvar{variable-list} are identical;
`\texttt{i}' indicates that the corresponding variable will be sorted in increasing
order and `\texttt{d}' indicates decreasing order.
\index[in]{sort@sort}%
NOTE: sort allocates enough memory for sorting small to moderately large disk files
efficiently; for very large files, consider setting DAP\_MAXMEM (see \hyperref[anchor:Appendix-I]{\chaptername~\ref*{anchor:Appendix-I} [Appendix I], page~\pageref*{anchor:Appendix-I}}).

\noindent{}\textbf{Code fragment(s)}

\emph{Create a copy of the dataset \texttt{people} sorted by `\texttt{height}'
in ascending order and by `\texttt{weight}' in ascending order within
groups with equal `\texttt{height}' and name
the new dataset \texttt{people.srt}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily sort("people",\ "height weight",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Create a copy of the dataset \texttt{people} sorted by `\texttt{height}'
in descending order and by `\texttt{weight}' in ascending order within
each group of lines with constant `\texttt{height}' and name
the new dataset \texttt{people.srt}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily sort("people",\ "height weight",\ "di");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Create a copy of the dataset \texttt{people} sorted by `\texttt{last}'
in ascending order and by `\texttt{weight}' in ascending order within
each group of lines with constant `\texttt{height}', but retain only one line from
each group of lines with the constant `\texttt{last}' and `\texttt{first}',
and name the new dataset \texttt{people.srt}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily sort("people",\ "last first",\ "u");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Create a copy of the dataset \texttt{people} sorted by `\texttt{last}'
in descending order and by `\texttt{weight}' in descending order within
each group of lines with constant `\texttt{height}', but retain only one line from
each group of lines with the constant `\texttt{last}' and `\texttt{first}',
and name the new dataset \texttt{people.srt}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily sort("people",\ "last first",\ "u dd");
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Merging datasets}}
\label{anchor:Merging-datasets}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{merge(\Texinfocommandstyletextvar{dataset1}, \Texinfocommandstyletextvar{variable-list1}, \Texinfocommandstyletextvar{dataset2}, \Texinfocommandstyletextvar{variable-list2}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{outputset})}
\Texinfocommandstyletextvar{dataset1}, \Texinfocommandstyletextvar{variable-list1}, \Texinfocommandstyletextvar{dataset2}, \Texinfocommandstyletextvar{variable-list2}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{outputset:} string
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{merge@merge}%
\index[in]{match@match}%

\noindent{}\textbf{Description}

Performs a many-to-one or one-to-one merge of
\Texinfocommandstyletextvar{dataset1} and \Texinfocommandstyletextvar{dataset2} and writes the result to \Texinfocommandstyletextvar{outputset}.
(For usage in an SAS `\texttt{data}' step, see See \hyperref[anchor:Appendix-IV]{\chaptername~\ref*{anchor:Appendix-IV} [Appendix IV], page~\pageref*{anchor:Appendix-IV}}.)
A variable is renamed in the output dataset if the variable name is followed by
`\texttt{> \Texinfocommandstyletextvar{newname}}'.
Only the variables in \Texinfocommandstyletextvar{variable-list1}, renamed if requested,
are included from \Texinfocommandstyletextvar{dataset1}
and only the variables in \Texinfocommandstyletextvar{variable-list2}, renamed if requested,
are included from \Texinfocommandstyletextvar{dataset2};
these two variable lists must be disjoint.
Individual array elements may not be referenced in the variable lists; array
names must appear without bracketed indices.
If either variable list is a `\texttt{NULL}'
pointer, then no variables are included from
that dataset; this can be used to select observations
from a dataset.
If either variable list is the null string ("", not `\texttt{NULL}'),
then all variables from that dataset are included.
If either variable list contains the character `\texttt{!}' before the first
variable name, then the named variables are excluded from, not included in,
the output dataset.
If \Texinfocommandstyletextvar{partvars} is not the null string or `\texttt{NULL}', then
matching is based on the variables in \Texinfocommandstyletextvar{partvars:}
for each part of the datasets \Texinfocommandstyletextvar{dataset1} and \Texinfocommandstyletextvar{dataset2}
specified by the variables in \Texinfocommandstyletextvar{partvars},
the first observation in \Texinfocommandstyletextvar{dataset2}
is matched with all observations from \Texinfocommandstyletextvar{dataset1};
both datasets must be sorted by \Texinfocommandstyletextvar{partvars} before merging.
Otherwise, observations in the two datasets are matched one-to-one
until one or both datasets are exhausted.

\noindent{}\textbf{Code fragment(s)}

\emph{Merge datasets \texttt{pretreat} and \texttt{posttreat} into a new
dataset `\texttt{changes}' by matching
lines with corresponding values of `\texttt{name}'; retain the values
of `\texttt{name}' and `\texttt{preweight}' from \texttt{pretreat} and
the values of `\texttt{postweight}' from \texttt{posttreat}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily merge("pretreat",\ "name preweight",
\      "posttreat",\ "postweight",\ "name",\ "changes");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Merge datasets \texttt{pretreat} and \texttt{posttreat} into a new
dataset `\texttt{changes}' by matching
lines with corresponding values of `\texttt{name}'; retain the values
of `\texttt{name}' and `\texttt{weight}' from \texttt{pretreat} and
the values of `\texttt{weight}' from \texttt{posttreat}, but change the name of
`\texttt{weight}' from \texttt{pretreat} to `\texttt{preweight}' and
the name of `\texttt{weight}' from \texttt{posttreat} to `\texttt{postweight}'
in the dataset \texttt{changes}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily merge("pretreat",\ "name weight>preweight",
\      "posttreat",\ "weight>postweight",\ "name",\ "changes");
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Displaying a dataset}}
\label{anchor:Displaying-a-dataset}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{print(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc print [data=\Texinfocommandstyletextvar{dataset-name}];
var \Texinfocommandstyletextvar{variable-list};
\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{print@print}%
\index[in]{print (SAS proc)@print (SAS proc)}%

\noindent{}\textbf{Description}

Displays the values of variables in \Texinfocommandstyletextvar{dataset}.
If \Texinfocommandstyletextvar{variable-list} is NULL or the null string or a string containing
only tabs or only commas, the values
of all variables are printed, otherwise just those of the named variables
are printed.
If the variables in \Texinfocommandstyletextvar{variable-list} are separated by spaces, then output
contains value of the `\texttt{\_type\_}' variable and the observation number.
Otherwise, the variables must be separated by tabs or commas and
the value of the `\texttt{\_type\_}' variable and the observation number are omitted.
No special handling is performed for strings containing tabs or commas.
\noindent{}\textbf{Code fragment(s)}

\emph{Display the values of all the variables of the dataset \texttt{names}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily print("names",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Display the values, separated by tabs, of all the variables of the dataset \texttt{names}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily print("names",\ "\textbackslash{}t");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Display the values of `\texttt{first}' and `\texttt{last}'
of the dataset \texttt{names}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily print("names",\ "first last");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Display the values, separated by commas, of `\texttt{first}', `\texttt{middle}', and `\texttt{last}'
of the dataset \texttt{names}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily print("names",\ "first,\ middle,last");
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{table(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{row-vars}, \Texinfocommandstyletextvar{col-vars}, \Texinfocommandstyletextvar{format}, \Texinfocommandstyletextvar{partvars})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{row-vars}, \Texinfocommandstyletextvar{col-vars}, \Texinfocommandstyletextvar{format}, \Texinfocommandstyletextvar{partvars:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc tabulate [data=\Texinfocommandstyletextvar{dataset-name}] [format=\Texinfocommandstyletextvar{width.places}];
[class \Texinfocommandstyletextvar{class-variable-list};]
[var \Texinfocommandstyletextvar{analysis-variable};]
table \Texinfocommandstyletextvar{row-variable-1} [... \Texinfocommandstyletextvar{row-variable-n}],
      \Texinfocommandstyletextvar{column-variable-1} [... \Texinfocommandstyletextvar{column-variable-n}] * \Texinfocommandstyletextvar{analysis-variable}
      [/ \{rtspace | rts\}=\Texinfocommandstyletextvar{number}];
by \Texinfocommandstyletextvar{variable-list};
\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{print@print}%
\index[in]{table@table}%
\index[in]{tabulate (SAS proc)@tabulate (SAS proc)}%

\noindent{}\textbf{Description}

Displays values from \Texinfocommandstyletextvar{dataset} in tabular form.
The values of the variables in \Texinfocommandstyletextvar{row-vars} label the rows hierarchically and
the values of the variables in \Texinfocommandstyletextvar{col-vars} label the columns hierarchically
except that the last variable in \Texinfocommandstyletextvar{col-vars} is the variable of type double
whose values are displayed in the cells of the table.
The string \Texinfocommandstyletextvar{format} is of either of the two forms,
\Texinfocommandstyletextvar{width}.\Texinfocommandstyletextvar{precision} or \Texinfocommandstyletextvar{width}.
The first specifies that \Texinfocommandstyletextvar{width} characters
should be allotted for each cell and \Texinfocommandstyletextvar{precision} digits should be displayed to the right
of the decimal point.
The second only specifies the number of characters to be allotted for each cell
and lets the program choose the "best" allocation of decimals.
The `\texttt{table}' function does not sort the data except that it sorts the columns if an
`\texttt{s}' appears before the \Texinfocommandstyletextvar{width}.\Texinfocommandstyletextvar{precision} specification; thus, the data must be sorted by
the \Texinfocommandstyletextvar{partvars} (if any), \Texinfocommandstyletextvar{row-vars}, and \Texinfocommandstyletextvar{col-vars} before calling `\texttt{table}'.
The \Texinfocommandstyletextvar{width}.\Texinfocommandstyletextvar{precision} can also be followed by
a number indicating how many columns to allocate for the combined
row labels, including column dividers.
`\texttt{Table}' does not process the data and expects at most one value of the
numerical variable for each distinct combination
of the row and column variables; see function `\texttt{split}'
(see \hyperref[anchor:Splitting-and-joining-lines]{Section~\ref*{anchor:Splitting-and-joining-lines} [Splitting and joining lines], page~\pageref*{anchor:Splitting-and-joining-lines}}) for datasets with multiple numerical
values to display.

SAS note: In `\texttt{proc tabulate}', the `\texttt{class}' and `\texttt{var}' statements have no effect and may be omitted.

\noindent{}\textbf{Code fragment(s)}

\emph{Display a table, with cells 6 characters long and values displayed
to 1 decimal place,
of the values of `\texttt{height}' with the rows
labeled by `\texttt{last}' and `\texttt{first}' and the columns labeled by
`\texttt{county}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily table("names",\ "last first",\ "county height",\ "6.1",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Display tables, one for each `\texttt{state}',
with cells 6 characters long and values displayed
to 1 decimal place,
of the values of `\texttt{height}' with the rows
labeled by `\texttt{last}' and `\texttt{first}' and the columns labeled by
`\texttt{county}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily table("names",\ "last first",\ "county height",\ "6.1",\ "state");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Display a table, with cells 6 characters long and values displayed
to 1 decimal place,
of the values of `\texttt{height}' with the rows
labeled by `\texttt{last}' and `\texttt{first}' and the columns labeled by
`\texttt{county}', with `\texttt{county}' sorted in ascending order:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily table("names",\ "last first",\ "county height",\ "s6.1",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Splitting and joining lines}}
\label{anchor:Splitting-and-joining-lines}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{split(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{class-value-vars})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{class-value-vars:} string
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{split@split}%

\noindent{}\textbf{Description}

For each line of \Texinfocommandstyletextvar{dataset}, writes to \Texinfocommandstyletextvar{dataset}.spl one line
for each variable in \Texinfocommandstyletextvar{variable-list}, with the value of the first
variable in \Texinfocommandstyletextvar{class-value-vars}
set to the name of that variable and the value of the second set to the
value.
All the variables in \Texinfocommandstyletextvar{variable-list} must have the same type, which will be
the type of the second variable in \Texinfocommandstyletextvar{class-value-vars}.
All variables in \Texinfocommandstyletextvar{dataset} except those \Texinfocommandstyletextvar{variable-list} appear
in \Texinfocommandstyletextvar{dataset}.spl, in addition to the two new variables named in
\Texinfocommandstyletextvar{class-value-vars}.
This function is useful for preparing a dataset for function `\texttt{table}'.

\noindent{}\textbf{Code fragment(s)}

\emph{Create a new dataset \texttt{people.spl} that is a copy of
\texttt{people} except that each person's height and weight are on consecutive lines
so that `\texttt{table}' can be called to display both values on the same line:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily split("people",\ "height weight",\ "statname statistic");
table("people.spl",\ "name",\ "statname statistic",\ "6.0",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{join(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{value-var})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{value-var:} string
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{join@join}%

\noindent{}\textbf{Description}

For consecutive lines in \Texinfocommandstyletextvar{dataset} distinguished by values of
the last variable named in \Texinfocommandstyletextvar{partvars}, which must be a string
variable, writes one line to \Texinfocommandstyletextvar{dataset}.joi.
In each part of \Texinfocommandstyletextvar{dataset} specified by all but the last variable
named in \Texinfocommandstyletextvar{partvars},
for each distinct value of the last variable named in \Texinfocommandstyletextvar{partvars},
the new dataset \Texinfocommandstyletextvar{dataset}.joi contains one new variable
whose name is that value and whose value is set to the value of
\Texinfocommandstyletextvar{value-var} in the corresponding line of \Texinfocommandstyletextvar{dataset}.
\Texinfocommandstyletextvar{dataset} must be sorted by \Texinfocommandstyletextvar{partvars} and
the same set of values of the last variable named in \Texinfocommandstyletextvar{partvars}
must occur in every part defined by all the variables but the last
in \Texinfocommandstyletextvar{partvars}.
Neither the last variable name in \Texinfocommandstyletextvar{partvars} nor
the variable \Texinfocommandstyletextvar{value-var} appears in \Texinfocommandstyletextvar{dataset}.joi.
This function is useful, for example, for preparing a dataset for
function `\texttt{plot}'.

\noindent{}\textbf{Code fragment(s)}

\emph{Create a new dataset \texttt{people.joi} that is a copy of
\texttt{people} except that each person's height and weight, which were
given as values of the variable `\texttt{statistic}' of type double,
on separate lines identified by the values `\texttt{height}' and `\texttt{weight}'
of the string variable `\texttt{statname}', now appear as variables named
`\texttt{height}' and `\texttt{weight}' on a single line:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily join("people",\ "city name statname",\ "statistic");
nport(plot("people.joi",\ "height weight",\ "city",
\            "",\ NULL,\ NULL,\ 3),\ 3,\ 1);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Grouping lines in a dataset}}
\label{anchor:Grouping-lines-in-a-dataset}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{group(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-specification}, \Texinfocommandstyletextvar{partvars})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-specification}, \Texinfocommandstyletextvar{partvars:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc rank [data=\Texinfocommandstyletextvar{dataset-name}] [out=\Texinfocommandstyletextvar{dataset-name}]
          [\{fraction | f | percent | p | groups=\Texinfocommandstyletextvar{number}\}];
by \Texinfocommandstyletextvar{variable-list};
[ranks \Texinfocommandstyletextvar{new-variable-list};]
var \Texinfocommandstyletextvar{variable-list};

\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{group@group}%
\index[in]{rank@rank}%
\index[in]{rank (SAS proc)@rank (SAS proc)}%

\noindent{}\textbf{Description}

Writes to \Texinfocommandstyletextvar{dataset}.grp the observations of \Texinfocommandstyletextvar{dataset},
grouped according to the \Texinfocommandstyletextvar{variable-specification}.
Groups are numbered consecutively and are formed as specified by
\Texinfocommandstyletextvar{variable-specification}. \Texinfocommandstyletextvar{dataset} only needs to be
sorted by \Texinfocommandstyletextvar{partvars}, if there are any.

If \Texinfocommandstyletextvar{variable-specification} begins with either `\texttt{\#}', `\texttt{/}',
or `\texttt{\%}' then for each observation,
\Texinfocommandstyletextvar{group} computes either the number of the observation or
the fraction of the total number of observations or
the percent of the total number of observations, respectively.
`\texttt{\#}', `\texttt{/}', or `\texttt{\%}' may be followed by a space and one of
`\texttt{+}', `\texttt{-}', `\texttt{+1}', `\texttt{+0}', `\texttt{-1}', or `\texttt{-0}'
to indicate ascending order, starting from 0,
descending order, ending at 0,
ascending order, starting from 1,
ascending order, starting from 0,
descending order, ending at 1, or
descending order, ending at 0, respectively;
the default is ascending order, starting from 1.
This may in turn may be followed by a space-separated list of variables:
only those observations of the dataset for which all of these variables have
a finite (i.e., non-NaN) value are given group numbers and the remaining observations
are given a group number of NaN.

If \Texinfocommandstyletextvar{variable-specification} does not begin with
`\texttt{\#}', `\texttt{/}', or `\texttt{\%}', then it must be a space-separated list of
\Texinfocommandstyletextvar{variable-name} \Texinfocommandstyletextvar{ngroups-method}, in which
\Texinfocommandstyletextvar{ngroups-method} is either an integer followed by `\texttt{\^{}}' (no space in between)
for that number of groups
of equal width from the smallest observation to the largest or
an integer followed by
`\texttt{\#}' (no space in between), for that number of groups
of (approximately) equal counts from the smallest observation to the largest.
Only those observations for which all the grouping variables have finite
(i.e., non-NaN) values are given group numbers and the
remaining observations are given a group number of NaN.
The numbering of the groups starts at 1.

In addition to all variables in \Texinfocommandstyletextvar{dataset}, the output dataset contains
for each grouping variable, which must be of type double,
a new variable whose
name is formed by preceding the original variable name with an
underscore (`\texttt{\_}');
this new variable, which is also of type double,
contains the group number of the value of the original variable.
If only `\texttt{\#}', `\texttt{/}', or
`\texttt{\%}',
was requested, then the new variable is named `\texttt{\_N\_}'.

SAS note: In `\texttt{proc rank}', the `\texttt{ranks}' statement is ignored: the output data
set always contains new variables for the ranks, as in
the dap function `\texttt{group}'.

\noindent{}\textbf{Code fragment(s)}

\emph{Create a new dataset \texttt{people.grp} that is a copy of
\texttt{people} except that it has an additional variable named
`\texttt{\_N\_}' that contains the line number, starting at 1:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily group("people",\ "\#",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Create a new dataset \texttt{people.grp} that is a copy of
\texttt{people} except that it has an additional variable named
`\texttt{\_N\_}' that contains the line number, starting at 0:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily group("people",\ "\# +0",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Create a new dataset \texttt{people.grp} that is a copy of
\texttt{people} except that it has an additional variable named
`\texttt{\_height}' that contains a number from 1 to 5 that indicates
the quintile of the value of `\texttt{height}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily group("people",\ "height 5\#",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Create a new dataset \texttt{people.grp} that is a copy of
\texttt{people} except that it has an additional variable named
`\texttt{\_height}' that contains a number from 1 to 5 that indicates
which of 5 equal length intervals, starting at the smallest value
of `\texttt{height}' and ending at the largest,
contains the value of `\texttt{height}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily group("people",\ "height 5\^{}",\ "county");
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Trimming extreme values}}
\label{anchor:Trimming-extreme-values}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{trim(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{trim-specification}, \Texinfocommandstyletextvar{partvars})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{trim-specification}, \Texinfocommandstyletextvar{partvars:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

Writes to \Texinfocommandstyletextvar{dataset}.trm the observations from \Texinfocommandstyletextvar{dataset}
for which the values of all of the variables in
\Texinfocommandstyletextvar{trim-specifications} do not lie in the upper or lower percent indicated in
\Texinfocommandstyletextvar{trim-specifications}.
The string \Texinfocommandstyletextvar{trim-specifications}
consists of space-separated pairs of
\Texinfocommandstyletextvar{variable-name} \Texinfocommandstyletextvar{percent}.
The variables listed in \Texinfocommandstyletextvar{trim-specifications} must be of type double.

\noindent{}\textbf{Code fragment(s)}

\emph{Create a new dataset named \texttt{wheat.trm} that contains only
those values of `\texttt{yield}' that do not lie
in the upper or lower 5\% of all the values of `\texttt{yield}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily trim("wheat",\ "yield 5",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Create a new dataset named \texttt{wheat.trm} that contains only
those lines of \texttt{wheat} whose value of `\texttt{yield}' does not lie
in the upper or lower 5\% of all the values of `\texttt{yield}' and,
simultaneously, whose value of `\texttt{nitrogen}' does not lie
in the upper or lower 10\% of all the values of `\texttt{nitrogen}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily trim("wheat",\ "yield 5 nitrogen 10",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{trim@trim}%
\index[in]{means@means}%
\index[in]{extreme values@extreme values}%
\index[in]{outliers@outliers}%

\chapter{{Statistics functions}}
\label{anchor:Statistics-functions}%


\section{{Survey selection}}
\label{anchor:Survey-selection}%
\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{surveyselect(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-specification}, \Texinfocommandstyletextvar{stat-list}, \Texinfocommandstyletextvar{partvars})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-specification}, \Texinfocommandstyletextvar{stat-list}, \Texinfocommandstyletextvar{partvars:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc surveyselect [data=\Texinfocommandstyletextvar{dataset-name}] [out=\Texinfocommandstyletextvar{out-name}]  [method=\Texinfocommandstyletextvar{method-name}]  [n=\Texinfocommandstyletextvar{n-name}];
\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{surveyselect (SAS proc)@surveyselect (SAS proc)}%

\noindent{}\textbf{Description}

survey selection on a dataset.
method SRS and SYS are implemented.
Method SRS take [n] values in the dataset by randomization. 
Method SYS take [n] values in the dataset with a systematic algorithm starting with a simple random.

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily proc surveyselect data =tPres2007 method=SRS  n = 220 out=sasPres2007 ;
run ;
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{One variable statistics}}
\label{anchor:One-variable-statistics}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{means(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-specification}, \Texinfocommandstyletextvar{stat-list}, \Texinfocommandstyletextvar{partvars})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-specification}, \Texinfocommandstyletextvar{stat-list}, \Texinfocommandstyletextvar{partvars:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc means [data=\Texinfocommandstyletextvar{dataset-name}] [noprint] [\Texinfocommandstyletextvar{statistics-list}]
           [vardf=\{df | wdf\}];
var \Texinfocommandstyletextvar{variable-list};
weight \Texinfocommandstyletextvar{variable};
by \Texinfocommandstyletextvar{variable-list};
output [out=\Texinfocommandstyletextvar{dataset-name}];
\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{means (SAS proc)@means (SAS proc)}%

\noindent{}\textbf{Description}

Writes to \Texinfocommandstyletextvar{dataset}.mns the statistics requested in
\Texinfocommandstyletextvar{stat-list} for the variables in \Texinfocommandstyletextvar{variable-specification}, which must be
of type double.
The `\texttt{means}' function does not display its results in the \texttt{lst} file; use
`\texttt{print}' or `\texttt{table}' (\hyperref[anchor:Displaying-a-dataset]{Section~\ref*{anchor:Displaying-a-dataset} [Displaying a dataset], page~\pageref*{anchor:Displaying-a-dataset}}) after
calling `\texttt{means}' to display the results from \Texinfocommandstyletextvar{dataset}.mns.
The statistics are given as values of the variables named in \Texinfocommandstyletextvar{variable-specification}
in \Texinfocommandstyletextvar{dataset}.mns.
The string \Texinfocommandstyletextvar{stat-list}
is a space separated list of one or more of the following statistics:

\textbf{MAX}
\begin{quote}
the maximum of the variable values
\end{quote}
\index[in]{maximum@maximum}%

\textbf{MEAN}
\begin{quote}
the mean of the variable values
\end{quote}
\index[in]{mean@mean}%

\textbf{MIN}
\begin{quote}
the minimum of the variable values
\end{quote}
\index[in]{minimum@minimum}%

\textbf{N}
\begin{quote}
the number of finite observations
\end{quote}
\index[in]{number of observations@number of observations}%

\textbf{RANGE}
\begin{quote}
the maximum minus the minimum of the variable values
\end{quote}
\index[in]{range@range}%

\textbf{SD} or \textbf{STD}
\begin{quote}
the sample standard deviation of the variable values (df = number of observations - 1)
\end{quote}
\index[in]{standard deviation@standard deviation}%
\index[in]{sd@sd}%

\textbf{SDFREQ}
\begin{quote}
the weighted sample standard deviation of the weighted variable values (df = sum of weights - 1)
\end{quote}
\index[in]{standard deviation@standard deviation}%
\index[in]{sd@sd}%

\textbf{SEM} or \textbf{STDERR}
\begin{quote}
the sample standard error of the mean of the variable values (df = number of observations - 1)
\end{quote}
\index[in]{standard error of the mean@standard error of the mean}%
\index[in]{sem@sem}%

\textbf{SEMFREQ}
\begin{quote}
the weighted sample standard error of the mean of the variable values (df = sum of weights - 1)
\end{quote}
\index[in]{standard error of the mean@standard error of the mean}%
\index[in]{sem@sem}%

\textbf{STEPxxxx}
\begin{quote}
a sequence of \Texinfocommandstyletextvar{xxxx} + 1 equally spaced numbers from the minimum
to the maximum of the variable values, with xxxx an integer of at most 4 digits
\end{quote}
\index[in]{step@step}%

\textbf{SUM}
\begin{quote}
the sum of the variable values
\end{quote}
\index[in]{sum@sum}%

\textbf{SUMWT}
\begin{quote}
the sum of the weight variable values
\end{quote}
\index[in]{weight@weight}%

\textbf{T}
\begin{quote}
the value of the t-statistic for the variable values
\end{quote}
\index[in]{Student's t@Student's t}%
\index[in]{t@t}%

\textbf{TPROB} or \textbf{PRT}
\begin{quote}
the (two-tailed) probability that the absolute value of the t-statistic would equal or exceed the observed value
\end{quote}
\index[in]{t-test@t-test}%

\textbf{VAR}
\begin{quote}
the sample variance of the variable values (df = number of observations - 1)
\end{quote}
\index[in]{variance@variance}%

\textbf{VARFREQ}
\begin{quote}
the weighted sample variance of the variable values (df = sum of weights - 1)
\end{quote}
\index[in]{variance@variance}%

\textbf{VARM}
\begin{quote}
the sample variance of the mean of the variable values (df = number of observations - 1)
\end{quote}
\index[in]{variance@variance}%

\textbf{VARMFREQ}
\begin{quote}
the weighted sample variance of the variable values (df = sum of weights - 1)
\end{quote}
\index[in]{variance@variance}%

For each observation in the output data set, the `\texttt{\_type\_}'
variable names the statistic whose
value is given for the requested variable.
If the only statistic requested is `\texttt{N}',
\index[in]{number of observations@number of observations}%
then \Texinfocommandstyletextvar{variable-list}
may consist of a single variable
which need not be present in the input data set.
The string \Texinfocommandstyletextvar{variable-specification}
is a space-separated list of variables except that each weight
\index[in]{weight@weight}%
variable is preceded by an `\texttt{*}'.
For example,

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily w x * u y z * v
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}indicates that each value of \Texinfocommandstyletextvar{w} and \Texinfocommandstyletextvar{x}
is weighted by the value of \Texinfocommandstyletextvar{u} and that each value of
\Texinfocommandstyletextvar{y} and \Texinfocommandstyletextvar{z} is weighted by the value of
\Texinfocommandstyletextvar{v}.

For each variable separately,
means discards values for which either the value itself or
its weight value, if any, is a NaN.
\index[in]{NaN@NaN}%
The number of discarded values for each variable is reported
in the \texttt{log} file.

\noindent{}\textbf{Code fragment(s)}

\emph{For each distinct value of the variable `\texttt{plot}',
compute and display the number of observations in dataset \texttt{wheat}
and the mean and variance of the values of `\texttt{yield}' and
`\texttt{height}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily means("wheat",\ "yield height",\ "N MEAN VAR",\ "plot");
table("wheat.mns",\ "plot",\ "\_type\_ yield",\ "s6.1",\ "");
table("wheat.mns",\ "plot",\ "\_type\_ height",\ "s6.1",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{For each distinct value of the variable `\texttt{county}',
compute and display the number of observations in dataset \texttt{wheat}
and the mean and variance of the value of `\texttt{meanyield}',
weighted by `\texttt{acres}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily means("wheat",\ "meanyield * acres",\ "N MEAN VAR",\ "county");
table("wheat.mns",\ "county",\ "\_type\_ meanyield",\ "s6.1",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{For each distinct value of the pair of variables `\texttt{last}'
and `\texttt{first}', compute the number of observations in dataset \texttt{names}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily means("names",\ "nrecords",\ "N",\ "last first");
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pctiles(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-specification}, \Texinfocommandstyletextvar{stat-list}, \Texinfocommandstyletextvar{partvars})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-specification}, \Texinfocommandstyletextvar{stat-list}, \Texinfocommandstyletextvar{partvars:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc univariate [data=\Texinfocommandstyletextvar{dataset-name}] [noprint] [normal] [plot];
var \Texinfocommandstyletextvar{variable-list};
by \Texinfocommandstyletextvar{variable-list};
weight \Texinfocommandstyletextvar{variable};
output [out=\Texinfocommandstyletextvar{dataset-name}] [\Texinfocommandstyletextvar{statistics-list}];
\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{univariate (SAS proc)@univariate (SAS proc)}%

\noindent{}\textbf{Description}

Writes to \Texinfocommandstyletextvar{dataset}.pct the statistics requested in
\Texinfocommandstyletextvar{stat-list} for the variables \Texinfocommandstyletextvar{variable-specification}, which must be
of type double.
The `\texttt{pctiles}' function does not display its results in the \texttt{lst} file; use
`\texttt{print}' or `\texttt{table}' (\hyperref[anchor:Displaying-a-dataset]{Section~\ref*{anchor:Displaying-a-dataset} [Displaying a dataset], page~\pageref*{anchor:Displaying-a-dataset}}) after calling
`\texttt{pctiles}' to display the results from \Texinfocommandstyletextvar{dataset}.pct.
The statistics are given as values of the variables named in \Texinfocommandstyletextvar{variable-specification}
in \Texinfocommandstyletextvar{dataset}.pct.
The string \Texinfocommandstyletextvar{stat-list}
is a space separated list of one or more of the following statistics:

\textbf{MAX}
\begin{quote}
the maximum
\end{quote}
\index[in]{maximum@maximum}%

\textbf{MED} or \textbf{MEDIAN}
\begin{quote}
the median
\end{quote}
\index[in]{median@median}%

\textbf{MIN}
\begin{quote}
the minimum
\end{quote}
\index[in]{minimum@minimum}%

\textbf{N}
\begin{quote}
the number of observations
\end{quote}
\index[in]{number of observations@number of observations}%

\textbf{P1}
\begin{quote}
the 1\% point
\end{quote}

\textbf{P5}
\begin{quote}
the 5\% point
\end{quote}

\textbf{P10}
\begin{quote}
the 10\% point
\end{quote}

\textbf{P90}
\begin{quote}
the 90\% point
\end{quote}

\textbf{P95}
\begin{quote}
the 95\% point
\end{quote}

\textbf{P99}
\begin{quote}
the 99\% point
\end{quote}

\textbf{Q1}
\begin{quote}
the first quartile
\end{quote}
\index[in]{quartile@quartile}%

\textbf{Q3}
\begin{quote}
the third quartile
\end{quote}
\index[in]{quartile@quartile}%

\textbf{QRANGE}
\begin{quote}
the interquartile range
\end{quote}
\index[in]{interquartile range@interquartile range}%

\textbf{RANGE}
\begin{quote}
the range
\end{quote}
\index[in]{range@range}%

Up to 9 additional percentile points
\index[in]{percentile points@percentile points}%
can be specified in the form `\texttt{P\Texinfocommandstyletextvar{xxxxx}}'
in which `\texttt{xxxxx}'
is a number, which may contain up to 5 characters, including a decimal point.

The string \Texinfocommandstyletextvar{variable-specification}
is a space-separated list of variables except that each weight
\index[in]{weight@weight}%
variable is preceded by an `\texttt{*}'.
For example,

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily w x * u y z * v
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}indicates that each value of \Texinfocommandstyletextvar{w} and \Texinfocommandstyletextvar{x}
is weighted by the value of \Texinfocommandstyletextvar{u} and that each value of
\Texinfocommandstyletextvar{y} and \Texinfocommandstyletextvar{z} is weighted by the value of
\Texinfocommandstyletextvar{v}.

\noindent{}\textbf{Code fragment(s)}

\emph{Compute and display the 10th, 25th, 50th (median), 75th, and 90th percentiles
of `\texttt{income}' for each `\texttt{county}' in the dataset \texttt{people}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pctiles("people",\ "income",\ "P10 P25 MED P75 P90",\ "county");
table("people.pct",\ "county",\ "\_type\_ income",\ "s7.2",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Compute and display the 37.5th, 50th (median), and 62.5th percentiles
of `\texttt{income}' for each `\texttt{county}' in the dataset \texttt{people}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pctiles("people",\ "income",\ "P37.5 MED P62.5",\ "county");
table("people.pct",\ "county",\ "\_type\_ income",\ "s7.2",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{percentiles@percentiles}%
\index[in]{pctiles@pctiles}%

\section{{Correlations}}
\label{anchor:Correlations}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{corr(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{partvars})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{partvars:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc corr [data=\Texinfocommandstyletextvar{dataset-name}] [outp=\Texinfocommandstyletextvar{dataset-name}] [noprint];
var \Texinfocommandstyletextvar{variable-list};
by \Texinfocommandstyletextvar{variable-list};
\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{corr (SAS proc)@corr (SAS proc)}%

\noindent{}\textbf{Description}

Writes to \Texinfocommandstyletextvar{dataset}.cor the correlation statistics and their significances for
all pairs of the variables, each of which must be of type double,
in \Texinfocommandstyletextvar{variable-list}.
The `\texttt{corr}' function does not display its results in the \texttt{lst} file; use
`\texttt{print}' or `\texttt{table}' (\hyperref[anchor:Displaying-a-dataset]{Section~\ref*{anchor:Displaying-a-dataset} [Displaying a dataset], page~\pageref*{anchor:Displaying-a-dataset}}) after calling
`\texttt{corr}' to display the results from \Texinfocommandstyletextvar{dataset}.cor.
The output dataset contains the variables `\texttt{\_var1\_}', `\texttt{\_var2\_}', and `\texttt{\_corr\_}'
\index[in]{\_var1\_@\_var1\_}%
\index[in]{\_var2\_@\_var2\_}%
\index[in]{\_corr\_@\_corr\_}%
in addition to all the variables in \Texinfocommandstyletextvar{partvars}.
There is one pair of correlation and significance
values for each pair of numeric variables.
For each line of the output data set,
`\texttt{\_var1\_}', and `\texttt{\_var2\_}', contain the names of the variables being
reported on and `\texttt{\_corr\_}'
contains the number of observations, the correlation coefficient, or its significance, as
indicated by the values `\texttt{N}',
`\texttt{CORR}', and `\texttt{PCORR}' of the `\texttt{\_type\_}' variable, respectively.

\noindent{}\textbf{Code fragment(s)}

\emph{Compute and display the correlations and their signficances for
each pair of the variables `\texttt{height}', `\texttt{weight}',
and `\texttt{income}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily corr("people",\ "height weight income",\ "");
sort("people.cor",\ "\_type\_ \_var1\_ \_var2\_",\ "");
table("people.cor.srt",\ "\_var1\_",\ "\_var2\_ \_corr\_",\ "6.2",\ "\_type\_");
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{corr@corr}%
\index[in]{correlation@correlation}%

\section{{Analysis of variance}}
\label{anchor:Analysis-of-variance}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{effects(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{model}, \Texinfocommandstyletextvar{partvars})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{model}, \Texinfocommandstyletextvar{partvars:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc glm [data=\Texinfocommandstyletextvar{dataset-name}];
class \Texinfocommandstyletextvar{variable-list};
model \Texinfocommandstyletextvar{response-variable} = \Texinfocommandstyletextvar{effects-list};
by \Texinfocommandstyletextvar{variable-list};
contrast "\Texinfocommandstyletextvar{label}" \Texinfocommandstyletextvar{effect} \Texinfocommandstyletextvar{coefficient-list} [/ e=\Texinfocommandstyletextvar{effect}];
lsmeans \Texinfocommandstyletextvar{effect-list} / [e=\Texinfocommandstyletextvar{effect}] [alpha=\Texinfocommandstyletextvar{n}] \{DUNNETT | TUKEY | LSD\};
test h=\Texinfocommandstyletextvar{effect-list} e=\Texinfocommandstyletextvar{effect};

\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{glm (SAS proc)@glm (SAS proc)}%
\index[in]{effects@effects}%
\index[in]{analysis of variance@analysis of variance}%
\index[in]{ANOVA@ANOVA}%
\index[in]{model@model}%

\noindent{}\textbf{Description}

For \Texinfocommandstyletextvar{dataset}, created by \Texinfocommandstyletextvar{means} with `\texttt{N}', `\texttt{MEAN}', and `\texttt{VAR}',
but no other statistics requested, \Texinfocommandstyletextvar{effects} constructs a dataset named
\Texinfocommandstyletextvar{dataset}.con appropriate for `\texttt{ftest}' and then calls `\texttt{ftest}'
on the set of contrasts
\index[in]{contrasts@contrasts}%
specified by all the terms together in \Texinfocommandstyletextvar{model}.
`\texttt{Ftest}'
\index[in]{F-test@F-test}%
can be used on \Texinfocommandstyletextvar{dataset}.con
to perform F-tests on the contrasts that correspond to individual
terms in the model.
The first variable in \Texinfocommandstyletextvar{variable-list}
is the response variable, which must be of type double,
and the remainder are the treatment variables, all of which must be of type string.
The string \Texinfocommandstyletextvar{model}
\index[in]{model@model}%
is a space-separated list of terms in the model; all
possible terms not in the model are considered to be in
the error, in addition to the cell variances (if any).
Each term is either a treatment or a cross of two or more
treatments, which is indicated by an `\texttt{*}' separated list of treatments.
Nesting
\index[in]{nested design@nested design}%
can be specified by including an effect in a cross
term without that effect appearing as a main effect.
NOTE:
\index[in]{bug@bug}%
\index[in]{nested design@nested design}%
In the current version, 3.5, nested designs must be balanced and the
levels of the nested factors must be the same for each set of levels
of the factors within which they are nested; presumably,
this will be corrected in later versions.

The output dataset \Texinfocommandstyletextvar{dataset}.con contains a variable named `\texttt{\_term\_}',
\index[in]{\_term\_@\_term\_}%
of type int, which indicates which terms the error and contrast lines refer to:
each bit in `\texttt{\_term\_}', with the lowest order bit corresponding to the
first treatment variable,
indicates whether the correspondingly numbered treatment in the model
is included in the term.
The error, contrast, and least-squares means terms in
\Texinfocommandstyletextvar{dataset}.con are adjusted for missing cells, but only the error
terms are orthogonalized.

SAS note: All the variables used in the \Texinfocommandstyletextvar{effects-list} of the `\texttt{model}'
statement must be named in the `\texttt{class}' statement, as dap only
allows categorical, string-valued, variables for the terms in the model.
Specify crossed and nested effects using `\texttt{*}' only.
A `\texttt{test}' statement automatically computes an appropriate combination of mean
squares from the terms in `\texttt{e=}' error term list, if possible, to test the numerator and
applies the Satterthwaite approximation.
An `\texttt{lsmeans}' statement that has an `\texttt{e=}' option or that appears after
a `\texttt{contrast}', a `\texttt{test}', or another \Texinfocommandstyletextvar{lsmeans} statement
automatically runs an F-test with the same denominator.
In each `\texttt{contrast}' statement, the effect to be tested must be a main effect,
the coefficients must appear in the sorting order of the
levels of that effect, they must be integers, and they must sum to zero.
For more complicated contrasts, see See \hyperref[anchor:Analysis-of-variance-examples]{Section~\ref*{anchor:Analysis-of-variance-examples} [Analysis of variance examples], page~\pageref*{anchor:Analysis-of-variance-examples}}.

\noindent{}\textbf{Code fragment(s)}

\emph{Perform an analysis of variance on the completely randomized
one-way layout with
response variable `\texttt{yield}' and treatment `\texttt{fert}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily effects("wheat.srt.mns",\ "yield fert",\ "fert",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Perform an analysis of variance (F-test on the model only)
on the one-way layout in a completely randomized block design with
response variable `\texttt{yield}' and treatment `\texttt{fert}',
blocked by `\texttt{block}', with main effects only:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily effects("wheat.srt.mns",\ "yield fert block",
\                 "fert block",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Perform an analysis of variance (F-test on the model only)
on the two-way layout in a completely randomized block design with
response variable `\texttt{yield}' and treatments `\texttt{fert}' and
`\texttt{variety}', blocked by `\texttt{block}', with main effects
and treatment interaction:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily effects("wheat.srt.mns",\ "yield fert variety block",
\                 "fert variety fert*variety block",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{ftest(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{numerator}, \Texinfocommandstyletextvar{denominator}, \Texinfocommandstyletextvar{partvars})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{numerator}, \Texinfocommandstyletextvar{denominator}, \Texinfocommandstyletextvar{partvars:} string
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{F-test@F-test}%

\noindent{}\textbf{Description}

Performs an F-test on the hypothesis that all the contrasts specified by \Texinfocommandstyletextvar{numerator}
are zero, using the terms specified by \Texinfocommandstyletextvar{denominator},
and the variances of the cell means, as appropriate, as the error.
The string \Texinfocommandstyletextvar{variable-list} must list the response variable followed by all the variables
in the model and error terms.

The input dataset
must have the following format: for each cell, there must be a line
for the mean, the number of observations for that cell, and the variance
(these three may be in any order)
followed by the denominator terms and then the numerator terms.
These lines are identified respectively by the following values
of the `\texttt{\_type\_}' variable: `\texttt{MEAN}', `\texttt{N}', `\texttt{VAR}', `\texttt{ERROR}', and `\texttt{CONTR}'.
Additional lines, such as `\texttt{LSMEAN}', lines, may follow.
The numerator and denominator terms used for the test,
which need to be adjusted for missing data (as is done by
effects) but which do not need to be orthogonal, are identified by the value of the
`\texttt{\_term\_}' variable in dataset (see `\texttt{effects}').
If \Texinfocommandstyletextvar{numerator} is null, then all the terms identified as
`\texttt{CONTR}' are used in the test.
If \Texinfocommandstyletextvar{denominator}
is null, then the cell variances and all the terms identified as
`\texttt{ERROR}' are used in the test.
If \Texinfocommandstyletextvar{denominator}
is non-null, then the cell variances are not included in the test and `\texttt{ftest}'
constructs an appropriate combination of mean squares
\index[in]{mean squares@mean squares}%
from the terms in
that denominator to test the numerator and applies the Satterthwaite
\index[in]{Satterthwaite@Satterthwaite}%
approximation.
Note, however, that \Texinfocommandstyletextvar{denominator}
must contain all possible terms that might be needed to construct that
combination of mean squares.

The function \Texinfocommandstyletextvar{ftest} writes out a dataset,
with the suffix of \Texinfocommandstyletextvar{dataset} replaced by .tst,
which contains only those error, contrast, and least-squares means terms
appearing in dataset that appear in the test.
This file is suitable for input to \Texinfocommandstyletextvar{lsmeans}.
\index[in]{lsmeans@lsmeans}%
\index[in]{least square means@least square means}%
At the end of that file are two lines, the first
with the mean-squared error appearing as the value of the response variable
and the second with the error degrees of freedom
appearing as the value of the response variable.
These lines are identified by the \_type\_ variable as
`\texttt{MSERROR}' and `\texttt{ERRORDF}', respectively.

\noindent{}\textbf{Code fragment(s)}

\emph{Perform an F-test on the interaction term in the
in the two-way layout in a completely randomized block design with
response variable `\texttt{yield}' and treatments `\texttt{fert}' and
`\texttt{variety}', blocked by `\texttt{block}' as a fixed effect, with main effects
and treatment interaction:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily ftest("wheat.srt.mns.con",\ "yield fert variety block",
\                                    "fert*variety",\ "",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Perform an F-test on the interaction term in the
in the two-way layout in a completely randomized block design with
response variable `\texttt{yield}' and treatments `\texttt{fert}' and
`\texttt{variety}', blocked by `\texttt{block}' as a random effect, with main effects
and treatment interaction:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily ftest("wheat.srt.mns.con",\ "yield fert variety block",\ "fert",
\                                    "block fert*block",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{lsmeans(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{method}, \Texinfocommandstyletextvar{alpha}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{treat}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{format})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{method}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{treat}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{format:} string
\Texinfocommandstyletextvar{alpha:} double
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{lsmeans@lsmeans}%
\index[in]{least square means@least square means}%

\noindent{}\textbf{Description}

For \Texinfocommandstyletextvar{dataset} produced by `\texttt{ftest}' whose \Texinfocommandstyletextvar{numerator} is the same
as the \Texinfocommandstyletextvar{treat} of `\texttt{lsmeans}',
computes the least-squares means of the levels of
\Texinfocommandstyletextvar{treat} and reports the minimum difference significant at level
\Texinfocommandstyletextvar{alpha} and places the comparison of them according to
\Texinfocommandstyletextvar{method} in a dataset named
\Texinfocommandstyletextvar{dataset-name}.lsm,
and displays a table of results, the cells of which are
formated according to \Texinfocommandstyletextvar{format} as for \Texinfocommandstyletextvar{table}.
The available methods are
\index[in]{LSD@LSD}%
\index[in]{Fisher's LSD@Fisher's LSD}%
\index[in]{Tukey@Tukey}%
\index[in]{Dunnett@Dunnett}%
`\texttt{LSD}', `\texttt{TUKEY}', and `\texttt{DUNNETT}'.
For `\texttt{DUNNETT}', the first level of \Texinfocommandstyletextvar{treat} is taken to be the control.
\index[in]{control@control}%

\noindent{}\textbf{Code fragment(s)}

\emph{Compute and test, using the LSD method with significance level
0.05, least squares means
for the one-way layout in a completely randomized block design with
response variable `\texttt{yield}' and treatment `\texttt{fert}',
blocked by `\texttt{block}', with main effects only; the table of
results is displayed with cells 6 characters long and values
to 1 decimal place:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily lsmeans("data.srt.mns.tst",\ "LSD",\ 0.05,
\                    "yield treat block",\ "block",\ "",\ "8.4");
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Categorical data analysis}}
\label{anchor:Categorical-data-analysis}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{freq(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{stat-list}, \Texinfocommandstyletextvar{partvars})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{stat-list}, \Texinfocommandstyletextvar{partvars:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc freq [data=\Texinfocommandstyletextvar{dataset-name}];
by \Texinfocommandstyletextvar{variable-list};
tables \Texinfocommandstyletextvar{variable-1} [* \Texinfocommandstyletextvar{variable-2} [... * \Texinfocommandstyletextvar{variable-n}]] /
             [out=\Texinfocommandstyletextvar{dataset-name}] [noprint] [nofreq] [noprecent]
             [norow] [nocol] [\Texinfocommandstyletextvar{statistics-list}];
weight \Texinfocommandstyletextvar{variable};
\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{freq (SAS proc)@freq (SAS proc)}%
\index[in]{freq@freq}%
\index[in]{contingency table@contingency table}%
\index[in]{cross-tabulation@cross-tabulation}%
\index[in]{cross-classification@cross-classification}%

\noindent{}\textbf{Description}

Writes dataset \Texinfocommandstyletextvar{dataset}.frq with the variable `\texttt{\_cell\_}',
of type double, set equal to the count, fraction, percent, or expected value under
independence, as requested by \Texinfocommandstyletextvar{stat-list}
for the cells with distinct values of the variables in
\Texinfocommandstyletextvar{variable-list}.
The dataset \Texinfocommandstyletextvar{dataset} must be sorted by \Texinfocommandstyletextvar{variable-list}.
The `\texttt{freq}' function does not display its results in the \texttt{lst} file; use
`\texttt{print}' or `\texttt{table}' (see \hyperref[anchor:Displaying-a-dataset]{Section~\ref*{anchor:Displaying-a-dataset} [Displaying a dataset], page~\pageref*{anchor:Displaying-a-dataset}}) after calling
`\texttt{freq}' to display the results from \Texinfocommandstyletextvar{dataset}.frq.
If \Texinfocommandstyletextvar{variable-list} contains a count-variable,
which must appear last in the list and must be preceded by an `\texttt{*}'
and which must be of type double,
then the count, fraction, or percent is weighted by the values of that
count-variable for that cell.
The string \Texinfocommandstyletextvar{stat-list} is a space separated list of one or more of the following statistics:

\textbf{CHISQ}
\index[in]{chi-squared@chi-squared}%
\begin{quote}
for 2-dimensional tables, compute Pearson's chi-squared statistic and test
\end{quote}

\textbf{CMH}
\index[in]{CMH@CMH}%
\index[in]{Cochran-Mantel-Haenszel@Cochran-Mantel-Haenszel}%
\begin{quote}
for tables of dimension 3 or higher, compute the Cochran-Mantel-Haenszel statistic and test,
with strata defined by the levels of all but the last two variables in
\Texinfocommandstyletextvar{variable-list}
\end{quote}

\textbf{COLPERC}
\index[in]{column percentage@column percentage}%
\index[in]{percentage, column@percentage, column}%
\begin{quote}
the percent of the number of observations in the column
\end{quote}

\textbf{COUNT}
\index[in]{count@count}%
\begin{quote}
the number of observations
\end{quote}

\textbf{EXPECTED}
\index[in]{expected count@expected count}%
\index[in]{independence@independence}%
\begin{quote}
for 2-dimensional tables, the expected table entry under independence,
conditioned on the marginal totals
\end{quote}

\textbf{FISHER}
\index[in]{Fisher's exact test@Fisher's exact test}%
\index[in]{exact test@exact test}%
\begin{quote}
for 2x2 tables, computes Fisher's exact test
\end{quote}

\textbf{FRACTION}
\index[in]{fraction@fraction}%
\begin{quote}
the fraction of the total number of observations
\end{quote}

\textbf{NOMINAL}
\index[in]{nominal@nominal}%
\index[in]{association@association}%
\index[in]{measures of association@measures of association}%
\index[in]{uncertainty coefficient@uncertainty coefficient}%
\begin{quote}
for 2-dimensional tables, compute the following measures of association of nominal variables and their asymptotic standard errors: uncertainty coefficients
\end{quote}

\textbf{ODDSRAT}
\index[in]{odds ratio@odds ratio}%
\begin{quote}
for 2x2 tables, computes the odds ratio
\end{quote}

\textbf{ORDINAL}
\index[in]{ordinal@ordinal}%
\index[in]{association@association}%
\index[in]{measures of association@measures of association}%
\index[in]{Kendall's Tau-b@Kendall's Tau-b}%
\index[in]{Somers' D@Somers' D}%
\begin{quote}
for 2-dimensional tables, compute the following measures of association of ordinal variables and their asymptotic standard errors: gamma, Kendall's Tau-b, and Somers' D (column on row and row on column)
\end{quote}

\textbf{PAIR}
\begin{quote}
for 2-dimensional tables, compute measures of association for matched pairs and
their asymptotic standard errors
\end{quote}
\index[in]{paired@paired}%

\textbf{PERCENT}
\begin{quote}
the percent of the total number of observations
\end{quote}
\index[in]{percent@percent}%

\textbf{ROWPERC}
\begin{quote}
the percent of the number of observations in the row
\end{quote}
\index[in]{row percent@row percent}%
\index[in]{percent, row@percent, row}%

For `\texttt{CHISQ}', `\texttt{FISHER}', `\texttt{ODDSRAT}', and `\texttt{ORDINAL}',
the requested statistic and, if applicable, test is displayed in the \texttt{lst} file.
For `\texttt{COUNT}', `\texttt{EXPECTED}', `\texttt{FRACTION}', and `\texttt{PERCENT}',
the requested `\texttt{\_cell\_}' values are indicated in
\Texinfocommandstyletextvar{dataset}.frq by the corresponding value of the `\texttt{\_type\_}' variable.
The input dataset must be sorted by the variables named in
\Texinfocommandstyletextvar{partvars} and \Texinfocommandstyletextvar{variable-list}.

\noindent{}\textbf{Code fragment(s)}

\emph{For each `\texttt{state}' and `\texttt{county}' in
the dataset \texttt{people}, compute and display the cell
percentages for a two-way table whose rows are labeled by
`\texttt{education}' and whose columns are labeled by `\texttt{education}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily freq("people",\ "education income",\ "PERCENT",\ "state county");
table("people.frq",\ "education",\ "income \_cell\_",
\                                             "3.0",\ "state county");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{For each `\texttt{county}' in
the dataset \texttt{people}, compute and display the cell
counts for a two-way table whose rows are labeled by
`\texttt{education}' and whose columns are labeled by `\texttt{education}';
also compute and display the cell counts expected under independence and
the Chi-squared statistic and its significance:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily freq("people",\ "education income",\ "COUNT EXPECTED CHISQ",\ "county");
sort("people.frq",\ "county \_type\_ education income",\ "");
table("people.frq.srt",\ "education",\ "income \_cell\_",
\                                             "6.0",\ "county \_type\_");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{For each `\texttt{state}' and `\texttt{county}' in
the dataset \texttt{people}, compute and display the cell
percentages within row for a two-way table whose rows are labeled by
`\texttt{education}' and whose columns are labeled by `\texttt{education}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily freq("people",\ "education income",\ "ROWPERC",\ "state county");
table("people.frq",\ "education",\ "income \_cell\_",
\                                             "3.0",\ "state county");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{For the dataset \texttt{rabbits.srt}, compute
the Cochran-Mantel-Haenszel statistic and its significance
for a three-way table that is stratified by
`\texttt{penicillin}' and, within each stratum,
whose rows are labeled by
`\texttt{delay}' and whose columns are labeled by `\texttt{response}' and
whose cell counts are given by `\texttt{count}';
:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily freq("rabbits.srt",\ "penicillin delay response*count",\ "CMH",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{categ(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{aux-variable-list}, \Texinfocommandstyletextvar{expect}, \Texinfocommandstyletextvar{param}, \Texinfocommandstyletextvar{select}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{trace})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{aux-variable-list}, \Texinfocommandstyletextvar{select}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{trace:} string
\Texinfocommandstyletextvar{expect:} pointer to function returning double
\Texinfocommandstyletextvar{param:} array of double
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{categ@categ}%
\index[in]{categorical data analysis@categorical data analysis}%
\index[in]{loglinear models@loglinear models}%
\index[in]{logit models@logit models}%
\index[in]{logistic regression@logistic regression}%

\noindent{}\textbf{Description}

`\texttt{Categ}' fits the model specified by the function \Texinfocommandstyletextvar{expect}
and the parameter selection string \Texinfocommandstyletextvar{select} to the data by
the method of maximum likelihood, reports goodness of fit statistics from the
comparison of the specified model with either a reduced
model or the saturated model, writes
the observed and fitted cell counts to \Texinfocommandstyletextvar{dataset}.cat,
with the `\texttt{\_type\_}' variable set to `\texttt{OBS}' and `\texttt{FIT}', respectively,
and the estimates and the covariance matrix to \Texinfocommandstyletextvar{dataset}.cov,
with the `\texttt{\_type\_}' variable set to `\texttt{ESTIMATE}' and
`\texttt{COVAR}', respectively, the `\texttt{\_param1\_}'
and `\texttt{\_param2\_}' variables indicating which of the parameters named in
\Texinfocommandstyletextvar{select} identify the row and column, and the `\texttt{\_cov\_}' variable
containing the numerical value.
The first variable named in \Texinfocommandstyletextvar{variable-list} is the cell count for the cells.
Cells are classified by the remaining variables in \Texinfocommandstyletextvar{variable-list}.
Additional auxiliary variables, such as the total number
of observations or marginal totals, that are required for computing expected
cell counts (see `\texttt{expect}' below) can be listed in \Texinfocommandstyletextvar{aux-variable-list}.
All variables in \Texinfocommandstyletextvar{variable-list} and in \Texinfocommandstyletextvar{aux-variable-list}
must be coded as double; this allows `\texttt{categ}'
to work with continuous and categorical variables together.
The input dataset must be sorted according to the classification variables in
\Texinfocommandstyletextvar{variable-list} in the order that they appear there.
If non-null,
the trace option \Texinfocommandstyletextvar{trace} is passed to `\texttt{dap\_maximize}' for tracing the
maximum likelihood iteration.

The string \Texinfocommandstyletextvar{select} is a space-separated sequence of parameter
names, each one optionally preceded by either a `\texttt{!}' to indicate that
it is to omitted from the model or `\texttt{?}' to indicate that it should
be omitted from the reduced model only.
The number of parameters must equal the dimension of the \Texinfocommandstyletextvar{param} array
and the order corresponds to the order of entries in that array.
Note that the parameter names need not correspond to
variables in the dataset, they are used only to identify
their estimates in the output.
If there are no `\texttt{?}'s, then the goodness of fit statistics
computed are relative to the saturated model.
If there are `\texttt{?}'s, then the goodness of fit statistics are computed
relative to the reduced model obtained by setting all the `\texttt{?}'s to `\texttt{!}'s.

`\texttt{Categ}' assumes that the parameters in \Texinfocommandstyletextvar{param} are independent and computes
the degrees of freedom as the number of cells minus the number of parameters.
See `\texttt{estimate}' (see \hyperref[anchor:Statistics-utilities]{Section~\ref*{anchor:Statistics-utilities} [Statistics utilities], page~\pageref*{anchor:Statistics-utilities}}) to see how to obtain
statistics on the remaining parameters or contrasts.
The initial values of the parameters for the maximum likelihood estimation
must be supplied in the call to `\texttt{categ}'; they are not modified by `\texttt{categ}'.
The function pointed to by \Texinfocommandstyletextvar{expect} must take two parameters, an array of
parameter values, with dimension equal to the number of parameters
specified by the string \Texinfocommandstyletextvar{select},
followed by an array of classification, and possibly auxiliary, values,
with dimension equal to the number of classification and auxiliary
variables in \Texinfocommandstyletextvar{variable-list} and \Texinfocommandstyletextvar{aux-variable-list}, and return the
expected number of observations for the indicated cell, based on
the parameter, classification, and auxiliary (if any) values supplied.

Note: `\texttt{categ}' creates or overwrites the dataset \Texinfocommandstyletextvar{dataset}.fil to
create a dataset with no missing cells for the analysis.

\noindent{}\textbf{Code fragment(s)}

\emph{Use the user-defined function `\texttt{expect}' to fit and
test a loglinear model and print a table of the
observed and fitted cell counts; in the dataset \texttt{deathpen}, the
variable `\texttt{n}' gives the cell counts for the three-way
table classified by `\texttt{def}', `\texttt{vic}', and `\texttt{pen}' and
`\texttt{param}' is an array of 7 independent parameters:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double expect(double param[8],\ double class[2]);
categ("cda262",\ "count income jobsat",\ \&expect,\ param,
\      "mu <6 6-15 15-25 VD LD MS ?Inc*Sat",\ "",\ "");
sort("cda262.cat",\ "income \_type\_ jobsat",\ "");
table("cda262.cat.srt",\ "income",\ "\_type\_ jobsat count",\ "6.2",\ "");

\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{loglin(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{model0}, \Texinfocommandstyletextvar{model1}, \Texinfocommandstyletextvar{partvars})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{model0}, \Texinfocommandstyletextvar{model1}, \Texinfocommandstyletextvar{partvars:} string
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{categ@categ}%
\index[in]{categorical data analysis@categorical data analysis}%
\index[in]{loglinear models@loglinear models}%
\index[in]{logit models@logit models}%

\noindent{}\textbf{Description}

The function `\texttt{loglin}' fits the hierarchical
loglinear models specified by \Texinfocommandstyletextvar{model0} and \Texinfocommandstyletextvar{model1}
and compares them.
The first variable named in \Texinfocommandstyletextvar{variable-list} gives the
cell counts and must be of type double, the remainder give the classification
and must be strings.
The strings \Texinfocommandstyletextvar{model0} and \Texinfocommandstyletextvar{model1} consist of one or more space-separated
terms, each term of which is a `\texttt{*}'-separated list of classification variables.
The model specified by \Texinfocommandstyletextvar{model1} must incorporate at least as many effects
as the one specified by \Texinfocommandstyletextvar{model0}.
If \Texinfocommandstyletextvar{model0} is the null string (not NULL),
then \Texinfocommandstyletextvar{model1} is compared to the saturated model.
The dataset \Texinfocommandstyletextvar{dataset} must be sorted according to
the partitioning variables and the classification
variables in the order listed in \Texinfocommandstyletextvar{variable-list}.
Further, if the input dataset is partitioned, the input data for each part
must have the same table layout and size.
The function `\texttt{loglin}' creates the dataset \Texinfocommandstyletextvar{dataset}.llm
and calls function `\texttt{categ}', which creates the dataset
\Texinfocommandstyletextvar{dataset}.llm.cat, which contains the observed and fitted cell counts and
is copied back to \Texinfocommandstyletextvar{dataset}.llm.

The output in the \texttt{lst} file reports the estimate and asymptotic standard
error for each of the independent parameters of the model, using zero-sum
constraints to eliminate dependent parameters.

\noindent{}\textbf{Code fragment(s)}

\emph{Compare the models `\texttt{vic*pen def*vic}' and `\texttt{def*pen vic*pen def*vic}'
using counts in `\texttt{n}', which gives the cell counts for the three-way
table classified by `\texttt{def}', `\texttt{vic}', and `\texttt{pen}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily loglin("deathpen",\ "n def vic pen",
\       "vic*pen def*vic",\ "def*pen vic*pen def*vic",\ "");
sort("deathpen.llm",\ "def vic \_type\_ pen",\ "");
table("deathpen.llm.srt",\ "def vic",\ "\_type\_ pen n",\ "s6.2 30",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Linear regression}}
\label{anchor:Linear-regression}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{linreg(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{y-variable-list}, \Texinfocommandstyletextvar{x0-variable-list}, \Texinfocommandstyletextvar{x1-variable-list}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{x-dataset}, \Texinfocommandstyletextvar{level})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{y-variable-list}, \Texinfocommandstyletextvar{x0-variable-list}, \Texinfocommandstyletextvar{x1-variable-list}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{x-dataset:} string
\Texinfocommandstyletextvar{level:} double
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc reg [data=\Texinfocommandstyletextvar{dataset-name}] [outest=\Texinfocommandstyletextvar{dataset-name}];
model \Texinfocommandstyletextvar{response-variables} = \Texinfocommandstyletextvar{explanatory-variables};
[var \Texinfocommandstyletextvar{variable-list};]
[add \Texinfocommandstyletextvar{variable-list};]
by \Texinfocommandstyletextvar{variable-list};
[plot \Texinfocommandstyletextvar{y-variable} * \Texinfocommandstyletextvar{x-variable};]

\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{reg (SAS proc)@reg (SAS proc)}%

\noindent{}\textbf{Description}

Performs ordinary least squares linear regression for each variable in
\Texinfocommandstyletextvar{y-variable-list} as a function of all the variables in \Texinfocommandstyletextvar{x0-variable-list}
and \Texinfocommandstyletextvar{x1-variable-list}, computes t-tests on each parameter, and
and tests the full model against the model with just the variables in
\Texinfocommandstyletextvar{x0-variable-list}.
The model always includes an intercept term, which is named \_intercept\_
and is always included implicitly in \Texinfocommandstyletextvar{x0-variable-list}.

Results are displayed in the \texttt{lst} file.
In addition, for each of the specified values of the variables in
\Texinfocommandstyletextvar{x0-variable-list} and \Texinfocommandstyletextvar{x1-variable-list},
observed and predicted values and lower and upper confidence limits
for the mean at \Texinfocommandstyletextvar{level} for each of the variables in
\Texinfocommandstyletextvar{y-variables} are written to \Texinfocommandstyletextvar{dataset}.reg
in lines identified by the respective values
`\texttt{OBS}', `\texttt{PRED}', `\texttt{LOWER}', and `\texttt{UPPER}' of the `\texttt{\_type\_}' variable.
These values are given as the values of the \Texinfocommandstyletextvar{y-variables} in \Texinfocommandstyletextvar{dataset}.reg.
If \Texinfocommandstyletextvar{x-dataset} is non-null, specified values for the x-variables
are read from that dataset; otherwise, the values of the x-variables in
\Texinfocommandstyletextvar{dataset} are used.
Finally,
the estimates and covariance matrix are written to the file \Texinfocommandstyletextvar{dataset}.cov,
with the `\texttt{\_type\_}' variable set to `\texttt{ESTIMATE}' and
`\texttt{COVAR}', respectively, the `\texttt{\_response\_}' variable indicating
the response variable and the `\texttt{\_param1\_}'
and `\texttt{\_param2\_}' variables indicating which parameters
identify the row and column, and the `\texttt{\_cov\_}' variable containing the numerical value.

SAS note: If you include a `\texttt{plot}' statement, then the model must contain
only one response and one explanatory variable. If there is an `\texttt{add}'
statement, the model will be fit as originally specified and with the
additional variables and the change in R-squared will be reported.
The `\texttt{var}' statement is ignored in any case.

\noindent{}\textbf{Code fragment(s)}

\emph{Perform linear regression of the response variable `\texttt{strength}'
on the independent variables `\texttt{length}' and `\texttt{thickness}', based
on the values in the dataset \texttt{wires}, and
compare the full model with the reduced model that contains the
intercept term only:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily linreg("wires",\ "strength",\ "",\ "length thickness",\ "",\ NULL,\ 0.0);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Perform linear regression of the response variable `\texttt{strength}'
on the independent variables `\texttt{length}' and `\texttt{thickness}', based
on the values in the dataset \texttt{wires}, and
compare the full model with the reduced model that contains the
intercept term and `\texttt{length}' only; also compute predicted values and
the endpoints of 95\% confidence intervals for the mean of the response
for the values of `\texttt{length}'
and `\texttt{thickness}' in the dataset \texttt{steps}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily linreg("wires",\ "strength",\ "length",\ "thickness",\ "",\ "steps",\ 0.95);
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{linear regression@linear regression}%
\index[in]{regression, linear@regression, linear}%

\section{{Logistic regression}}
\label{anchor:Logistic-regression}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{logreg(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{y-spec}, \Texinfocommandstyletextvar{x0-var-list}, \Texinfocommandstyletextvar{x1-var-list}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{x-dataset-name}, \Texinfocommandstyletextvar{level})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{y-spec}, \Texinfocommandstyletextvar{x0-var-list}, \Texinfocommandstyletextvar{x1-var-list}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{x-dataset-name:} string
\Texinfocommandstyletextvar{level:} double
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc logistic [data=\Texinfocommandstyletextvar{dataset-name}] [outest=\Texinfocommandstyletextvar{dataset-name}];
model \{\Texinfocommandstyletextvar{variable} | \Texinfocommandstyletextvar{events}/\Texinfocommandstyletextvar{trials}\} = \Texinfocommandstyletextvar{explanatory-variables};
by \Texinfocommandstyletextvar{variable-list};

\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{logistic (SAS proc)@logistic (SAS proc)}%
\index[in]{logistic regression@logistic regression}%
\index[in]{regression, logistic@regression, logistic}%

\noindent{}\textbf{Description}

Performs logistic regression for the response variable in
\Texinfocommandstyletextvar{y-spec} as a function of all the variables in
\Texinfocommandstyletextvar{x0-var-list} and \Texinfocommandstyletextvar{x1-var-list},
and tests the full model against the model with just the variables in
\Texinfocommandstyletextvar{x0-var-list}.
The model always includes an intercept term, which is named
`\texttt{\_intercept\_}' and is always included implicitly in
\Texinfocommandstyletextvar{x0-var-list}.
Variables in \Texinfocommandstyletextvar{y-spec}, \Texinfocommandstyletextvar{x0-var-list}, and \Texinfocommandstyletextvar{x1-var-list}
must be of type double.
Two forms for the response in \Texinfocommandstyletextvar{y-spec}
are available: \Texinfocommandstyletextvar{events-variable} / \Texinfocommandstyletextvar{trials-number},
in which \Texinfocommandstyletextvar{trials-number} is an explicit number (e.g., 1 for binary data),
and \Texinfocommandstyletextvar{events-variable} / \Texinfocommandstyletextvar{trials-variable},
in which \Texinfocommandstyletextvar{events-variable}
is a count of successes in the number of trials specified by \Texinfocommandstyletextvar{trials-variable}.

Results are displayed in the \texttt{lst} file.
In addition, for each of the specified values of the variables in
\Texinfocommandstyletextvar{x0-var-list} and \Texinfocommandstyletextvar{x1-var-list},
observed and predicted probabilities
and lower and upper confidence limits at
\Texinfocommandstyletextvar{level} for the probability that the \Texinfocommandstyletextvar{events-variable}
is 1 are written to \Texinfocommandstyletextvar{dataset}.lgr
in lines identified by the respective values
`\texttt{PRED}', `\texttt{LOWER}', and `\texttt{UPPER}' of the `\texttt{\_type\_}' variable.
These values are given as the values of the \Texinfocommandstyletextvar{events-variable} in \Texinfocommandstyletextvar{dataset}.lgr.
If \Texinfocommandstyletextvar{x-dataset-name}
is non-null, specified values for the x-variables
are read from that dataset; otherwise, the values of the x-variables in
\Texinfocommandstyletextvar{dataset} are used.
Finally,
the estimates and covariance matrix are written to the file \Texinfocommandstyletextvar{dataset}.cov,
with the `\texttt{\_type\_}' variable set to `\texttt{ESTIMATE}' and
`\texttt{COVAR}', respectively, the `\texttt{\_param1\_}'
and `\texttt{\_param2\_}' variables indicating which parameters
identify the row and column, and the `\texttt{\_cov\_}' variable containing the numerical value.

SAS note: only binary response is allowed, although the
\Texinfocommandstyletextvar{events}/\Texinfocommandstyletextvar{trials} form
allows that to be expressed as the result of a binomial experiment.

\noindent{}\textbf{Code fragment(s)}

\emph{Perform logistic regression with the binomial response variable
`\texttt{heartdis}', with values from 0 to `\texttt{ncases}' in each observation,
on the independent variable `\texttt{bloodpress}', based on the values in
the dataset \texttt{heartrisk}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily logreg("heartrisk",\ "heartdis / ncases",
\                 "",\ "bloodpress",\ "",\ NULL,\ 0.0);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Perform logistic regression with the binomial response variable
`\texttt{larvae}', with values from 0 to 10 in each observation,
on the independent variable `\texttt{co2}', based on the values in
the dataset \texttt{biocontrol}; also computed predicted values and
the endpoints of 95\% confidence intervals for the mean response:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily logreg("biocontrol",\ "larvae / 10",
\                 "",\ "co2",\ "",\ "biocontrol.mns",\ 0.95);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Nonparametric analyses}}
\label{anchor:Nonparametric-analyses}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{nonparam(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{partvars})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{partvars:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc npar1way [data=\Texinfocommandstyletextvar{dataset-name}];
class \Texinfocommandstyletextvar{class-variable};
var \Texinfocommandstyletextvar{variable-list};
by \Texinfocommandstyletextvar{variable-list};

\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{npar1way (SAS proc)@npar1way (SAS proc)}%

\noindent{}\textbf{Description}

If \Texinfocommandstyletextvar{variable-list} contains the name of only one variable,
which must be of type double, then `\texttt{nonparam}'
tests the Wilcoxon signed rank statistic on the values of that variable.
If \Texinfocommandstyletextvar{variable-list}
contains the names of two variables, then the first must be of type double
and the second must be of type string.
If the second variable has two levels, then
`\texttt{nonparam}' tests the Wilcoxon rank sum statistic
and the Kolmogorov two-sample statistic of the values
of the first variable classified by the values of the second.
If the second variable has more than two levels, then
`\texttt{nonparam}' tests the Kruskal-Wallis statistic of the values
of the first variable classified by the values of the second.
The input dataset does not need to be sorted.

SAS note: In `\texttt{proc npar1way}', the `\texttt{class}' and `\texttt{var}' statements are required
and the class variable must be of type string.

\noindent{}\textbf{Code fragment(s)}

\emph{For each distince value of `\texttt{sex}',
perform a Wilcoxon signed rank test on the values of `\texttt{weightchange}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nonparam("diettest",\ "weightchange",\ "sex");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Perform a Kuskal-Wallis test on the values of `\texttt{weightchange}'
as classified by `\texttt{drug}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nonparam("diettest",\ "weightchange drug",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{nonparametric@nonparametric}%
\index[in]{distribution-free@distribution-free}%
\index[in]{Wilcoxon@Wilcoxon}%
\index[in]{Mann-Whitney-Wilcoxon@Mann-Whitney-Wilcoxon}%
\index[in]{signed rank@signed rank}%
\index[in]{Kolmogorov@Kolmogorov}%
\index[in]{empirical distribution function@empirical distribution function}%

\section{{Statistics utilities}}
\label{anchor:Statistics-utilities}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{estimate(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{parameters}, \Texinfocommandstyletextvar{definitions}, \Texinfocommandstyletextvar{partvars})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{parameters}, \Texinfocommandstyletextvar{definitions}, \Texinfocommandstyletextvar{partvars:} string
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{categ@categ}%
\index[in]{estimate@estimate}%
\index[in]{categorical data analysis@categorical data analysis}%
\index[in]{loglinear models@loglinear models}%
\index[in]{logit models@logit models}%

\noindent{}\textbf{Description}

`\texttt{Estimate}' prints the estimate and standard error for each of
the parameters defined in \Texinfocommandstyletextvar{definitions}, based on the estimates and covariance matrix
provided by the dataset \Texinfocommandstyletextvar{dataset} for the parameters named in the space-separated
list \Texinfocommandstyletextvar{parameters}.
\Texinfocommandstyletextvar{dataset} is typically the `\texttt{.cov}' dataset output by a
function such as `\texttt{loglin}', `\texttt{categ}', `\texttt{linreg}', or `\texttt{logreg}' and
must contain, in addition to the `\texttt{\_type\_}' variable, variables named
`\texttt{\_param1\_}', `\texttt{\_param2\_}', and `\texttt{\_cov\_}': the first two are string variables
specifying the parameters by which the estimates and covariance matrix are indexed
and the last is the entry in the estimate vector or covariance matrix.
For the value `\texttt{ESTIMATE}' of `\texttt{\_type\_}', the variable `\texttt{\_param2\_}'
specifies the parameter. The value `\texttt{COVAR}' of `\texttt{\_type\_}' indicates that
the value of `\texttt{\_cov\_}' is an entry in the covariance matrix.

The string `\texttt{definitions}' is a space-separated list of equations of the form
\Texinfocommandstyletextvar{param} = \Texinfocommandstyletextvar{coefficient\_1} \Texinfocommandstyletextvar{param\_1} ... \Texinfocommandstyletextvar{coefficient\_n} \Texinfocommandstyletextvar{param\_n}, in which
\Texinfocommandstyletextvar{param\_1} through \Texinfocommandstyletextvar{param\_n} are the names of parameters whose
estimates and covariances appear in \Texinfocommandstyletextvar{dataset} or a previous definition
and each \Texinfocommandstyletextvar{coefficient} is a decimal number.
A `\texttt{+}' is optional for positive coefficients.
\Texinfocommandstyletextvar{coefficient\_1} may be omitted if it would be a `\texttt{+1}'.

\noindent{}\textbf{Code fragment(s)}

\emph{Use the user-defined function `\texttt{expect}' to fit and
test a saturated logit model for the 4 by 2 table with 4 rootstocks,
A, I, II, and U, and two levels of disease, 0 and 1.
`\texttt{param}' is an array of 8 independent parameters based on the
identifiability constraints lambda\_A + lambda\_I + lambda\_II + lambda\_U = 0,
lambda\_d0 + lambda\_d1 = 0, and mu\_A + mu\_I + mu\_II + mu\_U = 0.
Finally use `\texttt{estimate}' to define the missing parameter
mu\_U and test the contrast diff\_I\_U = mu\_I - mu\_U:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double expect(double param[8],\ double class[2]);
categ("rootdisease",\ "\_cell\_ root disease",\ \&expect,\ param,
\      "mu lambda\_A lambda\_I lambda\_II lambda\_d0 mu\_A mu\_I mu\_II",\ "",\ "");
estimate("rootdisease.cov",\ "mu\_A mu\_I mu\_II",
\       "mu\_U = - mu\_A - mu\_I - mu\_II diff\_I\_U = mu\_I - mu\_U",\ "");

\end{Texinfopreformatted}
\end{Texinfoindented}


\chapter{{Graphics functions}}
\label{anchor:Graphics-functions}%


\section{{Histogram}}
\label{anchor:Histogram}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{histogram(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{nbars}, \Texinfocommandstyletextvar{style}, \Texinfocommandstyletextvar{xfunct}, \Texinfocommandstyletextvar{nplots})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable-list}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{style:} string
\Texinfocommandstyletextvar{nbars}, \Texinfocommandstyletextvar{nplots:} int
\Texinfocommandstyletextvar{xfunct:} pointer to function returning double
\Texinfocommandstyletextvar{Returns:} array of `\texttt{pict}'
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{histogram@histogram}%
\index[in]{nport@nport}%

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc chart [data=\Texinfocommandstyletextvar{dataset-name}];
by \Texinfocommandstyletextvar{variable-list};
vbar \Texinfocommandstyletextvar{variable} / [freq=\Texinfocommandstyletextvar{variable}] [levels=\Texinfocommandstyletextvar{n}]
                  [axis=[\Texinfocommandstyletextvar{min}] \Texinfocommandstyletextvar{max}]
                  [type=freq | percent | pct];
\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{chart (SAS proc)@chart (SAS proc)}%

\noindent{}\textbf{Description}

Constructs an array of `\texttt{pict}' structures for
drawing (see \hyperref[anchor:Displaying-the-pictures]{Section~\ref*{anchor:Displaying-the-pictures} [Displaying the pictures], page~\pageref*{anchor:Displaying-the-pictures}})
separate histograms of the values of the first variable in
\Texinfocommandstyletextvar{variable-list}, weighted by the second variable, if present, in
\Texinfocommandstyletextvar{variable-list}, for each distinct set of values of
\Texinfocommandstyletextvar{partvars}.
The first variable name may be followed by a string, enclosed in back quotes (`\texttt{`}'),
to be used instead of the variable name as the x-axis label.
Each histogram has \Texinfocommandstyletextvar{nbars} bars.
The string \Texinfocommandstyletextvar{style} is either the null string or
contains axis specifications as for `\texttt{pict\_autoaxes}' (see \hyperref[anchor:Axes]{Section~\ref*{anchor:Axes} [Axes], page~\pageref*{anchor:Axes}})
and can optionally specify
`\texttt{EQUAL}' or `\texttt{VARIABLE}' width bars, each of which represents either the `\texttt{COUNT}'
(only for equal width bars) or `\texttt{PERCENT}' or `\texttt{FRACTION}' of the observations.
If \Texinfocommandstyletextvar{style} contains the word `\texttt{MINX}', followed without a space by a number,
then the horizontal minimum point of the histogram(s) is that number. 
If \Texinfocommandstyletextvar{style} contains the word `\texttt{MAXX}', followed without a space by a number,
then the horizontal maximum point of the histogram(s) is that number. 
If \Texinfocommandstyletextvar{style} contains the word `\texttt{MAXY}', followed without a space by a number,
then the vertical maximum point of the histogram(s) is that number. 
If \Texinfocommandstyletextvar{style} contains the word `\texttt{ROUND}',
then the right and left ends of the histogram are expanded,
if necessary, to make the width of the bars rounded to 1 digit.
The function pointed to by \Texinfocommandstyletextvar{xfunct} applies to the x-axis as in the description of
`\texttt{pict\_autoaxes}'.
The default is equal width bars of counts.
The integer \Texinfocommandstyletextvar{nplots}
must be at least as large as the number of parts created by
\Texinfocommandstyletextvar{partvars}.
The function `\texttt{histogram}'
allocates an array of `\texttt{picts}' for the histograms and axes, in which the
picts for all the plots come first, followed by an equal number of `\texttt{pict}'s for the
corresponding axes, and returns the starting address of that array.

\noindent{}\textbf{Code fragment(s)}

\emph{Display a histogram, in portrait orientation with a surrounding
box, of 10 variable-width bars that show counts of
the values of `\texttt{height}' in the dataset \texttt{people}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(histogram("people",\ "height",\ "",
\                          10,\ "VARIABLE ==",\ NULL,\ 1),\ 1,\ 1);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Display a histogram for each of 58 counties, on 58 pages in portrait orientation
with axes at (0, 0), of 25 equal-width bars extending from 0 to 84 that show counts of
the values of `\texttt{height}' in the dataset \texttt{people}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(histogram("people",\ "height",\ "county",
\                          25,\ "MIN0 MAX84",\ NULL,\ 58),\ 58,\ 1);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Display a histogram for each of 58 counties, on 58 pages in portrait orientation
with axes at (0, 0), of 25 equal-width bars that show percentages of
the values of `\texttt{height}' in the dataset \texttt{people}:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(histogram("people",\ "height",\ "county",
\                          25,\ "PERCENT",\ NULL,\ 58),\ 58,\ 1);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Normal probability plot}}
\label{anchor:Normal-probability-plot}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{normal(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{nplots})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{variable}, \Texinfocommandstyletextvar{partvars:} string
\Texinfocommandstyletextvar{nplots:} int
\Texinfocommandstyletextvar{Returns:} array of `\texttt{pict}'
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{normal@normal}%
\index[in]{normal probability plot@normal probability plot}%
\index[in]{Shapiro-Wilk@Shapiro-Wilk}%
\index[in]{q-q plot@q-q plot}%
\index[in]{nport@nport}%

\noindent{}\textbf{Description}

If \Texinfocommandstyletextvar{nplots} is greater than 0, constructs an array of `\texttt{pict}' structures for
drawing (see \hyperref[anchor:Displaying-the-pictures]{Section~\ref*{anchor:Displaying-the-pictures} [Displaying the pictures], page~\pageref*{anchor:Displaying-the-pictures}})
a q-q plot of the values of \Texinfocommandstyletextvar{variable}
for each part of \Texinfocommandstyletextvar{dataset} defined by the values of \Texinfocommandstyletextvar{partvars}.
If the number of values is at least 3 but no more than 2000, performs a Shapiro-Wilk test
for normality, the results of which are reported in the lst file and, if
\Texinfocommandstyletextvar{nplots} is greater than 0, in the caption of the `\texttt{pict}'s.
Each q-q plot is prepared for display on a separate page.
The integer \Texinfocommandstyletextvar{nplots}
must be at least as large as the number of parts created by \Texinfocommandstyletextvar{partvars}.
The function `\texttt{normal}'
allocates an array of \Texinfocommandstyletextvar{picts} for the plots and axes, in which all
the plots come first, and returns the address of that array.

\noindent{}\textbf{Code fragment(s)}

\emph{For each distinct value of `\texttt{block}', display a q-q plot
of the values of `\texttt{yield}' and apply the
Shapiro-Wilk test for normality:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(normal("wheat",\ "yield",\ "block",\ 4),\ 4,\ 1);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Scatter plot or line graph}}
\label{anchor:Scatter-plot-or-line-graph}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{plot(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{xyvar}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{style}, \Texinfocommandstyletextvar{xfunct}, \Texinfocommandstyletextvar{yfunct}, \Texinfocommandstyletextvar{nplots})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{xyvar}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{style:} string
\Texinfocommandstyletextvar{xfunct}, \Texinfocommandstyletextvar{yfunct:} pointer to function returning double
\Texinfocommandstyletextvar{nplots:} int
\Texinfocommandstyletextvar{Returns:} array of `\texttt{pict}'
\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc plot [data=\Texinfocommandstyletextvar{dataset-name}];
by \Texinfocommandstyletextvar{variable-list};
plot \Texinfocommandstyletextvar{y-variable} * \Texinfocommandstyletextvar{xvariable} [/ [box]];
[...
plot \Texinfocommandstyletextvar{y-variable} * \Texinfocommandstyletextvar{xvariable} [/ [box]];]
\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{plot (SAS proc)@plot (SAS proc)}%
\index[in]{plot@plot}%
\index[in]{scatter plot@scatter plot}%
\index[in]{line graph@line graph}%
\index[in]{nport@nport}%

\noindent{}\textbf{Description}

For \Texinfocommandstyletextvar{dataset},
constructs an array of `\texttt{pict}' structures for
plotting (see \hyperref[anchor:Displaying-the-pictures]{Section~\ref*{anchor:Displaying-the-pictures} [Displaying the pictures], page~\pageref*{anchor:Displaying-the-pictures}})
the points whose coordinates are in the two variables listed in \Texinfocommandstyletextvar{xyvar}.
Each of those variable names may be followed by a string, enclosed in back quotes,
to be used instead of the variable name as the axis label.
Points are plotted in the order that they appear in the dataset and therefore must be sorted
for a line graph.
The default type of graph is a scatter plot with circles marking the points.
To get a line graph, you must set the value of the `\texttt{pict\_type}'
field of the `\texttt{pict}' to the string `\texttt{LINE}';
see the description of the `\texttt{pict}' structure.
If the first character of \Texinfocommandstyletextvar{style} is `\texttt{o}'
and is not followed by an integer,
then the plots for the different values of the \Texinfocommandstyletextvar{partvars}
are all prepared to be displayed on the same pair of axes on the same page.
If the first character of \Texinfocommandstyletextvar{style} is `\texttt{o}'
and is followed by an integer \Texinfocommandstyletextvar{n},
then the plots are overlayed in consecutive groups of size \Texinfocommandstyletextvar{n}.
Otherwise those plots are prepared to be displayed on different pages.
The remaining characters of \Texinfocommandstyletextvar{style}
and the functions \Texinfocommandstyletextvar{xfunct} and \Texinfocommandstyletextvar{yfunct}
are axis specifications as for `\texttt{pict\_autoaxes}' (see \hyperref[anchor:Axes]{Section~\ref*{anchor:Axes} [Axes], page~\pageref*{anchor:Axes}}).
The integer \Texinfocommandstyletextvar{nplots}
must be at least as large as the number of groups created by
\Texinfocommandstyletextvar{partvars}.
The function
`\texttt{plot}' allocates an array of `\texttt{pict}'s for the plots and axes, in which all
the plots come first, and returns the address of that array.

\noindent{}\textbf{Code fragment(s)}

\emph{Display a scatter plot in portrait orientation
with `\texttt{height}' on the horizontal
axis and `\texttt{weight}' on the vertical axis:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(plot("people",\ "height weight",\ "",\ "",\ NULL,\ NULL,\ 1),\ 1,\ 1);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Overlay 4 scatter plots, one for each distinct value
of `\texttt{plot}', on one page in portrait orientation,
with `\texttt{fert}' on the horizontal
axis and `\texttt{yield}' on the vertical axis, and make the symbols
be open circles, filled-in circles, open squares, and filled-in
squares, respectively:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict *p;

p = plot("wheat",\ "fert yield",\ "plot",\ "o",\ NULL,\ NULL,\ 4);
strcpy(p[0].pict\_type,\ "CIRC");
strcpy(p[1].pict\_type,\ "CIRC");
p[1].pict\_fgray = 0.0;
strcpy(p[2].pict\_type,\ "SQUA");
strcpy(p[3].pict\_type,\ "SQUA");
p[3].pict\_fgray = 0.0;
nport(p,\ 4,\ 4);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Display one boxed line graph per page in portrait orientation
for each of the 2 distinct values of `\texttt{species}'
with `\texttt{time}' on the horizontal
axis and `\texttt{logpop}' on the vertical axis, with
the `\texttt{exp}' function applied to the vertical coordinate labels:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict *p;

p = plot("bacteria",\ "time logpop",\ "species",
\                                     "==",\ NULL,\ \&exp,\ 2);
strcpy(p[0].pict\_type,\ "LINE");
strcpy(p[1].pict\_type,\ "LINE");
nport(p,\ 2,\ 1);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Overlay 6 boxed scatter plots, one for each distinct value
of `\texttt{plot}', 3 per page on 2 pages in portrait orientation,
with `\texttt{fert}' on the horizontal
axis and `\texttt{yield}' on the vertical axis, and make the symbols
be open circles, open triangles, and open squares,
respectively, on each of the 2 pages:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict *p;

p = plot("wheat",\ "fert yield",\ "plot variety",
\                                     "o3 ==",\ NULL,\ NULL,\ 6);
strcpy(p[0].pict\_type,\ "CIRC");
strcpy(p[1].pict\_type,\ "TRIA");
strcpy(p[2].pict\_type,\ "SQUA");
strcpy(p[3].pict\_type,\ "CIRC");
strcpy(p[4].pict\_type,\ "TRIA");
strcpy(p[5].pict\_type,\ "SQUA");
nport(p,\ 6,\ 3);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Plotting means}}
\label{anchor:Plotting-means}%
\index[in]{mean@mean}%
\index[in]{error bar@error bar}%
\index[in]{standard deviation@standard deviation}%
\index[in]{standard error@standard error}%
\index[in]{plot@plot}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{plotmeans(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{y-variable}, \Texinfocommandstyletextvar{x-variable}, \Texinfocommandstyletextvar{errorbars}, \Texinfocommandstyletextvar{style}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{noverlay})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{y-variable}, \Texinfocommandstyletextvar{x-variable}, \Texinfocommandstyletextvar{errorbars}, \Texinfocommandstyletextvar{style}, \Texinfocommandstyletextvar{partvars:} string
\Texinfocommandstyletextvar{noverlay:} int
\Texinfocommandstyletextvar{Returns:} array of `\texttt{pict}'
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{means@means}%
\index[in]{plotmeans@plotmeans}%
\index[in]{nport@nport}%

\noindent{}\textbf{Description}

Constructs an array of `\texttt{pict}' structures for
plotting (see \hyperref[anchor:Displaying-the-pictures]{Section~\ref*{anchor:Displaying-the-pictures} [Displaying the pictures], page~\pageref*{anchor:Displaying-the-pictures}})
the mean, with an error bar, of \Texinfocommandstyletextvar{y-variable} for each value of \Texinfocommandstyletextvar{x-variable}.
Both variables must be of type double and either or both may be followed by
a string, enclosed in back quotes,
to be used instead of the variable name as the axis label.
The height of the error bar above and below the mean
can be specified to be any statistic available for the `\texttt{means}' function,
optionally multiplied by a scale factor, which follows the statistic name and
a space in \Texinfocommandstyletextvar{errorbars}.
The string \Texinfocommandstyletextvar{style} is as in \Texinfocommandstyletextvar{plot}, except that overlaying is controlled
by \Texinfocommandstyletextvar{plotmeans} and must not be specified in \Texinfocommandstyletextvar{style}.
If \Texinfocommandstyletextvar{partvars} is null (""), then the array of `\texttt{pict}'s has two elements, the first for
the error bars and the second for the means.
If \Texinfocommandstyletextvar{partvars} is not null but \Texinfocommandstyletextvar{noverlay} is 1,
then the array of `\texttt{pict}'s has those same two elements
for each part of the dataset and each plot is on a separate page.
If \Texinfocommandstyletextvar{partvars} is not null and \Texinfocommandstyletextvar{noverlay} is greater than 1,
then the array of `\texttt{pict}'s has those same two elements
for each part of the dataset but the elements are linked so that \Texinfocommandstyletextvar{noverlay}
pictures appear on the same set of axes.
NOTE: this function creates the following datasets or overwrites them if they exist:
\Texinfocommandstyletextvar{dataset}.mns, \Texinfocommandstyletextvar{dataset}.err, and \Texinfocommandstyletextvar{dataset}.err.srt.

\noindent{}\textbf{Code fragment(s)}

\emph{For each distinct value of `\texttt{thickness}', compute
the mean and standard deviation of the values of `\texttt{strength}'
and display on a single page in portrait orientation
the means with error bars extending the standard
deviation above and below the mean:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(plotmeans("wires",\ "strength",\ "thickness",\ "SD",
\                                                 "",\ 0),\ 2,\ 2);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{For each distinct value of `\texttt{thickness}', compute
the mean and standard error of the mean of the values of `\texttt{strength}'
and display on a single page in portrait orientation
the means with error bars extending 1.96 times the standard
error of the mean above and below the mean:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(plotmeans("wires",\ "strength",\ "thickness",\ "SEM 1.96",
\                                                 "",\ 0),\ 2,\ 2);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{For each of 3 distinct values of `\texttt{metal}' display
a separate page on which appears, for
each distinct value of `\texttt{thickness}',
the means of `\texttt{strength}' with error bars extending the standard
deviation above and below the mean:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(plotmeans("wires",\ "strength",\ "thickness",\ "SD",
\                                                 "metal",\ 1),\ 6,\ 2);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{For each of 3 distinct values of `\texttt{metal}', display
overlayed on a single page the means of `\texttt{strength}'
for each distinct value of `\texttt{thickness}',
with error bars extending the standard
deviation above and below the mean:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(plotmeans("wires",\ "strength",\ "thickness",\ "SD",
\                                                 "metal",\ 3),\ 6,\ 6);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Regression plots}}
\label{anchor:Regression-plots}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{plotlinreg(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{y-variable}, \Texinfocommandstyletextvar{x-variable}, \Texinfocommandstyletextvar{style}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{nparts}, \Texinfocommandstyletextvar{level})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{y-variable}, \Texinfocommandstyletextvar{x-variable}, \Texinfocommandstyletextvar{style}, \Texinfocommandstyletextvar{partvars:} string
\Texinfocommandstyletextvar{nparts:} int
\Texinfocommandstyletextvar{level:} double
\Texinfocommandstyletextvar{Returns:} array of `\texttt{pict}'
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{linear regression@linear regression}%
\index[in]{regression, linear@regression, linear}%
\index[in]{plot@plot}%

\noindent{}\textbf{Description}

Runs \Texinfocommandstyletextvar{linreg} on \Texinfocommandstyletextvar{dataset},
allocates an array of `\texttt{pict}'s for the plots and axes for the plots
of the observed data the regression line, and the curves enclosing a
\Texinfocommandstyletextvar{level} confidence region for the predicted mean of
\Texinfocommandstyletextvar{y-variable}, and returns the address of the array of `\texttt{pict}'s,
to be displayed
as \Texinfocommandstyletextvar{nparts} page(s) of 4 overlayed pictures each (see \hyperref[anchor:Displaying-the-pictures]{Section~\ref*{anchor:Displaying-the-pictures} [Displaying the pictures], page~\pageref*{anchor:Displaying-the-pictures}}).
Both \Texinfocommandstyletextvar{x-variable} and \Texinfocommandstyletextvar{y-variable} must be single variables and each
may be followed by an axis label enclosed in pairs of `\texttt{`}'.
\Texinfocommandstyletextvar{dataset} must be partitioned by \Texinfocommandstyletextvar{partvars} into exactly \Texinfocommandstyletextvar{nparts} parts.
\Texinfocommandstyletextvar{style} may contain axis specifications as for `\texttt{pict\_autoaxes}'
(see \hyperref[anchor:Axes]{Section~\ref*{anchor:Axes} [Axes], page~\pageref*{anchor:Axes}}).
NOTE: This function creates the following datasets or overwrites them if they exist:
\Texinfocommandstyletextvar{dataset}.mns, \Texinfocommandstyletextvar{dataset}.reg, and \Texinfocommandstyletextvar{dataset}.reg.srt.

\noindent{}\textbf{Code fragment(s)}

\emph{Display on one page a scatter plot of the data,
with `\texttt{thickness}' on the horizontal
axis, which will be labeled `\texttt{Thickness}',
and `\texttt{strength}' on the vertical axis,
while will be labeled `\texttt{Strength}', and the regression line
and the curves defining a 95\% confidence region for the predicted
means:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(plotlinreg("wires",\ "stren`Strength`",\ "thick`Thickness`",
\                 "==",\ "",\ 1,\ 0.95),\ 4,\ 4);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{For each of the 4 values of the variable `\texttt{plot}',
display on a separate page a scatter plot of the data,
with `\texttt{salin}' on the horizontal
axis and `\texttt{yield}' on the vertical axis, the regression line,
and the curves defining a 95\% confidence region for the predicted
means:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(plotlinreg("pist",\ "yld",\ "sal",\ "==",\ "plot",\ 4,\ 0.95),\ 16,\ 4);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{plotlogreg(\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{y-spec}, \Texinfocommandstyletextvar{x-variable}, \Texinfocommandstyletextvar{style}, \Texinfocommandstyletextvar{ngroups}, \Texinfocommandstyletextvar{partvars}, \Texinfocommandstyletextvar{nparts}, \Texinfocommandstyletextvar{level})}
\Texinfocommandstyletextvar{dataset}, \Texinfocommandstyletextvar{y-spec}, \Texinfocommandstyletextvar{x-variable}, \Texinfocommandstyletextvar{style}, \Texinfocommandstyletextvar{partvars:} string
\Texinfocommandstyletextvar{ngroups}, \Texinfocommandstyletextvar{nparts:} int
\Texinfocommandstyletextvar{level:} double
\Texinfocommandstyletextvar{Returns:} array of `\texttt{pict}'
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{logistic regression@logistic regression}%
\index[in]{regression, logistic@regression, logistic}%
\index[in]{plot@plot}%

\noindent{}\textbf{Description}

Runs \Texinfocommandstyletextvar{logreg} on \Texinfocommandstyletextvar{dataset},
allocates an array of `\texttt{pict}'s for the plots and axes for
plots the logistic regression curve and the curves enclosing a
\Texinfocommandstyletextvar{level} confidence region for the predicted expectation of
the response variable in
\Texinfocommandstyletextvar{y-spec}, and returns the starting address of the array of `\texttt{pict}'s,
to be displayed
as \Texinfocommandstyletextvar{nparts} page(s) of 4 overlayed pictures each (see \hyperref[anchor:Displaying-the-pictures]{Section~\ref*{anchor:Displaying-the-pictures} [Displaying the pictures], page~\pageref*{anchor:Displaying-the-pictures}}).
Also plots the mean of the response variable in \Texinfocommandstyletextvar{y-spec} for the
\Texinfocommandstyletextvar{ngroups} groups of the observations.
The list \Texinfocommandstyletextvar{x-variable} must contain only one variable;
\Texinfocommandstyletextvar{y-spec} is as in \Texinfocommandstyletextvar{logreg}.
The response variable in \Texinfocommandstyletextvar{y-spec} and the variable in \Texinfocommandstyletextvar{x-variable}
may be followed by axis labels enclosed in `\texttt{`}'.
\Texinfocommandstyletextvar{dataset} must be partitioned by \Texinfocommandstyletextvar{partvars} into exactly \Texinfocommandstyletextvar{nparts} parts.
\Texinfocommandstyletextvar{style} may contain axis specifications as for `\texttt{pict\_autoaxes}'
(see \hyperref[anchor:Axes]{Section~\ref*{anchor:Axes} [Axes], page~\pageref*{anchor:Axes}}).
NOTE: This function creates the following datasets or overwrites them if
they exist: \Texinfocommandstyletextvar{dataset}.trl, \Texinfocommandstyletextvar{dataset}.trl.grp,
\Texinfocommandstyletextvar{dataset}.trl.grp.srt, \Texinfocommandstyletextvar{dataset}.trl.grp.srt.mns, \Texinfocommandstyletextvar{dataset}.mns,
\Texinfocommandstyletextvar{dataset}.lgr, and \Texinfocommandstyletextvar{dataset}.lgr.srt.

\noindent{}\textbf{Code fragment(s)}

\emph{Display on one page the mean success rate for each
of 5 consecutive groups of the data, ordered by `\texttt{lab}',
and the logistic regression line,
and the curves defining a 95\% confidence region for the predicted
fraction of success:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(plotlogreg("can",\ "rem`Remissions` / 1",\ "lab`Labeling index`",
\                 "==",\ 5,\ "",\ 1,\ 0.95),\ 4,\ 4);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Display on one page the mean fraction of `\texttt{rem}' per
`\texttt{case}' for each
of 5 consecutive groups of the data, ordered by `\texttt{lab}',
and the logistic regression line,
and the curves defining a 95\% confidence region for the predicted
fraction of `\texttt{rem}' per `\texttt{case}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(plotlogreg("can",\ "rem/case",\ "lab",\ "==",\ 5,\ "",\ 1,\ 0.95),
\      4,\ 4);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{For each of the 3 values of the variable `\texttt{hosp}',
display on a separate page the mean fraction of `\texttt{rem}' per
`\texttt{case}' for each
of 5 consecutive groups of the data, ordered by `\texttt{lab}',
and the logistic regression line,
and the curves defining a 95\% confidence region for the predicted
fraction of `\texttt{rem}' per `\texttt{case}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(plotlogreg("can",\ "rem/case",\ "lab",\ "==",\ 5,\ "hosp",\ 3,\ 0.95),
\      12,\ 4);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Displaying the pictures}}
\label{anchor:Displaying-the-pictures}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{nport(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{nplots}, \Texinfocommandstyletextvar{nperpage})}
\textbf{nland(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{nplots}, \Texinfocommandstyletextvar{nperpage})}
\Texinfocommandstyletextvar{p:} array of `\texttt{pict}'
\Texinfocommandstyletextvar{nplots}, \Texinfocommandstyletextvar{nperpage:} int
\end{Texinfopreformatted}
\end{Texinfoindented}

\index[in]{nport@nport}%
\index[in]{nland@nland}%

\noindent{}\textbf{Description}

Generates an \Texinfocommandstyletextvar{nplots} / \Texinfocommandstyletextvar{nperpage} page graphics output file,
in portrait or landscape orientation, from the `\texttt{pict}' array pointed to by
\Texinfocommandstyletextvar{p} with a total of \Texinfocommandstyletextvar{nplots} plots, \Texinfocommandstyletextvar{nperpage} per page.
As shown above, the first argument of a call to `\texttt{nport}' or
`\texttt{nland}' is usually provided directly by the value returned
from a call to a graphics function such as `\texttt{plotlogreg}'.

\noindent{}\textbf{Code fragment(s)}

\emph{Display the 8 `\texttt{pict}'s of the array `\texttt{p}' on
4 pages in portrait orientation, with 2 `\texttt{pict}'s per page:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict *p;

...
nport(p,\ 8,\ 2);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Display `\texttt{pict}'s from `\texttt{plotlogreg}' in portrait orientation:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(plotlogreg("can",\ "nrem/ncase",\ "lab",\ "==",\ 5,\ "",\ 1,\ 0.95),
\      4,\ 4);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Display `\texttt{pict}'s from `\texttt{plotlogreg}' in landscape orientation:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nland(plotlogreg("can",\ "nrem/ncase",\ "lab",\ "==",\ 5,\ "",\ 1,\ 0.95),
\      4,\ 4);
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{portrait@portrait}%
\index[in]{landscape@landscape}%
\index[in]{graphics@graphics}%
\index[in]{output, graphics@output, graphics}%
\index[in]{display@display}%

\chapter{{Utilities: probability and miscellaneous functions}}
\label{anchor:Utilities}%


\section{{Chi-squared distribution}}
\label{anchor:Chi_002dsquared-distribution}%
\index[in]{chi-squared@chi-squared}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{probchisq(\Texinfocommandstyletextvar{c}, \Texinfocommandstyletextvar{df})}
\Texinfocommandstyletextvar{c:} double
\Texinfocommandstyletextvar{df:} int
\Texinfocommandstyletextvar{Returns:} double
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

Returns the probability that a variable distributed as chi-squared with
\Texinfocommandstyletextvar{df} degrees of freedom has a value greater than \Texinfocommandstyletextvar{c}.

\noindent{}\textbf{Code fragment(s)}

\emph{Assign to `\texttt{p}' the probability that a Chi-squared variable with 2
degrees of freedom will have a value exceeding 3.7:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double p;
p = probchisq(3.7,\ 2);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{chisqpoint(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{df})}
\Texinfocommandstyletextvar{p:} double
\Texinfocommandstyletextvar{df:} int
\Texinfocommandstyletextvar{Returns:} double
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

Returns the value that a variable that is distributed as chi-squared with
\Texinfocommandstyletextvar{df} degrees of freedom exceeds with probability \Texinfocommandstyletextvar{p}.

\noindent{}\textbf{Code fragment(s)}

\emph{Assign to `\texttt{c}' the point that
a Chi-squared variable with 3 degrees of freedom
exceeds with probability 0.05:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double c;
c = chisqpoint(0.05,\ 3);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{F distribution}}
\label{anchor:F-distribution}%
\index[in]{F distribution@F distribution}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{probf(\Texinfocommandstyletextvar{f}, \Texinfocommandstyletextvar{numer-df}, \Texinfocommandstyletextvar{denom-df})}
\Texinfocommandstyletextvar{f:} double
\Texinfocommandstyletextvar{numer-df}, \Texinfocommandstyletextvar{denom-df:} int
\Texinfocommandstyletextvar{Returns:} double
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

Returns the probability that a variable distributed as F with
\Texinfocommandstyletextvar{numer-df} and \Texinfocommandstyletextvar{denom-df} degrees of freedom has a value greater than \Texinfocommandstyletextvar{f}.

\noindent{}\textbf{Code fragment(s)}

\emph{Assign to `\texttt{p}' the probability that an F variable with 4 and 2
degrees of freedom will have a value exceeding 5.8:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double p;
p = prob(5.8,\ 4,\ 2);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{fpoint(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{numer-df}, \Texinfocommandstyletextvar{denom-df})}
\Texinfocommandstyletextvar{p:} double
\Texinfocommandstyletextvar{numer-df}, \Texinfocommandstyletextvar{denom-df:} int
\Texinfocommandstyletextvar{Returns:} double
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

Returns the value that a variable that is distributed as F with
\Texinfocommandstyletextvar{numer-df} and \Texinfocommandstyletextvar{denom-df} degrees of freedom exceeds with probability \Texinfocommandstyletextvar{p}.

\noindent{}\textbf{Code fragment(s)}

\emph{Assign to `\texttt{f}' the point
that an F variable with 4 and 2 degrees of freedom
exceeds with probability 0.05:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double f;
f = fpoint(0.05,\ 4,\ 2);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Normal distribution}}
\label{anchor:Normal-distribution}%
\index[in]{normal@normal}%
\index[in]{random@random}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{varnorm()}
\Texinfocommandstyletextvar{Returns:} double
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

Repeated calls return values (pseudo) independently
sampled from a standard normal distribution.

\noindent{}\textbf{Code fragment(s)}

\emph{Assign to `\texttt{z}' a value sampled from a standard normal distribution:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double z;
z = varnorm();
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{probz(\Texinfocommandstyletextvar{z})}
\Texinfocommandstyletextvar{z:} double
\Texinfocommandstyletextvar{Returns:} double
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

Returns the probability that a standard normal variable
has a value no greater than \Texinfocommandstyletextvar{z}.

\noindent{}\textbf{Code fragment(s)}

\emph{Assign to `\texttt{p}' the probability that a standard normal variable
will have a value not exceeding 1.645:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double p;
p = probz(1.645);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{zpoint(\Texinfocommandstyletextvar{p})}
\Texinfocommandstyletextvar{p:} double
\Texinfocommandstyletextvar{Returns:} double
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

Returns the value that a standard normal variable
exceeds with probability \Texinfocommandstyletextvar{p}.

\noindent{}\textbf{Code fragment(s)}

\emph{Assign to `\texttt{z}' the
that a standard normal variable
exceeds with probability 0.05:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double z;
z = zpoint(0.05);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{t distribution}}
\label{anchor:t-distribution}%
\index[in]{t distribution@t distribution}%
\index[in]{Student's t@Student's t}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{probt(\Texinfocommandstyletextvar{t}, \Texinfocommandstyletextvar{df})}
\Texinfocommandstyletextvar{t:} double
\Texinfocommandstyletextvar{df:} int
\Texinfocommandstyletextvar{Returns:} double
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

Returns the probability that a variable distributed as Student's t with
\Texinfocommandstyletextvar{df} degrees of freedom has a value greater than \Texinfocommandstyletextvar{t}.

\noindent{}\textbf{Code fragment(s)}

\emph{Assign to `\texttt{p}' the probability that a t variable with 3
degrees of freedom will have a value exceeding 2.3:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double p;
p = probt(2.3,\ 3);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{tpoint(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{df})}
\Texinfocommandstyletextvar{p:} double
\Texinfocommandstyletextvar{df:} int
\Texinfocommandstyletextvar{Returns:} double
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

Returns the value that a variable that is distributed as Student's t with
\Texinfocommandstyletextvar{df} degrees of freedom exceeds with probability \Texinfocommandstyletextvar{p}.

\noindent{}\textbf{Code fragment(s)}

\emph{Assign to `\texttt{t}' the point
that a t variable with 4 degrees of freedom
exceeds with probability 0.05:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double t;
t = tpoint(0.05,\ 4);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Uniform distribution}}
\label{anchor:Uniform-distribution}%
\index[in]{uniform distribution@uniform distribution}%
\index[in]{random@random}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{varunif()}
\Texinfocommandstyletextvar{Returns:} double
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

Repeated calls return values (pseudo) independently
sampled from a uniform [0, 1] distribution.

\noindent{}\textbf{Code fragment(s)}

\emph{Assign to `\texttt{u}' a value sampled from a uniform [0, 1] distribution:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double u;
u = varunif();
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Miscellaneous functions}}
\label{anchor:Miscellaneous-functions}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dap\_bincoeff(\Texinfocommandstyletextvar{n}, \Texinfocommandstyletextvar{r})}
\Texinfocommandstyletextvar{n}, \Texinfocommandstyletextvar{r:} double
\Texinfocommandstyletextvar{Returns:} double
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{binomial coefficient@binomial coefficient}%
\index[in]{combinations@combinations}%
\index[in]{choose@choose}%

\noindent{}\textbf{Description}

Returns the binomial coefficient n C r.

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dap\_maximize(\Texinfocommandstyletextvar{f}, \Texinfocommandstyletextvar{nx}, \Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{step}, \Texinfocommandstyletextvar{tol}, \Texinfocommandstyletextvar{trace})}
\Texinfocommandstyletextvar{f:} pointer to function returning double
\Texinfocommandstyletextvar{nx:} int
\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{step}, \Texinfocommandstyletextvar{tol:} double
\Texinfocommandstyletextvar{trace:} string
\Texinfocommandstyletextvar{Returns:} double
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{minimize@minimize}%
\index[in]{maximize@maximize}%
\index[in]{extreme value@extreme value}%

\noindent{}\textbf{Description}

Maximizes (or attempts to maximize) the function \Texinfocommandstyletextvar{f}
of \Texinfocommandstyletextvar{nx} variables, starting with the input point \Texinfocommandstyletextvar{x}.
The function
`\texttt{dap\_maximize}' uses a simple hill-climbing algorithm, with
numerically approximated partial derivatives, starting with step-size
\Texinfocommandstyletextvar{step} and halving the step-size as necessary until it is less than
\Texinfocommandstyletextvar{tol}.
The string \Texinfocommandstyletextvar{trace} is either the null string (not `\texttt{NULL}') for no tracing,
or `\texttt{TRACE}', for continuous tracing, or
`\texttt{PAUSE}', for tracing and waiting for the user to press \texttt{Enter}
at each iteration.
Either `\texttt{TRACE}' or `\texttt{PAUSE}' may be followed, with no spaces, by a number
to specify how many steps should be taken before each trace or pause.
If convergence is not obtained in `\texttt{DAP\_MAXITER}'
steps \hyperref[anchor:Appendix-I]{\chaptername~\ref*{anchor:Appendix-I} [Appendix I], page~\pageref*{anchor:Appendix-I}}, that failure is
reported before returning.

\noindent{}\textbf{Code fragment(s)}

\emph{Assign to `\texttt{max}' the maximum value attained by the function
of 2 variables `\texttt{fun}', starting with the values stored in `\texttt{x}',
with a step size of 0.01 and a tolerance in the independent variables
of 0.001:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double fun(double x[2]);
double max;
double x[2];

max = dap\_maximize(\&fun,\ 2,\ x,\ 0.01,\ 0.001,\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Assign to `\texttt{max}' the maximum value attained by the function
of 2 variables `\texttt{fun}', starting with the values stored in `\texttt{x}',
with a step size of 0.01 and a tolerance in the independent variables
of 0.001 and display a trace of the iterations:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double fun(double x[2]);
double max;
double x[2];

max = dap\_maximize(\&fun,\ 2,\ x,\ 0.01,\ 0.001,\ "TRACE");
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dap\_numdate(\Texinfocommandstyletextvar{date})}
\Texinfocommandstyletextvar{date:} string
\Texinfocommandstyletextvar{Returns:} int
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{date@date}%

\noindent{}\textbf{Description}

With \Texinfocommandstyletextvar{date} a date on or after January 1, 1752,
in the form `\texttt{MMDDYYYY}' or `\texttt{MM/DD/YYYY}',
in which the `\texttt{MM}' and the `\texttt{DD}' in the latter form can consist
of a single digit,
returns the number of days since December 31, 1751, otherwise
returns -1.

\noindent{}\textbf{Code fragment(s)}

\emph{Assign to `\texttt{d}' the number 72143,
i.e., the number of days that
July 9, 1949 is later than December 31, 1751:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily int d;
d = dap\_numdate("07091949");
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dap\_datenum(\Texinfocommandstyletextvar{n}, \Texinfocommandstyletextvar{date})}
\Texinfocommandstyletextvar{n:} int
\Texinfocommandstyletextvar{date:} string
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{date@date}%

\noindent{}\textbf{Description}

With \Texinfocommandstyletextvar{n} the number of days since December 31, 1751,
fills \Texinfocommandstyletextvar{date} with the date in the form `\texttt{MMDDYYYY}'.
If \Texinfocommandstyletextvar{n} is not positive or is too large, \Texinfocommandstyletextvar{date} is
set to "?".

\noindent{}\textbf{Code fragment(s)}

\emph{Assign to `\texttt{date}' the string "07021761",
i.e., the date 3471 days after December 31, 1751:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily char date[9];
dap\_datenum(3471,\ date);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{dap\_invert(\Texinfocommandstyletextvar{matrix}, \Texinfocommandstyletextvar{rowscols})}
\Texinfocommandstyletextvar{matrix:} pointer to pointer to double
\Texinfocommandstyletextvar{rowscols:} int
\Texinfocommandstyletextvar{Returns:} int
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{matrix@matrix}%
\index[in]{invert@invert}%

\noindent{}\textbf{Description}

Inverts the matrix, returns 1 if non-singular, 0 otherwise.
The parameter \Texinfocommandstyletextvar{matrix} is an array of pointers to double, each double pointed
to being the first element of an array of double.

\noindent{}\textbf{Code fragment(s)}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double **mat;
int nonsing;
nonsing = dap\_invert(mat,\ 3);
\end{Texinfopreformatted}
\end{Texinfoindented}

\chapter{{Picture functions}}
\label{anchor:Picture-functions}%

The most common use of the information in this chapter is to modify one or more
fields in the `\texttt{pict}' structure, which is described in the first section
of this chapter, returned by a dap graphics function.
In addition, this chapter describes low-level picture functions.
Although these picture functions are not needed in most dap programs,
they are useful for constructing custom graphics.
The functions that add elements, shapes, or text to a picture must be followed
by a call to `\texttt{pict\_show}' to include those objects in the graphics output file.
Complex pictures with, for example, different fonts
for different pieces of text or different sized circles, may be constructed
in one of two ways: either link the parts of the picture
and call `\texttt{pict\_show}' once, on the head of the list, or call
`\texttt{pict\_show}' repeatedly, after assembling each of the parts of
the picture.


\section{{Pict structure and pict\_init}}
\label{anchor:Pict-structure}%

Dap graphics functions return arrays of `\texttt{pict}'.
\index[in]{pict structure@pict structure}%
\index[in]{structure, pict@structure, pict}%
The `\texttt{pict}' structure
contains the following fields that may be modified directly to change a picture.
Numerical values are in points (1/72 inch).

\noindent{}\textbf{pict\_type:} string (4 letters)
\index[in]{type, picture@type, picture}%
\index[in]{picture@picture}%

This field must be one of the following strings:

\textbf{LINE}
\begin{quote}
Draw lines connecting successive points.
\end{quote}
\index[in]{line graph@line graph}%

\textbf{SEGM}
\begin{quote}
Draw a separate segment for each successive pair of points.
\end{quote}
\index[in]{segments@segments}%
\index[in]{line segments@line segments}%

\textbf{IBEA}
\begin{quote}
Draw an I-beam for each successive pair of points.
If the horizontal coordinates of the pair of points are equal,
draw a vertical I-beam; if the vertical coordinates of the pair of points are equal,
draw a horizontal I-beam; otherwise, report the error and exit.
\end{quote}
\index[in]{I-beam@I-beam}%

\textbf{CIRC}
\begin{quote}
Draw each point as a circle.
\end{quote}
\index[in]{scatter plot@scatter plot}%
\index[in]{points@points}%

\textbf{SQUA}
\begin{quote}
Draw each point as a square.
\end{quote}
\index[in]{squares@squares}%

\textbf{TRIA}
\begin{quote}
Draw each point as a triangle.
\end{quote}
\index[in]{triangles@triangles}%

\textbf{UTRI}
\begin{quote}
Draw each point as a upside-down triangle.
\end{quote}
\index[in]{triangles@triangles}%

\textbf{DIAM}
\begin{quote}
Draw each point as a diamond.
\end{quote}
\index[in]{diamonds@diamonds}%

\textbf{PATT}
\begin{quote}
At the position of each point, display the pattern pointed to by \Texinfocommandstyletextvar{pict\_patt}.
\end{quote}
\index[in]{patterns@patterns}%

\noindent{}\textbf{pict\_dash:} double

The dash
\index[in]{dashing@dashing}%
\index[in]{broken lines@broken lines}%
length for lines if \Texinfocommandstyletextvar{pict\_dash} > 0.0;
the lines are not dashed if \Texinfocommandstyletextvar{pict\_dash} = 0.0.
The default is 0.0.

\noindent{}\textbf{pict\_font:} string (up to 63 letters)

A string specifying the font
\index[in]{font@font}%
for displayed text, if any.
The default is `\texttt{Helvetica-Bold}'.

\noindent{}\textbf{pict\_fs:} double

The font size
\index[in]{font size@font size}%
\index[in]{size, font@size, font}%
for displayed text, if any.
The default is 12.0.

\noindent{}\textbf{pict\_lw:} double

The width for lines.
\index[in]{line width@line width}%
\index[in]{thickness, lines@thickness, lines}%
\index[in]{width, lines@width, lines}%
The default is 0.4.

\noindent{}\textbf{pict\_r:} double
\index[in]{radius@radius}%
\index[in]{size@size}%

The radius for circles and size for squares, triangles, upside-down triangles, and
diamonds.

\noindent{}\textbf{pict\_lgray:} double

The gray level
\index[in]{gray level@gray level}%
\index[in]{darkness@darkness}%
\index[in]{line, darkness@line, darkness}%
for lines: 0.0 is completely black, 1.0 is completely white.
The default is 0.0.

\noindent{}\textbf{pict\_fgray:} double
\index[in]{gray level@gray level}%
\index[in]{darkness@darkness}%
\index[in]{fill, darkness@fill, darkness}%
\index[in]{solid areas, darkness@solid areas, darkness}%

The gray level for fill:  if \Texinfocommandstyletextvar{pict\_fgray} $<$ 0.0, then don't fill areas;
if \Texinfocommandstyletextvar{pict\_fgray} $\ge$ 0.0, then fill areas, then draw the boundary lines.
The default is $-1.0$.

\noindent{}\textbf{pict\_patt:} pointer to `\texttt{pict}'
\index[in]{pattern@pattern}%

This field allows you to place a picture at each point: set
\Texinfocommandstyletextvar{pict\_patt} to the address of the `\texttt{pict}' to be displayed.

\noindent{}\textbf{pict\_next:} pointer to `\texttt{pict}'
\index[in]{pattern@pattern}%

This field allows you to link pictures to be displayed on the same page.

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_initpict(\Texinfocommandstyletextvar{prev}, \Texinfocommandstyletextvar{p})}
\Texinfocommandstyletextvar{prev}, \Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{pict, initialize@pict, initialize}%
\index[in]{pict, link@pict, link}%
\index[in]{initialize@initialize}%
\index[in]{link@link}%

\noindent{}\textbf{Description}

Initialize the `\texttt{pict}' pointed to by \Texinfocommandstyletextvar{p},
linking the `\texttt{pict}' pointed to by \Texinfocommandstyletextvar{prev} to it.
If \Texinfocommandstyletextvar{prev} is `\texttt{NULL}', then no `\texttt{pict}' is linked to
\Texinfocommandstyletextvar{p}.

\noindent{}\textbf{Code fragment(s)}

\emph{Initialize the picture structures `\texttt{p[0]}'
and `\texttt{p[1]}' and link `\texttt{p[0]}' to `\texttt{p[1]}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p[2];

pict\_initpict(NULL,\ p);
pict\_initpict(p,\ p + 1);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_clearpict(\Texinfocommandstyletextvar{p})}
\Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{pict, clear@pict, clear}%

\noindent{}\textbf{Description}

Frees up internal memory space used by \Texinfocommandstyletextvar{p}: use
before calling `\texttt{pict\_initpict}' on \Texinfocommandstyletextvar{p} after
it has been used.
Does not free \Texinfocommandstyletextvar{p} itself.

\noindent{}\textbf{Code fragment(s)}

\emph{Free the internal memory space used by `\texttt{p}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p;

pict\_clearpict(\&p);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Axes}}
\label{anchor:Axes}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_axes(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{minx}, \Texinfocommandstyletextvar{maxx}, \Texinfocommandstyletextvar{xticks}, \Texinfocommandstyletextvar{nxticks}, \Texinfocommandstyletextvar{miny}, \Texinfocommandstyletextvar{maxy}, \Texinfocommandstyletextvar{yticks}, \Texinfocommandstyletextvar{nyticks}, \Texinfocommandstyletextvar{axspec}, \Texinfocommandstyletextvar{bpos}, \Texinfocommandstyletextvar{lpos}, \Texinfocommandstyletextvar{tpos}, \Texinfocommandstyletextvar{rpos})}
\Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\Texinfocommandstyletextvar{xticks}, \Texinfocommandstyletextvar{yticks:} array of `\texttt{tick}'
\Texinfocommandstyletextvar{nxticks}, \Texinfocommandstyletextvar{nyticks:} int
\Texinfocommandstyletextvar{axspec:} string
\Texinfocommandstyletextvar{bpos}, \Texinfocommandstyletextvar{lpos}, \Texinfocommandstyletextvar{tpos}, \Texinfocommandstyletextvar{rpos:} double
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{axes@axes}%
\index[in]{ticks@ticks}%

\noindent{}\textbf{Description}

Create axes in the `\texttt{pict}' pointed to by \Texinfocommandstyletextvar{p}
with ticks along the x-axis specified by the array \Texinfocommandstyletextvar{xtick} of
\Texinfocommandstyletextvar{nxticks} `\texttt{tick}'s
and ticks along the y-axis specified by the array \Texinfocommandstyletextvar{yticks} of
\Texinfocommandstyletextvar{nyticks} `\texttt{tick}'s.
The ticks must be in order.
The last tick is used to label the axis and the numbers of ticks,
\Texinfocommandstyletextvar{nxticks} and \Texinfocommandstyletextvar{nyticks} do not include this last tick.
The string \Texinfocommandstyletextvar{axspec} is as for \Texinfocommandstyletextvar{pict\_autoaxes}.
The doubles \Texinfocommandstyletextvar{bpos}, \Texinfocommandstyletextvar{lpos}, \Texinfocommandstyletextvar{tpos}, and \Texinfocommandstyletextvar{rpos}
are the positions of the bottom or only x-axis, the left or only y-axis,
the top x-axis (if any), and the right y-axis (if any).
The variables \Texinfocommandstyletextvar{minx}, \Texinfocommandstyletextvar{maxx}, \Texinfocommandstyletextvar{miny}, and \Texinfocommandstyletextvar{maxy}
give the endpoints of the axes.

\noindent{}\textbf{Code fragment(s)}

\emph{Creat axes in `\texttt{p}' with 11 ticks on each of the
x- and y-axes as a box whose lower and upper edges are at
0.0 and 100.0, respectively, and whose left and right edges are at
-10.0 and 10.0, respectively, with ticks and numbers on all sides:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p;
tick xt[12],\ yt[12];

pict\_axes(\&p,\ xt,\ 12,\ yt,\ 12,\ "BB",\ 0.0,\ 100.0,\ -10.0,\ 10.0);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_autoaxes(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{xlabel}, \Texinfocommandstyletextvar{ylabel}, \Texinfocommandstyletextvar{axspec}, \Texinfocommandstyletextvar{xfunct}, \Texinfocommandstyletextvar{yfunct}, \Texinfocommandstyletextvar{caption}, \Texinfocommandstyletextvar{autopos})}
\Texinfocommandstyletextvar{p:} array of `\texttt{pict}'
\Texinfocommandstyletextvar{xlabel}, \Texinfocommandstyletextvar{ylabel}, \Texinfocommandstyletextvar{axspec}, \Texinfocommandstyletextvar{caption:} string
\Texinfocommandstyletextvar{xfunct}, \Texinfocommandstyletextvar{yfunct:} pointer to function returning double
\Texinfocommandstyletextvar{autopos:} int
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{axes@axes}%
\index[in]{ticks@ticks}%
\index[in]{caption@caption}%
\index[in]{title@title}%
\index[in]{autoaxes@autoaxes}%

\noindent{}\textbf{Description}

Create axes, as specified below, by
\Texinfocommandstyletextvar{axspec} for the linked list of `\texttt{pict}'s whose head
is pointed to by \Texinfocommandstyletextvar{p} and whose tail is the `\texttt{pict}' to contain the axes.
Unless otherwise specified,
the axes extend to the maximum and minimum values of
x and y in the entire linked list of `\texttt{pict}'s (except the tail `\texttt{pict}'),
but always include the origin.
Unless otherwise specified,
the function \Texinfocommandstyletextvar{pict\_autoaxes} chooses an appropriate spacing for the ticks on both axes.
The x- and y-axes are labeled \Texinfocommandstyletextvar{xlabel} and \Texinfocommandstyletextvar{ylabel},
respectively, and the entire picture is captioned by \Texinfocommandstyletextvar{caption}.
The first part of the
string \Texinfocommandstyletextvar{axspec} consists of 0, 1, or 2 characters according to whether the default
is used for both axes, just the y-axis, or the axes are specified
as follows, respectively.
An axis specification is one of the characters
`\texttt{-}', `\texttt{+}', `\texttt{0}', `\texttt{n}', `\texttt{=}',  or `\texttt{\#}',
which indicate that the axis should be placed: on the negative end of the other
axis; the positive end; at 0; not at all; or at both ends,
without or with markings on the positive end.
The default is `\texttt{0}'.
The endpoints of the graph and the number of ticks in each direction may be specified
in \Texinfocommandstyletextvar{axspec} after the first part of the string
(and at least one space) as follows:
to set the minimum point on the x-axis to a number, say `\texttt{-3.6}', use
`\texttt{MINX-3.6}' (no spaces). The maximum point on the x-axis and the minimum
and maximum points on the y-axis can be specified using `\texttt{MAXX}',
`\texttt{MINY}', and `\texttt{MAXY}' in the same way. To set the number of tick marks
on the x-axis to a number, say 14, use `\texttt{NXTICKS14}' (no spaces).
The number of ticks on the y-axis can be set using `\texttt{NYTICKS}' in the
same way.
The number of significant figures used for the labels on the ticks can
be specified using `\texttt{NXDIGITS}' and `\texttt{NYDIGITS}', as in
`\texttt{NXDIGITS4}'; the default is 3 digits.

The functions \Texinfocommandstyletextvar{xfunct} and \Texinfocommandstyletextvar{yfunct}
are applied to the true tick values to create the tick labels.
Either one or both may be `\texttt{NULL}' to specify that the tick labels equal the tick values.
If \Texinfocommandstyletextvar{autopos} is `\texttt{PORTRAIT}' or `\texttt{LANDSCAPE}' (integer
values, not strings, defined in the header file), then
\Texinfocommandstyletextvar{apict\_utoaxes} automatically scales and positions the plot appropriately.
No scaling and positioning is done if
\Texinfocommandstyletextvar{autopos} is 0.

\noindent{}\textbf{Code fragment(s)}

\emph{Create axes in the last `\texttt{pict}' in the linked array
given by `\texttt{p}' with the horizontal axis labeled "time",
the vertical axis labeled "CFU", the horizontal axis at the most
negative point the `\texttt{pict}'s of `\texttt{p}',
the vertical axis at `\texttt{time}' = 0, the function
`\texttt{exp}' used to display numerical tick values on the vertical axis,
the caption "CFU per cm\^{}2\^{} surface area" (with the `\texttt{2}' as a
superscript), scaled and placed appropriately on a page in portrait orientation:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict *p;

pict\_autoaxes(p,\ "time",\ "CFU",\ "-0",\ NULL,\ \&exp,
\                            "CFU per cm\^{}2\^{} surface area",\ PORTRAIT);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_maketick(\Texinfocommandstyletextvar{thetick}, \Texinfocommandstyletextvar{position}, \Texinfocommandstyletextvar{label}, \Texinfocommandstyletextvar{length})}
\Texinfocommandstyletextvar{tick:} pointer to `\texttt{tick}'
\Texinfocommandstyletextvar{position}, \Texinfocommandstyletextvar{length:} double
\Texinfocommandstyletextvar{label:} string
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{tick@tick}%
\index[in]{axes@axes}%

\noindent{}\textbf{Description}

Make the `\texttt{tick}' pointed to by \Texinfocommandstyletextvar{thetick} be at coordinate \Texinfocommandstyletextvar{position}
with label \Texinfocommandstyletextvar{label} and of length \Texinfocommandstyletextvar{length}.

\noindent{}\textbf{Code fragment(s)}

\emph{Create in `\texttt{t}' a tick with position 5.0, label "25.0", and length
3.0 points:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily tick t;

pict\_maketick(\&t,\ 5.0,\ "25.0",\ 3.0);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Elements}}
\label{anchor:Elements}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_point(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y})}
\Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y:} double
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

Add a point at (\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}) to the `\texttt{pict}' pointed to by \Texinfocommandstyletextvar{p}.
Points added to the same `\texttt{pict}' appear in the order in which they are added.

\noindent{}\textbf{Code fragment(s)}

\emph{Add a point at (7.2, -4.3) to `\texttt{p}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p;

pict\_point(\&p,\ 7.2,\ -4.3);
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{point@point}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_line(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{x1}, \Texinfocommandstyletextvar{y1}, \Texinfocommandstyletextvar{x2}, \Texinfocommandstyletextvar{y2})}
\Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\Texinfocommandstyletextvar{x1}, \Texinfocommandstyletextvar{y1}, \Texinfocommandstyletextvar{x2}, \Texinfocommandstyletextvar{y2:} double
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{line@line}%

\noindent{}\textbf{Description}

Add a line from (\Texinfocommandstyletextvar{x1}, \Texinfocommandstyletextvar{y1}) to (\Texinfocommandstyletextvar{x2}, \Texinfocommandstyletextvar{y2})
to the `\texttt{pict}' pointed to by \Texinfocommandstyletextvar{p}.
Lines added to the same `\texttt{pict}' appear in the order in which they are added.

\noindent{}\textbf{Code fragment(s)}

\emph{Add a line from (7.2, -4.3) to (9.1, 2.6) to `\texttt{p}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p;

pict\_line(\&p,\ 7.2,\ -4.3,\ 9.1,\ 2.6);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Shapes}}
\label{anchor:Shapes}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_circle(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}, \Texinfocommandstyletextvar{r})}
\Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}, \Texinfocommandstyletextvar{r:} double
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{circle@circle}%

\noindent{}\textbf{Description}

Make the `\texttt{pict}' pointed to by \Texinfocommandstyletextvar{p} a circle of radius
\Texinfocommandstyletextvar{r}, centered at (\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}).
NOTE: If a picture is to contain more than one circle,
then those circles must
be created in separate `\texttt{pict}'s that are linked together.

\noindent{}\textbf{Code fragment(s)}

\emph{Add a circle with center (7.2, -4.3) and radius 3.0 to `\texttt{p}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p;

pict\_circle(\&p,\ 7.2,\ -4.3,\ 3.0);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_rectangle(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}, \Texinfocommandstyletextvar{xside}, \Texinfocommandstyletextvar{yside})}
\Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}, \Texinfocommandstyletextvar{xside}, \Texinfocommandstyletextvar{yside:} double
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{rectangle@rectangle}%
\index[in]{square@square}%

\noindent{}\textbf{Description}

Add a rectangle whose lower left corner is a (\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y})
and has horizontal sides of length
\Texinfocommandstyletextvar{xside} and vertical sides of length \Texinfocommandstyletextvar{yside}
to the `\texttt{pict}' pointed to by \Texinfocommandstyletextvar{p}.
NOTE: If a picture is to contain more than one rectangle but those
rectangles are not to be connected, then those rectangles must
be created in separate `\texttt{pict}'s that are linked together.

\noindent{}\textbf{Code fragment(s)}

\emph{Add a rectangle with lower left corner (7.2, -4.3),
width 4.0, and height 4.5 to `\texttt{p}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p;

pict\_rectangle(\&p,\ 7.2,\ -4.3,\ 4.0,\ 4.5)
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_hrect(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{spacing}, \Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}, \Texinfocommandstyletextvar{xside}, \Texinfocommandstyletextvar{yside})}
\textbf{pict\_bhrect(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{spacing}, \Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}, \Texinfocommandstyletextvar{xside}, \Texinfocommandstyletextvar{yside})}
\Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\Texinfocommandstyletextvar{spacing}, \Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}, \Texinfocommandstyletextvar{xside}, \Texinfocommandstyletextvar{yside:} double
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{rectangle@rectangle}%
\index[in]{hash@hash}%

\noindent{}\textbf{Description}

Add a forward-hashed (respectively, backward-hashed) rectangle whose lower left corner is at
(\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}) and has horizontal sides of length
\Texinfocommandstyletextvar{xside} and vertical sides of length \Texinfocommandstyletextvar{yside}
to the `\texttt{pict}' pointed to by \Texinfocommandstyletextvar{p}.
The horizontal space between hash lines is \Texinfocommandstyletextvar{spacing}.
NOTE: If a picture is to contain more than one rectangle but those
rectangles are not to be connected, then those rectangles must
be created in separate `\texttt{pict}'s that are linked together.

\noindent{}\textbf{Code fragment(s)}

\emph{Add a rectangle with lower left corner (3.5, 29.0),
width 1.0, height 5.0, and with hashes sloping upwards at a
spacing of 2.0 points to `\texttt{p}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p;

pict\_hrect(\&p,\ 2.0,\ 3.5,\ 29.0,\ 1.0,\ 5.0);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Add a rectangle with lower left corner (3.5, 29.0),
width 1.0, height 5.0, and with hashes sloping downwards at a
spacing of 2.0 points to `\texttt{p}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p;

pict\_bhrect(\&p,\ 2.0,\ 3.5,\ 29.0,\ 1.0,\ 5.0);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_curve(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}, \Texinfocommandstyletextvar{t0}, \Texinfocommandstyletextvar{t1}, \Texinfocommandstyletextvar{nsegments})}
\Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y:} pointer to function returning double
\Texinfocommandstyletextvar{t0}, \Texinfocommandstyletextvar{t1:} double
\Texinfocommandstyletextvar{nsegments:} int
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{curve@curve}%
\index[in]{graph@graph}%

\noindent{}\textbf{Description}

Add a curve to the `\texttt{pict}' pointed to by \Texinfocommandstyletextvar{p}.
The curve is parameterized by \Texinfocommandstyletextvar{x} and \Texinfocommandstyletextvar{y},
which point to functions that take a single
argument of type double and return a result of type double.
If \Texinfocommandstyletextvar{x} is `\texttt{NULL}', then that function is taken to be the identity function.
The parameter varies from \Texinfocommandstyletextvar{t0} to \Texinfocommandstyletextvar{t1}
in \Texinfocommandstyletextvar{nsegments} steps.
Curves (and lines and points) added to the same `\texttt{pict}' are connected in
the order in which they are added.
NOTE: If a picture is to contain more than one curve but those
curves are not to be connected, then those curves must
be created in separate `\texttt{pict}'s that are linked together.

\noindent{}\textbf{Code fragment(s)}

\emph{Add to `\texttt{p}' a curve parameterized by
`\texttt{cos}' and `\texttt{sin}' with parameter running from
0.0 to 2.0 * 3.14159 in 100 steps:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p;

pict\_curve(\&p,\ \&cos,\ \&sin,\ 0.0,\ 2.0 * 3.14159,\ 100);
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Add to `\texttt{p}' a graph of `\texttt{exp}'
running from 0.0 to 3.0 in the horizontal direction in 100 steps:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p;

pict\_curve(\&p,\ NULL,\ \&exp,\ 0.0,\ 3.0,\ 100);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Text}}
\label{anchor:Text}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_text(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{text}, \Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}, \Texinfocommandstyletextvar{angle}, \Texinfocommandstyletextvar{pos})}
\Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\Texinfocommandstyletextvar{text}, \Texinfocommandstyletextvar{pos:} string
\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}, \Texinfocommandstyletextvar{angle:} double
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{text@text}%
\index[in]{words@words}%
\index[in]{font@font}%

\noindent{}\textbf{Description}

Add text \Texinfocommandstyletextvar{text} to the `\texttt{pict}' pointed to by \Texinfocommandstyletextvar{p}.
The string \Texinfocommandstyletextvar{text} may contain substrings enclosed between pairs of
`\texttt{\^{}}' for superscripts and between pairs of `\texttt{|}' for subscripts.
The string \Texinfocommandstyletextvar{text} may also contain newline characters (`\texttt{\textbackslash{}n}')
for multi-line text.
The string \Texinfocommandstyletextvar{pos} consists of either two or three letters that
specify the position of the point with coordinates
\Texinfocommandstyletextvar{x} and \Texinfocommandstyletextvar{y}
relative to the text, as follows.
The first character of \Texinfocommandstyletextvar{pos} is either `\texttt{l}', `\texttt{c}', or `\texttt{r}',
for left, center, or right, respectively, and the
second letter is either `\texttt{t}', `\texttt{m}', or `\texttt{b}',
for top, middle, or bottom, respectively.
If the optional third character of \Texinfocommandstyletextvar{pos}
is a space, then a blank rectangle is formed to hold the text.
The double \Texinfocommandstyletextvar{angle} is counter-clockwise rotation in degrees to be applied to text.

\noindent{}\textbf{Code fragment(s)}

\emph{Add to `\texttt{p}' the text "cm\^{}3\^{} of H|2|O" (with the
`\texttt{3}' as a superscript and the `\texttt{2}' as a subscript) placed
horizontally with its bottom center at the point
(306.0, 72.0):}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p;

pict\_text(\&p,\ "cm\^{}3\^{} of H|2|O",\ 306.0,\ 72.0,\ 0.0,\ "cb");
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Transformations}}
\label{anchor:Transformations}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_translate(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y})}
\Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y:} double
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{transform@transform}%
\index[in]{translate@translate}%
\index[in]{move@move}%
\index[in]{shift@shift}%
\index[in]{raise@raise}%
\index[in]{lower@lower}%

\noindent{}\textbf{Description}

Translate (i.e., shift)
the `\texttt{pict}' pointed to by \Texinfocommandstyletextvar{p} by \Texinfocommandstyletextvar{x} in the x-direction and
\Texinfocommandstyletextvar{y} in the y-direction.
If the `\texttt{pict}' is linked to another `\texttt{pict}', then that `\texttt{pict}' is translated the same
way, and so on until there are no more links.

\noindent{}\textbf{Code fragment(s)}

\emph{Translate all 4 pictures in the linked array
`\texttt{p}' 306.0 points to the right and 72.0 points up:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p[4];

pict\_translate(p,\ 306.0,\ 72.0);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_scale(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}, \Texinfocommandstyletextvar{sx}, \Texinfocommandstyletextvar{sy})}
\Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}, \Texinfocommandstyletextvar{sx}, \Texinfocommandstyletextvar{sy:} double
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{transform@transform}%
\index[in]{scale@scale}%
\index[in]{size@size}%
\index[in]{stretch@stretch}%
\index[in]{shrink@shrink}%
\index[in]{compress@compress}%
\index[in]{expand@expand}%

\noindent{}\textbf{Description}

Scale the `\texttt{pict}' pointed to by \Texinfocommandstyletextvar{p} by \Texinfocommandstyletextvar{sx} in the x-direction and
\Texinfocommandstyletextvar{sy} in the y-direction, leaving the point at
(\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}) fixed.
If the `\texttt{pict}' is linked to another `\texttt{pict}', then that `\texttt{pict}' is scaled the same
way, and so on until there are no more links.

\noindent{}\textbf{Code fragment(s)}

\emph{Scale all 4 pictures in the linked array
`\texttt{p}' by 1.5 in the horizontal direction
and 2.0 in the vertical direction,
relative to the fixed point (306.0, 72.0):}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p[4];

pict\_scale(p,\ 306.0,\ 72.0,\ 1.5,\ 2.0);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_rotate(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}, \Texinfocommandstyletextvar{degrees})}
\Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}, \Texinfocommandstyletextvar{degrees:} double
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{transform@transform}%
\index[in]{rotate@rotate}%
\index[in]{turn@turn}%

\noindent{}\textbf{Description}

Rotate the `\texttt{pict}' pointed to by \Texinfocommandstyletextvar{p} counter-clockwise by
\Texinfocommandstyletextvar{degrees} around the point at (\Texinfocommandstyletextvar{x}, \Texinfocommandstyletextvar{y}).
If the `\texttt{pict}' is linked to another `\texttt{pict}', then that `\texttt{pict}' is rotated the same
way, and so on until there are no more links.

\noindent{}\textbf{Code fragment(s)}

\emph{Rotate all 4 pictures in the linked array
`\texttt{p}' by 45.0 degrees counterclockwise
around the fixed point (306.0, 400.0):}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p[4];

pict\_rotate(p,\ 306.0,\ 400.0,\ 45.0);
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Graphics output file}}
\label{anchor:Graphics-output-file}%

A graphics output file must be started with a call to `\texttt{pict\_init}'
(or a function, such as `\texttt{pict\_port}', that calls `\texttt{pict\_init}')
and ended with a call to `\texttt{pict\_end}'.

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_port(\Texinfocommandstyletextvar{npages})}
\textbf{pict\_land(\Texinfocommandstyletextvar{npages})}
\Texinfocommandstyletextvar{npages:} int
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{portrait@portrait}%
\index[in]{landscape@landscape}%
\index[in]{picture@picture}%
\index[in]{orientation@orientation}%
\index[in]{graphics@graphics}%
\index[in]{output, graphics@output, graphics}%

\noindent{}\textbf{Description}

Calls `\texttt{pict\_init}' to set up \Texinfocommandstyletextvar{npages} portrait or landscape pages.

\noindent{}\textbf{Code fragment(s)}

\emph{Initialize a graphics output file for 3 pages in landscape orientation:}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict\_land(3);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_init(\Texinfocommandstyletextvar{orient}, \Texinfocommandstyletextvar{bboxxl}, \Texinfocommandstyletextvar{bboxyb}, \Texinfocommandstyletextvar{bboxxr}, \Texinfocommandstyletextvar{bboxyt}, \Texinfocommandstyletextvar{npages})}
\Texinfocommandstyletextvar{orient}, \Texinfocommandstyletextvar{bboxxl}, \Texinfocommandstyletextvar{bboxyb}, \Texinfocommandstyletextvar{bboxxr}, \Texinfocommandstyletextvar{bboxyt}, \Texinfocommandstyletextvar{npages:} int
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{portrait@portrait}%
\index[in]{landscape@landscape}%
\index[in]{picture@picture}%
\index[in]{orientation@orientation}%
\index[in]{graphics@graphics}%
\index[in]{output, graphics@output, graphics}%

\noindent{}\textbf{Description}

Initialize the graphics output file.
The character (not string)
\Texinfocommandstyletextvar{orient} is either `\texttt{l}', for landscape or `\texttt{p}' for portrait.
The bounding box is specified by the \Texinfocommandstyletextvar{bbox}
parameters and the number of pages by \Texinfocommandstyletextvar{npages}.
`\texttt{pict\_init}' is called by `\texttt{pict\_portrait}' and `\texttt{pict\_landscape}'.

\noindent{}\textbf{Code fragment(s)}

\emph{Initialize a graphics output file for 4 pages in portrait orientation with
a bounding box with lower left corner (0, 0) and upper right corner
(612, 792):}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict\_init(`\texttt{p}',\ 0,\ 0,\ 612,\ 792,\ 4);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_page()}
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{page@page}%

\noindent{}\textbf{Description}

Begin new page.

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_show(\Texinfocommandstyletextvar{p})}
\Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\end{Texinfopreformatted}
\end{Texinfoindented}
\index[in]{show@show}%
\index[in]{display@display}%
\index[in]{picture@picture}%

\noindent{}\textbf{Description}

Write the picture commands to display the `\texttt{pict}' pointed to by
\Texinfocommandstyletextvar{p} into the graphics output file.
If \Texinfocommandstyletextvar{p}
is linked to another `\texttt{pict}', then show writes out the commands for that
pict and so on until there are no more links.

\noindent{}\textbf{Code fragment(s)}

\emph{Display the 4 `\texttt{pict}'s in the linked array `\texttt{p}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p[4];

pict\_show(p);
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_end()}
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}\index[in]{output, graphics@output, graphics}%
\index[in]{graphics@graphics}%

\noindent{}\textbf{Description}

Terminate the graphics output file.

\section{{Picture datasets}}
\label{anchor:Picture-datasets}%

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_save(\Texinfocommandstyletextvar{p}, \Texinfocommandstyletextvar{npicts}, \Texinfocommandstyletextvar{dataset})}
\Texinfocommandstyletextvar{p:} pointer to `\texttt{pict}'
\Texinfocommandstyletextvar{npicts:} integer
\Texinfocommandstyletextvar{dataset:} string
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

This function is useful for saving picture information generated
by graphics functions, such as `\texttt{plotlogreg}', that may require
lengthy execution times to generate pictures.
Saved picture datasets can be restored quickly by calling `\texttt{pict\_rest}'.

The function `\texttt{pict\_save}' saves the picture information
in the array of `\texttt{pict}'s \Texinfocommandstyletextvar{p} to
the datasets \Texinfocommandstyletextvar{dataset}.picXXXX, \Texinfocommandstyletextvar{dataset}.ptsXXXX, and
\Texinfocommandstyletextvar{dataset}.txtXXXX, where `\texttt{XXXX}' is the index of the `\texttt{pict}'
in the array.
If \Texinfocommandstyletextvar{npicts} is 0, then `\texttt{pict\_save}' only saves the elements
of `\texttt{p}' that are linked together, starting at the first element.
Otherwise, `\texttt{pict\_save}' saves \Texinfocommandstyletextvar{npicts} `\texttt{pict}'s in the array.
NOTE: graphics functions, such as `\texttt{plot}', link an extra `\texttt{pict}'
for each page or overlayed `\texttt{pict}'s for the axes.

The following details are not needed for saving
`\texttt{pict}' arrays generated by `\texttt{dap}' graphics functions.
`\texttt{Pict\_save}' calls itself to save patterns,
if any, referenced in elements of \Texinfocommandstyletextvar{p}
using \Texinfocommandstyletextvar{dataset}.patXXXX as the \Texinfocommandstyletextvar{dataset} argument.
Patterns must be either single `\texttt{pict}'s or linked arrays.
A link in the array \Texinfocommandstyletextvar{p} must always be to an element with an index
larger than the element linking to it. (This condition is always satisfied
by the `\texttt{pict}' arrays generated by graphics functions.)

\noindent{}\textbf{Code fragment(s)}

\emph{Save the 4 `\texttt{pict}'s in the linked array `\texttt{p}' in a picture
datasets with base name `\texttt{picture}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p[4];

pict\_save(p,\ 0,\ "picture");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Save the 4 `\texttt{pict}'s in the unlinked array `\texttt{p}' in a picture
datasets with base name `\texttt{picture}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict p[4];

pict\_save(p,\ 4,\ "picture");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Save the 10 `\texttt{pict}'s created by `\texttt{plotlogreg}' in a picture
datasets with base name `\texttt{grad}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict\_save(plotlogreg("grad",\ "grad/1",\ "GPA",\ "==",\ 5,\ "year",\ 2,\ 0.95),
\          10,\ "grad");
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{SPECIFICATION}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\textbf{pict\_rest( \Texinfocommandstyletextvar{dataset})}
\Texinfocommandstyletextvar{dataset:} string
\Texinfocommandstyletextvar{Returns:} pointer to `\texttt{pict}'
\end{Texinfopreformatted}
\end{Texinfoindented}

\noindent{}\textbf{Description}

Allocates an array of `\texttt{pict}'s and
restores into that array a picture saved
to \Texinfocommandstyletextvar{dataset} by `\texttt{pict\_save}'.

\noindent{}\textbf{Code fragment(s)}

\emph{Restore a picture from picture datasets with base
name `\texttt{picture}' into the array array `\texttt{p}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict *p;

p = pict\_rest("picture");
\end{Texinfopreformatted}
\end{Texinfoindented}

\emph{Restore and display a picture with 2 pages, created
by `\texttt{plotlogreg}', from picture datasets
with base name `\texttt{grad}':}
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily nport(pict\_rest("grad"),\ 8,\ 4);
\end{Texinfopreformatted}
\end{Texinfoindented}

\chapter{{Examples}}
\label{anchor:Examples}%

This chapter contains examples to illustrate the use
of dap. Data files, programs, and output for the examples
are provided in a directory named \texttt{examples}.


\section{{Analysis of variance}}
\label{anchor:Analysis-of-variance-examples}%
\index[in]{analysis of variance@analysis of variance}%
\index[in]{ANOVA@ANOVA}%

These examples are from:

\begin{itemize}
\item AMD: Milliken, G.A. and Johnson, D.E. 1984.
Analysis of Messy Data.  Van Nostrand Reinhold: New York. 473pp.

\item ED: Cochran, W.G. and Cox, G.M. 1957.
Experimental Designs.  John Wiley \& Sons: New York. 611pp.

\end{itemize}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily 
/* AMD pp.\ 128 - 134:\ unbalanced layout using SAS  */

data;
\ infile "amd128.dat" firstobs=2;\ /* space separated,\ skip 1 header line */
\ length treat \$ 6 block \$ 6;
\ input treat block y;

proc glm;
\ class treat block;
\ model y = treat block treat*block;
\ lsmeans treat block / tukey;

\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily /* AMD pp.\ 249 - 251:\ using SAS
\ * Two factors crossed,\ another nested within
\ * levels of one crossed factor
\ */

data;\ 
\ infile "amd249.dat" firstobs=2;
\ length a \$ 1 b \$ 1 c \$ 1;
\ input b c a y1 y2;\ /* two values per cell */
\ y = y1;
\ output;
\ y = y2;
\ output;

proc glm;
\ class a b c;
\ model y = a b a*b c*b a*c*b;
\ test h=a e=a*b;
\ test h=b e=a*b b*c a*b*c;
\ test h=a*b e=a*b*c;
\ test h=c*b e=a*c*b;

\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily 
/* AMD pp.\ 265 - 273 using SAS
\ * Random model,\ unbalanced
\ */

data;
\ infile "amd265.dat" firstobs=2;
\ length plant \$ 1 site \$ 1 worker \$ 1;
\ input plant worker site efficiency;

proc glm;
\ class plant site worker;
\ model efficiency = plant plant*worker plant*site plant*site*worker;
\ test h=site*plant e=site*worker*plant;

proc glm;
\ class plant site worker;
\ model efficiency = plant plant*worker site*worker*plant;
\ test h=worker*plant e=site*worker*plant;
\ test h=plant e=worker*plant site*worker*plant;


\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily 
/* AMD pp.\ 285 - 289 using SAS
\ * Mixed model,\ balanced
\ */

data;
\ infile "amd285.dat" firstobs=2;
\ length machine \$ 1 person \$ 1;
\ input machine person prod1 prod2 prod3;\ /* 3 observations per cell */
\ productivity = prod1;
\ output;
\ productivity = prod2;
\ output;
\ productivity = prod3;
\ output;

proc glm;
\ class machine person;
\ model productivity = machine person machine*person;
\ test h=person e=machine*person;
\ lsmeans machine / e=machine*person lsd;


\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily 
/* AMD pp.\ 290 - 295 using SAS
\ * Mixed model,\ unbalanced
\ */

data;
\ infile "amd290.dat" firstobs=2;
\ length machine \$ 1 person \$ 1;
\ input machine person productivity;

proc glm;
\ class machine person;
\ model productivity = machine person machine*person;
\ test h=person e=machine*person;
\ lsmeans machine / e=machine*person lsd;


\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily 
/* AMD pp.\ 297 - 308 using SAS
\ * Split plot
\ */

data;
\ infile "amd297.dat" firstobs=2;
\ length fertilizer \$ 1 block \$ 1 variety \$ 1;
\ input block variety fertilizer yield;

proc glm;
\ title "Whole plot (block,\ fertilizer) analysis";
\ class fertilizer block variety;
\ model yield = fertilizer block;
\ lsmeans fertilizer / e=fertilizer*block LSD;

proc glm;
\ title "Subplot (variety) analysis";
\ class fertilizer block variety;
\ model yield = fertilizer block variety
\               fertilizer*block fertilizer*variety;


\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily 
/* ED pp.\ 122 - 125 using SAS
\ * Latin square
\ */

data;
\ infile "ed122.dat" firstobs=2;
\ length sampler \$ 1 area \$ 1 order \$ 1;
\ input order area sampler error;

proc glm;
\ class sampler area order;
\ model error = sampler area order;
\ lsmeans sampler / lsd;

\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily 
/* ED pp.\ 176 using SAS and proc dap
\ * Without covariate,\ with contrasts
\ */

data muscle;
\ infile "sas976.dat" dlm="\textbackslash{}t" firstobs=3;
\ length rep \$ 1 time \$ 1 current \$ 1 number \$ 1;
\ input rep time current number y;

proc glm;
\ class rep current time number;
\ model y=rep current time number current*time current*number
\         time*number current*time*number;
\ contrast "curr 1 vs curr 2" current 1 -1;

/* To construct the constrast for testing "time in current 3",
\ * we have to modify the muscle.srt.mns.con file produced by glm.
\ */
proc dap;
\{\ /* start with brace to enclose everything */
\  inset("muscle.srt.mns.con")
\   \{
\     char rep[2],\ current[2],\ time[2];
\     double y;
\     char \_type\_[9];\ /* N,\ MEAN,\ VAR,\ ERROR,\ CONTR,\ LSMEAN */
\     int \_term\_;\ /* specifies term to which contrast applies */
\     int more;\ /* to control stepping through dataset */
\     double c1[4],\ c2[4],\ c3[4];\ /* contrast with 3 df */
\     outset("muscle.con",\ "");\ /* datast for the F-test */
\     /* set up the contrast coefficients */
\     c1[0] = 1;\ c1[1] = 0;\ c1[2] = 0;\ c1[3] = -1;
\     c2[0] = 0;\ c2[1] = 1;\ c2[2] = 0;\ c2[3] = -1;
\     c3[0] = 0;\ c3[1] = 0;\ c3[2] = 1;\ c3[3] = -1;
\     for (more = step();\ more;\ )
\      \{
\        output();\ /* N,\ MEAN,\ VAR */
\        step();
\        output();
\        step();
\        output();
\        for (step();\ strcmp(\_type\_,\ "CONTR");\ step()) /* get to CONTR lines */
\          output();
\        \_term\_ = 4;\ /* bits:\ 1 is rep,\ 2 is current,\ 4 is time */
\        if (!strcmp(current,\ "3")) /* only in current 3 */
\         \{
\           y = c1[time[0] - '1'];\ /* convert time to index */
\           output();
\           y = c2[time[0] - '1'];
\           output();
\           y = c3[time[0] - '1'];
\           output();
\         \}
\        else
\         \{
\           y = 0.0;
\           output();
\           output();
\           output();
\         \}
\        while (more \&\& !strcmp(\_type\_,\ "CONTR")) /* look for the ones we want */
\           more = step();
\        while (more \&\& !strcmp(\_type\_,\ "LSMEAN")) /* get to next cell or end */
\         \{
\           output();
\           more = step();
\         \}
\      \}
\   \}
\  /* muscle.con only has time in numerator so don't need to specify it */
\  ftest("muscle.con",\ "y rep current time number",\ "",\ "",\ "");
\}

\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily 
/* AMD pp.\ 173 - 177:
\ * missing treatment combinations
\ */

data amd173;
\ infile "amd173.dat" firstobs=2;
\ length treat \$ 2 block \$ 2;
\ input treat block y;

proc sort data=amd173;
\ by treat block;

proc means data=amd173 N MEAN VAR noprint;
\ var y;
\ by treat block;
\ output out=amd173.mns;

/* Now we have to create "by hand" the .con files for
\ * the custom F-tests for the contrasts that are meaningful
\ * in the presence of empty cells.
\ */
/* The first F-test (p.\ 175-76) is the interaction:
\ * m11 - m13 - m21 + m23 = 0 and m21 - m22 - m31 + m32 = 0
\ */
proc dap;
\{\ /* start with a brace to enclose everything here */
\  inset("amd173.mns") /* file from model statement */
\   \{
\     char treat[3],\ block[3];\ /* we're in C here!\ */
\     double y;
\     char \_type\_[9];\ /* set this to CONTR */
\     int \_term\_;\     /* bits specify the effect */
\     double c1[7],\ c2[7];\ /* coeffs of the contrasts */
\     int c;\ /* cell number */
\     outset("amd173.mns.con",\ "treat block y \_term\_");
\     /* cells,\ in sort order,\ are:
\     /*   11       13       21       22      23       31      32 */
\     c1[0]=1;c1[1]=-1;c1[2]=-1;c1[3]= 0;c1[4]=1;c1[5]= 0;c1[6]=0;
\     c2[0]=0;c2[1]= 0;c2[2]= 1;c2[3]=-1;c2[4]=0;c2[5]=-1;c2[6]=1;
\     \_term\_ = 3;\ /* bit 1 for treat,\ bit 2 for block */
\     for (c = 0;\ step();\ c++) /* while there's another cell */
\      \{
\        output();\ /* N,\ MEAN,\ VAR */
\        step();
\        output();
\        step();
\        output();
\        strcpy(\_type\_,\ "CONTR");
\        y = c1[c];
\        output();
\        y = c2[c];
\        output();
\      \}
\   \}
\  ftest("amd173.mns.con",\ "y treat block",\ "treat*block",\ "",\ "");

/* The second F-test (p.\ 176-77) is the treat effect:
\ * m11 + m13 - m21 - m23 = 0 and m21 + m22 - m31 - m32 = 0
\ */
\  inset("amd173.mns") /* file from model statement */
\   \{
\     char treat[3],\ block[3];\ /* we're in C here!\ */
\     double y;
\     char \_type\_[9];\ /* set this to CONTR */
\     int \_term\_;\     /* bits specify the effect */
\     double c1[7],\ c2[7];\ /* coeffs of the contrasts */
\     int c;\ /* cell number */
\     outset("amd173.mns.con",\ "treat block y \_term\_");
\     /* cells,\ in sort order,\ are:
\     /*   11      13       21      22       23       31      32 */
\     c1[0]=1;c1[1]=1;c1[2]=-1;c1[3]=0;c1[4]=-1;c1[5]= 0;c1[6]= 0;
\     c2[0]=0;c2[1]=0;c2[2]= 1;c2[3]=1;c2[4]= 0;c2[5]=-1;c2[6]=-1;
\     \_term\_ = 1;\ /* bit 1 for treat */
\     for (c = 0;\ step();\ c++) /* while there's another cell */
\      \{
\        output();\ /* N,\ MEAN,\ VAR */
\        step();
\        output();
\        step();
\        output();
\        strcpy(\_type\_,\ "CONTR");
\        y = c1[c];
\        output();
\        y = c2[c];
\        output();
\      \}
\   \}
\  ftest("amd173.mns.con",\ "y treat block",\ "treat",\ "",\ "");
\}

\end{Texinfopreformatted}
\end{Texinfoindented}


\section{{Linear regression}}
\label{anchor:Linear-regression-examples}%
\index[in]{linear regression@linear regression}%
\index[in]{regression, linear@regression, linear}%

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily /* Bickel,\ P.J.\ and Doksum,\ K.A.\ 1977
\ * Mathematical Statistics:
\ * Basic Ideas and Selected Topics
\ * Holden-Day:\ Oakland.\ 493.pp.
\ * Example pp.\ 95 - 97.
\ */

data;
\  infile "ms95.dat" firstobs=2;
\  input soilphos plantphos;

proc reg;
\ model plantphos = soilphos;
\ plot phantphos * soilphos;


\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily /* Rao,\ C.R.\ and Toutenberg,\ H.\ 1995 using SAS
\ * Linear Models:\ Least Squares and Alternatives
\ * Springer-Verlag:\ New York.\ 352 pp.
\ * Example pp.\ 50 - 60.
\ */

data;
\  infile "lm50.dat" firstobs=2;
\  input y x1 x2 x3 x4;

proc corr;
\ var x1 x2 x3 x4 y;
\ title "Correlations";

proc reg;
\ model y = x4;
\ title "Model building";

proc reg;
\ model y = x4;
\ add x1;

proc reg;
\ model y = x4 x1;
\ add x3;

proc reg;
\ model y = x4 x1 x3;
\ add x2;

\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Categorical data analysis}}
\label{anchor:Categorical-data-analysis-examples}%
\index[in]{contingency table@contingency table}%
\index[in]{cross classification@cross classification}%
\index[in]{cross tabulation@cross tabulation}%
\index[in]{chi-squared@chi-squared}%
\index[in]{Cochran-Mantel-Haenszel@Cochran-Mantel-Haenszel}%
\index[in]{ordinal@ordinal}%
\index[in]{categorical data@categorical data}%
\index[in]{binary@binary}%

These examples are from CDA: Agresti, A.  1990.  Categorical Data Analysis.
John Wiley \& Sons: New York.  558pp.

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily /* CDA pp.\ 49 - 50 using SAS */

data;
\ infile "cda50.dat" firstobs=2;
\ length income \$ 5 jobsat \$ 10;
\ input income jobsat count;

proc freq;
\ tables income * jobsat / measures chisq expected
\                          norow nocol nopercent;
\ weight count;

\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily /* CDA pp.\ 232 - 233 using SAS */

data;
\ infile "cda233.dat" firstobs=2;
\ length penicillin \$ 5 delay \$ 4 response \$ 5;
\ input penicillin delay response count;

proc freq;
\ tables penicillin * delay * response / norow nocol nopercent cmh;
\ weight count;


\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily /* CDA pp.\ 135 - 138,\ 171 - 174,\ 176 - 177
\ * Here we fit loglinear models in table 6.3 on p.\ 172
\ */
\#include <dap.h>

void main()
\{
\  infile("cda171.dat",\ " ")
\    \{
\      char defendant[6],\ victim[6],\ penalty[4];
\      double n;
\      input("defendant victim penalty n");
\      outset("cda171",\ "");
\      skip(2);
\      while (step())
\        output();
\    \}

\  sort("cda171",\ "defendant victim penalty",\ "");

\  title("(DV,\ P) vs (D,\ V,\ P)");
\  loglin("cda171.srt",\ "n defendant victim penalty",
\         "victim penalty defendant",\ "defendant*victim penalty",\ "");

\  sort("cda171.srt.llm",\ "defendant victim \_type\_ penalty",\ "");
\  table("cda171.srt.llm.srt",\ "defendant victim",\ "\_type\_ penalty n",
\        "s6.2 30",\ "");

\  title("(DV,\ VP) vs (DV,\ P)");
\  loglin("cda171.srt",\ "n defendant victim penalty",
\         "defendant*victim penalty",
\         "defendant*victim victim*penalty",\ "");
\  sort("cda171.srt.llm",\ "defendant victim \_type\_ penalty",\ "");
\  table("cda171.srt.llm.srt",\ "defendant victim",\ "\_type\_ penalty n",
\        "s6.2 30",\ "");

\  title("(DV,\ DP,\ VP) vs (DV,\ VP)");
\  loglin("cda171.srt",\ "n defendant victim penalty",
\         "defendant*victim victim*penalty",
\         "defendant*victim defendant*penalty victim*penalty",\ "");
\  sort("cda171.srt.llm",\ "defendant victim \_type\_ penalty",\ "");
\  table("cda171.srt.llm.srt",\ "defendant victim",\ "\_type\_ penalty n",
\        "s6.2 30",\ "");
\}

\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily 
/* CDA pp.\ 261 - 269
\ * Here we fit the logit model for linear-by-linear association
\ * to Table 8.2 on page 268.
\ */
\#include <dap.h>

double expect(double param[8],\ double class[2]);

void main()
\{
\  infile("cda262.dat",\ " ")
\    \{
\      char Income[6],\ JobSat[10];
\      double income,\ jobsat,\ count;
\      input("Income JobSat count");
\      outset("cda262",\ "");
\      skip(1);
\      while (step()) 
\        \{
\          /* we have to convert to double for categ */
\          if (!strcmp(Income,\ "<6"))
\            income = 0.0;
\          else if (!strcmp(Income,\ "6-15"))
\            income = 1.0;
\          else if (!strcmp(Income,\ "15-25"))
\            income = 2.0;
\          else if (!strcmp(Income,\ ">25"))
\            income = 3.0;
\          if (!strcmp(JobSat,\ "VeryDis"))
\            jobsat = 0.0;
\          else if (!strcmp(JobSat,\ "LittleDis"))
\            jobsat = 1.0;
\          else if (!strcmp(JobSat,\ "ModSat"))
\            jobsat = 2.0;
\          else if (!strcmp(JobSat,\ "VerySat"))
\            jobsat = 3.0;
\          output();
\        \}
\    \}

\  \{
\    double param[8];
\    int p;

\    param[0] = 1.0;
\    for (p = 1;\ p < 8;\ p++)
\      param[p] = 0.0;
\    categ("cda262",\ "count income jobsat",\ \&expect,\ param,
\          "mu <6 6-15 15-25 VD LD MS ?Inc*Sat",\ "",\ "");
\    sort("cda262.cat",\ "income \_type\_ jobsat",\ "");
\    table("cda262.cat.srt",\ "income",\ "\_type\_ jobsat count",\ "6.2",\ "");
\  \}
\}

/* We use an independent subset of the parameters in order to
\ * incorporate the zero-sum constraints.\ Thus,\ if class[0] == 3,
\ * for example,\ then we use the fact that lambda\^{}\{income\}\_\{>25\}\ is
\ * minus the sum of the other lambda\^{}\{income\}\ parameters.
\ */
double expect(double param[8],\ double class[2])
\{
\  double lx,\ ly;

\  if (class[0] < 3.0)
\    lx = param[1 + (int) class[0]];
\  else
\    lx = -(param[1] + param[2] + param[3]);
\  if (class[1] < 3.0)
\    ly = param[4 + (int) class[1]];
\  else
\    ly = -(param[4] + param[5] + param[6]);
\  return exp(param[0] + lx + ly + param[7] * class[0] * class[1]);
\}

\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Logistic regression}}
\label{anchor:Logistic-regression-examples}%
\index[in]{logistic regression@logistic regression}%
\index[in]{regression, logistic@regression, logistic}%

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily /* Agresti,\ A.\  1990.\  Categorical Data Analysis.
\ * John Wiley \& Sons:\ New York.\  558pp.
\ * Example pp.\ 87 - 89 using SAS with proc dap
\ */
data cda88;
\  infile "cda88.dat" firstobs=2;
\  input labind ncases nremiss;

proc dap;
nport(plotlogreg("cda88",\ "nremiss/ncases",\ "labind",
\                 "== MAXX40 NXTICKS5 MAXY1 NYTICKS6 NYDIGITS2 NXDIGITS1",
\                 5,\ "",\ 1,\ 0.95),\ 4,\ 4);


\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Standard graphical output}}
\label{anchor:Standard-graphical-output}%

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily /* Using plotmeans to plot means,\ both as symbols
\ * and joined by lines,\ and 95\% confidence intervals
\ * of two groups of data together.
\ */
\#include <dap.h>

void main()
\{
infile("standard.dat",\ " ")
\  \{
\    int part;
\    double x,\ y;

\    input("x y part");
\    outset("mtest",\ "");
\    while (step())
\      output();
\  \}

title("Means of y.\ Error bars are 95\% confidence for means");
\  \{
\    pict *p;

\    sort("mtest",\ "part x",\ "");
\    p = plotmeans("mtest.srt",\ "y",\ "x",\ "SEM 1.96",\ "part",\ 2);
/* p[0] and p[1] are error bars and means as points for group 1 */
\    strcpy(p[1].pict\_type,\ "TRIA");
/* p[2] and p[3] are error bars and means as points for group 2 */
\    strcpy(p[3].pict\_type,\ "SQUA");

\    nport(p,\ 4,\ 4);
\  \}
\}
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Custom graphics}}
\label{anchor:Custom-graphics}%

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily /* This example illustrates the construction
\ * of custom graphics.\  We create two distributions
\ * and display them as a split histogram:\ the bars
\ * of one distribution extend horizontally to the
\ * left and the bars of the other extend
\ * horizontally to the right and are shaded.
\ */
\#include <dap.h>

\#define NBARS 10

void main()
\{
\ /* these variables are not in the datasets */
double min,\ max;\  /* extremes of both
\                   * distributions together
\                   */
double width;\     /* width of the bars */

infile("custom.dat",\ " ")
\  \{
\    double x;
\    int part;

\    input("x part");
\    outset("split",\ "");
\    while (step())
\      output();
\  \}

means("split",\ "x",\ "MIN MAX",\ "");\ /* find min,\ max */
inset("split.mns")
\  \{
\    double x;
\    int n;
\    char \_type\_[9];

\    for (n = 0;\ n < 2;\ n++)
\      \{
\        step();\             /* and store them */
\        if (!strcmp(\_type\_,\ "MIN"))
\          min = x;
\        else
\          max = x;
\      \}
\  \}

width = (max - min) / ((double) NBARS);

inset("split")      /* compute class for each x */
\  \{
\    double x;
\    int class;

\    outset("class",\ "x class part");
\    while (step())
\      \{
\        class = (int) floor((x - min) / width);
\        if (class < 0)
\          class = 0;
\        else if (class > NBARS - 1)
\          class = NBARS - 1;
\        output();
\      \}
\  \}

sort("class",\ "part class",\ "");
/* compute counts in each class for each distribution */
means("class.srt",\ "count",\ "N",\ "part class");

\  \{
\  pict p[21];\  /* one pict for each class for each part
\                * plus one for the axes
\                */
\  int pn;

\  pict\_initpict(NULL,\ p);\  /* initialize the pict structs */
\  for (pn = 1;\ pn < 21;\ pn++)
\    pict\_initpict(p + pn - 1,\ p + pn);

\  inset("class.srt.mns")
\    \{
\      int part,\ class;
\      double classmin,\ count;

\      while (step())
\        \{
\          classmin = min + width * ((double) class);
\          /* make a rectangle */
\          pict\_rectangle(p + NBARS * part + class,
\              0.0,\ classmin,\ (part ?\ count :\ -count),\ width);
\          /* shade the ones on the right */
\          if (part)
\            p[NBARS * part + class].pict\_fgray = 0.8;
\        \}
\    \}
\  /* set up the axes */
\  pict\_autoaxes(p,\ "Count",\ "X",\ "==",\ \&fabs,\ NULL,
\                          "Split histogram",\ 1);
\  /* and make it all appear */
\  pict\_port(1);
\  pict\_page();
\  pict\_show(p);
\  pict\_end();
\  \}
\}
\end{Texinfopreformatted}
\end{Texinfoindented}

\chapter*{{Appendix I: Settable parameters}}
\label{anchor:Appendix-I}%

The following list of settable parameters and their
default values is in \texttt{dap.h}:
\index[in]{execution@execution}%
\index[in]{parameters@parameters}%
\index[in]{constants@constants}%
\index[in]{settable parameters@settable parameters}%

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily /* Parameters for variables */
DAP\_MAXVAR 256  /* max number of variables in a dataset */
\                /* if changed to >= 10,000,\ change dimstr in dap0.c */
DAP\_NAMELEN 15  /* max length of variable names (+1 for null) */
DAP\_INTLEN 20  /* max number of char in char representation of int */
DAP\_LISTLEN (256 * (16 + 6))
\ /* max length of list of variables:\ dap\_maxvar *
\  * (max var name length + room for bracketed index)
\  * This may not be entirely safe!\ (but most likely is)
\  */
DAP\_TOOLONG 10 /* max \# times to print "string too long" message */
DAP\_STRLEN 63  /* max length of some string values */

/* Parameters for tables */
DAP\_MAXROWS 1024  /* max rows for table() */
DAP\_MAXCOLS 64  /* max columns for table() */
DAP\_MAXCLAB 128  /* max number of column labels */
DAP\_MAXROWV 8  /* max number of row variables */
DAP\_MAXCOLV 8  /* max number of column variables */
DAP\_LABLEN 63  /* max number of non-null char in column label */

/* Parameters for datasets */
DAP\_SETDIR "dap\_sets"  /* where datasets are stored */
DAP\_MAXVAL 32768  /* max number of values for some stat functions*/
DAP\_MAXCELL 512  /* max number of cells in some internal tables */
DAP\_MAXTREAT 9  /* max number of factors for ANOVA */

/* Parameters for grouping */
DAP\_MAXBARS 128  /* max number of bars for histograms,\ grouping */
DAP\_MAXLEV 96  /* max number of levels of a variable */

/* Parameters for I/O */
DAP\_LINELEN 2047  /* max number of char for input line (+1 for null) */
DAP\_OUTREPORT 100000
\   /* report multiples of this number of lines written */

/* Parameters for graphics */
DAP\_MAXPTS 16384  /* max number of points in a pict */
DAP\_MAXCHAR 65536  /* max number of text chars in all the picts */
DAP\_MAXNTXT 128  /* max number of text chars in a pict */
DAP\_MAXTXT 127   /* max number of chars in a single string */
DAP\_MAXFONT 63   /* max number of chars in a font name */

/* Parameters for numerical algorithms */
DAP\_REDTOL 1e-9 /* to tell if row is zero in reduction */
DAP\_ORTHTOL 1e-9 /* to tell if row is zero in orthog */
DAP\_ZEROTOL 1e-6 /* to tell if row is zero in matrix ops */
DAP\_TOL 1e-8    /* for pivoting,\ etc.\ in matrix ops */
DAP\_CTOL 1e-6   /* for iterative reweighted least sq (logreg) */
DAP\_KTOL 1e-6   /* for significance of Kolmogorov statistic */
DAP\_PRTOL 1e-6  /* for inverse prob functs:\ should disappear */
DAP\_ADDTOZERO 1e-8  /* for contingency tables */
DAP\_MAXITER 500 /* max number of iterations */
DAP\_MAXEX1 20  /* max number of values for exact test */
DAP\_MAXEX2 20  /* max number of values for exact test */
DAP\_CATTOL 0.0000005 /* tolerance for convergence in categ() */

/* Parameters for memory files */
DAP\_NRFILES 128  /* number of files stored in memory */
DAP\_RFILESIZE 16384  /* max number of bytes in a memory file */
DAP\_MAXLINES 2048  /* max number of lines in memory file:
\                    * keep at dap\_rfilesize / 8
\                    */
DAP\_MAXMEM 1048576 /* memory buffer size for sorting */
DAP\_TMPDIR "dap\_tmp" /* directory for temporary files for sorting */

/* Memory allocation tracing */
DAP\_MEMTRACE NULL  /* if non-NULL,\ print trace of malloc and free
\                    * and if address = dap\_memtrace,\ then...
\                    */
DAP\_MABORT 0  /* abort on malloc */
DAP\_FABORT 0  /* abort on free */
\end{Texinfopreformatted}
\end{Texinfoindented}

\chapter*{{Appendix II: Essentials of C syntax}}
\label{anchor:Appendix-II}%

This appendix explains the most basic syntax of C needed for using dap.
There are many books to which you can refer for more detailed or
more advanced descriptions of C.
Note that the GNU editor \texttt{emacs} has special provisions for editing
C programs.


\section{{Variables and operations}}
\label{anchor:Variables-and-operations}%

A \textsl{variable} is a box in which one or more numbers or characters,
or even more complicated objects called \textsl{structures}, are stored.
You \emph{must} use a \textsl{declaration}
\index[in]{variable@variable}%
\index[in]{unknown variable@unknown variable}%
\index[in]{undeclared@undeclared}%
\index[in]{declaration@declaration}%
to indicate exactly what kind of contents the box will hold and what
name you are going to use to refer to the box before you
use the box to store anything or else the computer won't know
what kind of information is stored in the box and how to use it.
(Names must contain only letters and numbers and `\texttt{\_}' and
must not start with a number.)
For example,

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily int n;
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}is a declaration that
indicates that the box named `\texttt{n}' will hold an integer
\index[in]{int@int}%
(whole number).
Non-integer numbers, such as `\texttt{2.718}', are referred to as
\textsl{double precision floating point} numbers, or simply as
\textsl{doubles}.
\index[in]{double@double}%
For example,

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double x;
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}is a declaration that
indicates that the box named `\texttt{x}' will hold a double.
There is a special value called \textsl{NaN},
\index[in]{NaN@NaN}%
which stands for \textsl{Not-a-Number}, for undefined values
of a double.

Numbers and characters and structures can each be grouped into
ordered collections known as \textsl{arrays};
\index[in]{array@array}%
arrays of characters
are called \textsl{strings}.
\index[in]{string@string}%
For example, the declaration

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily char employee[21];
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}indicates that the box named `\texttt{employee}' will hold a
string of 21 characters, say, the employee's name.
The last character of a string of characters is usually used to hold
a special character that marks the end of the string, so that `\texttt{employee}'
will really be limited to 20 ordinary characters.
The character that marks the end of a string is called the
\textsl{null character} and is denoted `\texttt{\textbackslash{}0}'.

You can also declare, for example,

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily double y[3];
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}to indicate a box that will hold 3 doubles.
Brackets `\texttt{[}' and `\texttt{]}' also allow you to
refer to the individual doubles in the array: the three elements
of `\texttt{y}' are `\texttt{y[0]}', `\texttt{y[1]}', and `\texttt{y[2]}'.
(The numbering of array elements always starts at 0.)
Such referencing can be used for arrays of characters, integers, or
structures, too.

The most common kind of structure in dap is the `\texttt{pict}' structure,
which contains graphical information that
is used by graphics functions; `\texttt{pict}'s are
most often collected into arrays.
In some cases you may not know for certain or care how many
`\texttt{pict}' structures are in the array, in which case you can use
a declaration like this:

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily pict *p;
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}which indicates that the graphics function that sets up the
array of picts to be stored in
the box named `\texttt{p}' will allow for however
many picts that graphics function needs.
In this case, `\texttt{p}' is usually referred to as a \textsl{pointer}
\index[in]{pointer@pointer}%
to `\texttt{pict}', and in that sense, `\texttt{p}'
is interpreted as the location in the computer's memory
of the first `\texttt{pict}' in the array.
Nevertheless, you can still refer to the `\texttt{pict}'s in the
array as `\texttt{p[0]}', `\texttt{p[1]}', etc.

The pointer
\index[in]{pointer@pointer}%
concept, as a location in the computer's memory,
is used in other contexts, too.
One use is to be able to distinguish between
a string that has no interesting characters in it, that is,
a string whose first character is the null character, and
a string that doesn't exist at all.
The former is called a \textsl{null string},
\index[in]{null string@null string}%
\index[in]{string, null@string, null}%
and is denoted `\texttt{""}',
and the latter is called a \textsl{null pointer}, and is
denoted `\texttt{NULL}'.
\index[in]{NULL@NULL}%
Another use of pointers
involves functions, which are described in the next section.
Functions have locations in the computer's memory and can be referred to by
pointers: if `\texttt{f}' is a function, then `\texttt{\&f}' is a pointer
to that function.

There are many operations that can be used on variables, but the most common
operations are copying and arithmetic operations.  For example, the
\textsl{statement}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily x = y + z;
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}computes the sum of the numbers in the boxes named `\texttt{y}' and `\texttt{z}'
and copies that sum into the box named `\texttt{x}'; note that the contents
of `\texttt{y}' and `\texttt{z}' are unchanged.  Note that the paradoxical-looking
statement

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily x = -x;
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}says to copy the negation of the contents of `\texttt{x}' back into `\texttt{x}'.
Copying strings is more complicated and is described in the
next section.

Two very common arithmetic
operations that can be used only on `\texttt{int}' variables
are `\texttt{++}', `\texttt{{-}{-}}':  For example, the statement

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily n++;
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}increments, i.e., increases by 1, the number stored in `\texttt{n}'.
Similarly,

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily n{-}{-};
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}decrements, i.e., decreases by 1, the number stored in `\texttt{n}'.

\section{{Functions}}
\label{anchor:Functions}%

\textsl{Functions} are program parts that are usually stored in \textsl{libraries}
and can be used from a program.  For example, a dap program could contain
the statement

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily means("data",\ "x",\ "SUM",\ "");
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}which \textsl{calls}, i.e., uses,
the function `\texttt{means}', which is stored in a library
that is supplied with dap, to compute the sum of the values of the
variable `\texttt{x}' in the dataset `\texttt{data}'.  The comma-separated,
quoted strings `\texttt{"data"}', `\texttt{"x"}', `\texttt{"SUM"}', and `\texttt{""}'
are called \textsl{arguments} to the function and they tell the function
what to operate on and how.  This particular function will create
a dataset named `\texttt{data.mns}' that will contain the computed sum.

Two functions that are not supplied with dap but that are available
nonetheless in the standard C library and that are commonly used in dap programs are
`\texttt{strcpy}'
\index[in]{strcpy@strcpy}%
\index[in]{copying strings@copying strings}%
\index[in]{strings, copying@strings, copying}%
and `\texttt{strcmp}'.  The first is used for copying strings and
the second is used for comparing strings.
For example, following the declaration

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily char employee[21];
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}you could write the statement

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily strcpy(employee,\ "Bassein,\ Susan");
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}which calls the `\texttt{strcpy}' function
to copy the 14 characters between the quotes into the
string `\texttt{employee}' and follow it with the null character, for a total
of 15 characters.
NOTE: An explicit string of characters must be enclosed in double quotes
\index[in]{quotes@quotes}%
("..."), not single quotes ('...').
WARNING: Serious program bugs
\index[in]{bug@bug}%
can be caused by copying more characters
into a string than are allotted in the declaration!

The `\texttt{strcmp}'
\index[in]{strcmp@strcmp}%
\index[in]{comparing strings@comparing strings}%
\index[in]{strings, comparing@strings, comparing}%
function is typically used in loops and
`\texttt{if}'s and is described in the next section.

Functions can also \textsl{return a value}, which means that the function
can provide a value that can be copied into a variable.
For example, after the declaration

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily int more;
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}you could write

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily more = step();
\end{Texinfopreformatted}
\end{Texinfoindented}

This statement calls the function `\texttt{step}',
which attempts to read one line from the input data file or
dataset and then returns the integer 1 or 0, if there was or was not,
respectively, another line to be read from the file or dataset. 
(Note that although `\texttt{step}' does not require any arguments, the
parentheses are still necessary, to identify it as a call to a function.)
Thus, `\texttt{more}' would contain the value 1 if `\texttt{step}' successfully read
another line or the value 0 if the previous call to `\texttt{step}' had read
the last line in the input data file or dataset.

You can also define functions in your program.  In particular, `\texttt{main}'
\index[in]{main@main}%
is a function that must appear in every dap program.  The \textsl{body} of
the definition of a function must always be enclosed between `\texttt{\{}'
and `\texttt{\}}'.
The example program cda262.c (see \hyperref[anchor:Categorical-data-analysis-examples]{Section~\ref*{anchor:Categorical-data-analysis-examples} [Categorical data analysis examples], page~\pageref*{anchor:Categorical-data-analysis-examples}})
illustrates the definition and use of a function required by
the categorical data analysis function `\texttt{categ}'
to compute expected cell frequencies from parameter values.

\section{{Loops and `\texttt{if}'s}}
\label{anchor:Loops-and-ifs}%

\textsl{Loops} allow an action to be repeated, either until some condition
arises or for a fixed number of times.  The most common loop in dap
programs looks like this (with possible enhancements):

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily while (step())
\  output();
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}This loop repeats reading a line from the input data file or dataset
and writing the data to the output dataset until
there are no more lines to be read.
More specifically, it attempts to read a line and
if there was a line to be read, it writes the data to the output dataset and
attempts to read the next line; otherwise it
\textsl{breaks out of the loop} and continues to the next line of the program.
Note that a value of 1 (or, in fact, any non-zero value) is taken to mean
\textsl{TRUE} and a value of 0 is taken to mean \textsl{FALSE}, so that these lines
can be interpreted as saying, "While (i.e., as long as)
it is TRUE that step has read another
line, output the data from that line".

A `\texttt{for}' loop can be used
to read, say, the first 100 lines of the input data file or dataset:

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily int n;

for (n = 1;\ n <= 100;\ n++)
\  \{
\    step();
\    output();
\  \}
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}The `\texttt{for}' statement has three parts within the parentheses, separated by semi-colons:
the \textsl{initialization}, `\texttt{n = 1}', which starts the loop; the
\textsl{test}, `\texttt{n <= 100}', which acts as though it is inside the parentheses
in a `\texttt{while}' statement; and the \textsl{increment}, `\texttt{n++}', which gets
performed after each repetition of the body of the `\texttt{for}' loop.
(Note that the body of the `\texttt{for}' in this case must be enclosed between
`\texttt{\{}' and `\texttt{\}}' because, unlike the body of the `\texttt{while}' above, it
contains more than one statement.)

The previous example will fail if there are fewer than 100 lines in the input
data file or dataset because `\texttt{step}' will stop your program if you try
to read another line of the input data file or dataset
after a previous call to `\texttt{step}' has returned a 0.
One better alternative would be to use an
`\texttt{if}':

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily int n;

for (n = 1;\ n <= 100;\ n++)
\  \{
\    if (step())
\      output();
\    else
\      break;
\  \}
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}In this example, the `\texttt{break}' causes the program to break out of the loop
when `\texttt{step}' returns a 0.

Suppose you wanted to write into the output dataset
all the lines from the input data file
for which the `\texttt{employee}' was named "Bassein, Susan".
You could use the
\textsl{logical negation} operator `\texttt{!}' with the string comparison function
`\texttt{strcmp}'
\index[in]{strcmp@strcmp}%
\index[in]{comparing strings@comparing strings}%
\index[in]{strings, comparing@strings, comparing}%
as follows:

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily char employee[21];

while (step())
\  \{
\    if (!strcmp(employee,\ "Bassein,\ Susan"))
\      output();
\  \}
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}because `\texttt{strcmp}' returns 0 if the strings are the
same and a non-zero number otherwise and `\texttt{!}' turns a 0 into a 1
and a non-zero integer into 0.

The C language provides two operators that allow you to combine conditions
to be tested in `\texttt{while}', `\texttt{for}', and `\texttt{if}' statements:
logical \textsl{and}, `\texttt{\&\&}', and logical \textsl{or}, `\texttt{||}'.
For example, the previous code could be modified to select only those
records for "Bassein, Susan" that had a value greater than or
equal to 10 for a variable named `\texttt{hours}':

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily char employee[21];
double hours;

while (step())
\  \{
\    if (!strcmp(employee,\ "Bassein,\ Susan") \&\& hours >= 10.0)
\      output();
\  \}
\end{Texinfopreformatted}
\end{Texinfoindented}

\chapter*{{Appendix III: Troubleshooting}}
\label{anchor:Appendix-III}%
\index[in]{bug@bug}%
\index[in]{troubleshooting@troubleshooting}%

Many things can go wrong with a program.
At the simplest level, there can be an error in \textsl{syntax},
\index[in]{syntax@syntax}%
which would cause the preprocessor or the compiler to be unable
to interpret what is meant by a statement.
For example, a syntax error commonly made by novices is to
forget to include the semi-colon
\index[in]{semi-colon@semi-colon}%
that is required at the end
of every declaration or statement.
Another common error is to have a left brace `\texttt{\{}' without a
matching right brace `\texttt{\}}' (or vice versa);
using appropriate indentation in your program and the features
of your text editor will help you find
unmatched braces.
If your program has a syntax error,
you will get a message indicating the line number
of the statement containing
the error and why the preprocessor or the compiler
couldn't interpret that statement.
(Missing semi-colons often confuse the compiler so badly
that the error message can be hard to interpret.)
In that case, you simply edit your program to correct the error
and compile and run it again.

If your program uses too many variables, lines that are too long, 
variable names or strings that are too long, etc., then you will
get a message that indicates the problem during execution.
You can solve that problem by setting the value of the appropriate
parameter
\index[in]{settable parameters@settable parameters}%
as described in \hyperref[anchor:Reading-files-and-datasets]{Section~\ref*{anchor:Reading-files-and-datasets} [Reading files and datasets], page~\pageref*{anchor:Reading-files-and-datasets}}.

More serious bugs will result in the program \textsl{crashing}, which
means that the program will stop before completing
its task, often with no output of any sort.
In that case, the system will produce a file named \texttt{core}, which
is a snapshot of what point the program reached when it crashed.
If that happens, exit dap and use a \textsl{debugger} to examine the
core file.  For example, to use the GNU debugger \texttt{gdb} on the
core file produced by a crash in prog.c, you would type

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily gdb prog.dap core
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}Then, typing

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily where
\end{Texinfopreformatted}
\end{Texinfoindented}
\noindent{}will tell you the number of the line reached by your program,
and the functions that it called, when the program crashed.
A debugger is a powerful and somewhat complicated program; you should
read at least some of its documentation before you use it.

If a program doesn't crash but still doesn't produce output, most probably
it is executing in an \textsl{infinite loop}, that is, a loop whose condition
for terminating is never met.  Such a situation is particularly
dangerous if there is a call to `\texttt{output}' in tha loop, so that
more and more lines are being written to the output dataset, which therefore
runs the risk of completely filling up your disk.
You can terminate
\index[in]{terminate@terminate}%
\index[in]{abort@abort}%
\index[in]{stop@stop}%
a program by typing \textsl{control-C} (\emph{twice}, if you are using the
Emacs interface) which means pressing both the
\Texinfocommandstyletextkbd{Control} (or \Texinfocommandstyletextkbd{Ctrl}) key and the \Texinfocommandstyletextkbd{C} key at the same time.

Still more serious bugs will result in the program giving nonsense
results.
Often, you can track down such bugs by inserting calls
to the dap `\texttt{print}' function at strategic points
in your program, and running the program again,
to display intermediate files to see where the program started
to have problems.
If that fails, a debugger is a good tool for tracking down
unintended values of your variables.

The most serious bugs will result in the program giving sensible-looking
but wrong results.
To catch bugs of that sort requires a thorough understanding of
approximately what your results should look like, some experience
with the statistical functions you are using, and a lot of patience.

\chapter*{{Appendix IV: SAS}}
\label{anchor:Appendix-IV}%

\index[in]{SAS syntax@SAS syntax}%
\index[in]{dap (SAS proc)@dap (SAS proc)}%
This section contains miscellaneous notes and warnings regarding
the use of SAS.
\textbf{WARNING}:
When processing \Texinfocommandstyletextvar{file}.sbs, dap writes (or overwrites)
the file \Texinfocommandstyletextvar{file}.c. Note that because the syntax
and options of SAS and dap graphics procedures are not very compatible,
many dap graphics options are not available in SAS (which is one reason
that I wrote dap in the first place); for complete access
to dap graphics options (or statistical options) from SAS,
use a `\texttt{proc dap}' statement (see below).
In addition, you can define your own functions in a separate `\texttt{.c}' file
that you include on the command line to run dap. (To declare such functions
in the `\texttt{.sbs}' file, use a `\texttt{proc dap}' statement at the beginning
of the file.)
Note that if the program does not use a graphics proc,
compiling will produce a number of warnings about unused variables, all of whose
names begin and end with an underscore `\texttt{\_}'; you may ignore them.

One peculiarity that SAS inherits from C through dap
is that character variables that are explicitly
used in a data step always need to appear in a `\texttt{length}' statement,
no matter whether the data step gets its data from a
`\texttt{set}', a `\texttt{merge}' or an `\texttt{infile}' statement.

Important notes regarding data steps (at least through this version of dap):

\begin{enumerate}[start=1]
\item Comparison, assignment, and concatenation of strings must be performed
using the C functions `\texttt{strcmp}' (or its variants),
`\texttt{strcpy}' (or its variants), and `\texttt{strcat}' (or its variants);

\item C-style subscripting (i.e., with `\texttt{[ ]}') must be used for obtaining
individual characters from a string except that in SAS, array indexes start at
1, not 0 as in C.

\item Mnemonics are not accepted for relational or logical operators (e.g., `\texttt{ne}'
is not accepted for `\texttt{\^{}=}');

\item The only statements accepted in the body of a data step, other than numerical
assignment statements, are `\texttt{if-then}', `\texttt{if-then-else}',
`\texttt{do}', `\texttt{do while}', `\texttt{end}', and `\texttt{output}';

\item \Texinfocommandstyletextvar{first}.variable is allowed by `\texttt{by}' groups, but not \Texinfocommandstyletextvar{last}.variable.

\item Syntax errors in the body of a data step may not be caught by the SAS-to-dap
translator, but will subsequently be caught by either the dap preprocessor
or the C compiler. However, the line numbers referred to by those programs will
be the line numbers of the dap program into which your SAS program was translated,
which you can view by opening up file \Texinfocommandstyletextvar{file}.c if you ran dap on \Texinfocommandstyletextvar{file}.sbs.

\end{enumerate}

\index[in]{data step (SAS)@data step (SAS)}%

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
data [\Texinfocommandstyletextvar{output-file-name} [(\{drop | keep\}=\Texinfocommandstyletextvar{variable} [... \Texinfocommandstyletextvar{variable}])];
length \Texinfocommandstyletextvar{variable-1} \$ \Texinfocommandstyletextvar{length-1} [... \Texinfocommandstyletextvar{variable-n} \$ \Texinfocommandstyletextvar{length-n}];
infile "\Texinfocommandstyletextvar{infile-name}" [\{delimiter | dlm\}="\Texinfocommandstyletextvar{delimeter}"]
                       [firstobs=\Texinfocommandstyletextvar{n}];
input \Texinfocommandstyletextvar{variable-1} [\Texinfocommandstyletextvar{start-col-1} [-\Texinfocommandstyletextvar{end-col-1}]]
      [... \Texinfocommandstyletextvar{variable-n} [\Texinfocommandstyletextvar{start-col-n} [-\Texinfocommandstyletextvar{end-col-n}]]];
set \Texinfocommandstyletextvar{dataset-name};
merge \Texinfocommandstyletextvar{dataset-name-1} [(\{drop | keep\}=\Texinfocommandstyletextvar{variable} [... \Texinfocommandstyletextvar{variable}])]
     \Texinfocommandstyletextvar{dataset-name-2} [(\{drop | keep\}=\Texinfocommandstyletextvar{variable} [... \Texinfocommandstyletextvar{variable}])];
by \Texinfocommandstyletextvar{variable-list};
\{drop | keep\} \Texinfocommandstyletextvar{variable-list};

\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{quote}
SAS note: for column input, it is not possible to skip columns, i.e.,
`\texttt{start-col-1}' must be 1 and each succeeding `\texttt{start-col}'
must be one more than the preceeding `\texttt{end-col}'.
\end{quote}

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
proc dap;
\Texinfocommandstyletextvar{dap-statement}

\end{Texinfopreformatted}
\end{Texinfoindented}

\begin{quote}
SAS note: \Texinfocommandstyletextvar{dap statement} can either be enclosed in braces `\texttt{\{\ \}}' or
end with a semi-colon `\texttt{;}'. Attempting to use dap graphics and SAS graphics in the
same program will produce unpredictable and, perhaps, undesirable results. Note
that \Texinfocommandstyletextvar{dap statement} is run as-is by dap and, in particular, indexes of array
subscripts start at 0. The \Texinfocommandstyletextvar{dap statement} cannot use
the `\texttt{0x}' prefix for hexidecimal numbers.
\end{quote}

\chapter*{{Frequently Asked Questions}}
\label{anchor:FAQ}%


\section{{I cannot find a function}}
\label{anchor:I-cannot-find-a-function}%

\textbf{Q:} I cannot find a function to delete spurious zeros from my
dataset without deleting anything else. What do I do?

\textbf{A:} You have to write some C code (see \hyperref[anchor:Appendix-II]{\chaptername~\ref*{anchor:Appendix-II} [Appendix II], page~\pageref*{anchor:Appendix-II}}) for that:
\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily while (step())
\  \{
\    if (yield > 0.0)
\      output();
\  \}
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{I want to split a dataset}}
\label{anchor:I-want-to-split-a-dataset}%

\textbf{Q:} I want to split a dataset based on the value of a
variable. How do I do that?

\textbf{A:} Assume that the variable to be used is a
character variable named `\texttt{part}' with 9 characters
(including the terminating null) and that dataset
\texttt{set} is sorted by `\texttt{part}'.
The following code fragment creates a dataset for each
value of `\texttt{part}' and names it that value.

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily inset("set")
\  \{
\    char part[9];
\    int partv[1];

\    daplist("part",\ partv,\ 1);
\    if (step())  /* to get started */
\      \{
\        outset(part,\ "");
\        output();
\        while (step())  /* to continue */
\          \{
\            if (dap\_newpart(partv,\ 1))
\              outset(part,\ "");
\            output();
\          \}
\      \}
\  \}
\end{Texinfopreformatted}
\end{Texinfoindented}

\section{{Logistic regression reported a singular matrix}}
\label{anchor:Logistic-regression-reported-a-singular-matrix}%

\textbf{Q:} Logistic regression reported a singular matrix, but my data seems OK.
\index[in]{logistic regression@logistic regression}%

\textbf{A:} You may need to lower the value of DAP\_CTOL (see \hyperref[anchor:Appendix-I]{\chaptername~\ref*{anchor:Appendix-I} [Appendix I], page~\pageref*{anchor:Appendix-I}}),
which is used to
zero-out matrix entries that appear to be non-zero only as the result of
round-off errors.


\section{{How do I add a line to a plot?}}
\label{anchor:How-do-I-add-a-line-to-a-plot_003f}%

\textbf{Q:} I plotted a dataset using `\texttt{plot}' and I want to add a line to it.
How do I do that without knowing the scaling and translating used by `\texttt{plot}'?

\textbf{A:} In your call to `\texttt{plot}', specify `\texttt{MINX}', `\texttt{MAXX}',
`\texttt{MINY}', and `\texttt{MAXX}'. Don't use `\texttt{nport}' or `\texttt{nland}'; rather use
`\texttt{pict\_port}', `\texttt{pict\_land}', or `\texttt{pict\_init}' to start the graphics section
of your program (and don't forget `\texttt{pict\_page}', `\texttt{pict\_show}',
and `\texttt{pict\_end}'). Then
declare an array of 2 `\texttt{pict}'s and use `\texttt{pict\_initpict}' to initialize them
as a list. Then use `\texttt{pict\_line}' on the first of these 2 picts and call
`\texttt{pict\_autoaxes}' with the same axis specifications (although you can
set `\texttt{NXTICKS}' and `\texttt{NYTICKS}' to 0 if you wish).
You can use the same axis labels, overwrite them, or leave them as null strings.
Finally, call `\texttt{pict\_show}'.

Here's an example:

\begin{Texinfoindented}
\begin{Texinfopreformatted}%
\ttfamily 
\#include <dap.h>

void main()
\{
\  infile (NULL,\ NULL)
\    \{
\      double x,\ y;
\      int n;
\      outset("gtest",\ "");
\      for (n = 0;\ n < 10;\ n++)
\        \{
\          x = varnorm();
\          y = varnorm();
\          output();
\        \}
\    \}
\  \{
\    pict *p,\ p1[2];

\    pict\_port(1);
\    pict\_page();

\    p = plot("gtest",\ "x y",\ "",\ "== MINX-4 MAXX4 MINY-4 MAXY4",
\             NULL,\ NULL,\ 1);
\    pict\_show(p);

\    pict\_initpict(NULL,\ p1);
\    pict\_initpict(p1,\ p1 + 1);
\    pict\_line(p1,\ -3.0,\ 2.0,\ 2.0,\ -1.0);
\    pict\_autoaxes(p1,\ "",\ "",
\                  "== MINX-4 MAXX4 MINY-4 MAXY4 NXTICKS0 NYTICKS0",
\                  NULL,\ NULL,\ "",\ 1);
\    pict\_show(p1);

\    pict\_end();
\  \}
\}

\end{Texinfopreformatted}
\end{Texinfoindented}

\chapter*{{Index}}
\label{anchor:Index}%

\printindex[in]


\end{document}
